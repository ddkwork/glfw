// Code generated by bindgen. DO NOT EDIT.
package glfw

import (
	"unsafe"

	"github.com/ddkwork/app/bindgen/bindlib"
)

const GengoLibraryName = "glfw"

var GengoLibrary = bindlib.NewLibrary(GengoLibraryName)

type _CrtLocaleDataPublic struct {
	_LocalePctype     *uint16
	_LocaleMbCurMax   int32
	_LocaleLcCodepage uint32
}
type _CrtLocalePointers struct {
	Locinfo unsafe.Pointer
	Mbcinfo unsafe.Pointer
}
type _Mbstatet struct {
	_Wchar uint64
	_Byte  uint16
	_State uint16
}
type Vidmode struct {
	// The width, in screen coordinates, of the video mode.
	Width int32
	// The height, in screen coordinates, of the video mode.
	Height int32
	// The bit depth of the red channel of the video mode.
	redBits int32
	// The bit depth of the green channel of the video mode.
	greenBits int32
	// The bit depth of the blue channel of the video mode.
	blueBits int32
	// The refresh rate, in Hz, of the video mode.
	refreshRate int32
}
type Gammaramp struct {
	// An array of value describing the response of the red channel.
	Red *uint16
	// An array of value describing the response of the green channel.
	Green *uint16
	// An array of value describing the response of the blue channel.
	Blue *uint16
	// The number of elements in each array.
	Size uint32
}
type Image struct {
	// The width, in pixels, of this image.
	Width int32
	// The height, in pixels, of this image.
	Height int32
	// The pixel data of this image, arranged left-to-right, top-to-bottom.
	Pixels *uint8
}
type Gamepadstate struct {
	// The states of each [gamepad button](
	// @ref gamepad_buttons),
	// `GLFW_PRESS`
	// or `GLFW_RELEASE`.
	Buttons [15]uint8
	// The states of each [gamepad axis](
	// @ref gamepad_axes),
	// in the range -1.0
	// to 1.0 inclusive.
	Axes [6]float32
}
type Allocator struct {
	// The memory allocation function.  See
	// @ref GLFWallocatefun
	// for details about
	// allocation function.
	Allocate Allocatefun
	// The memory reallocation function.  See
	// @ref GLFWreallocatefun
	// for details about
	// reallocation function.
	Reallocate Reallocatefun
	// The memory deallocation function.  See
	// @ref GLFWdeallocatefun
	// for details about
	// deallocation function.
	Deallocate Deallocatefun
	// The user pointer for this custom allocator.  This value will be passed to the
	// allocator functions.
	User unsafe.Pointer
}
type (
	_Int128T                             = any
	_Uint128T                            = any
	__NSConstantString                   = any
	SizeT                                = uint64
	_BuiltinMsVaList                     = *byte
	_BuiltinVaList                       = *byte
	UintptrT                             = uint64
	VaList                               = *byte
	SizeT                                = uint64
	PtrdiffT                             = int64
	IntptrT                              = int64
	_VcrtBool                            = bool
	WcharT                               = uint16
	_CrtBool                             = bool
	ErrnoT                               = int32
	WintT                                = uint16
	WctypeT                              = uint16
	_Time32T                             = int64
	TimeT                                = int64
	_LocaleT                             = unsafe.Pointer
	MbstateT                             = any
	RsizeT                               = uint
	Int8T                                = int8
	Int16T                               = int16
	Int32T                               = int32
	Int64T                               = int64
	Uint8T                               = uint8
	Uint16T                              = uint16
	Uint32T                              = uint32
	Uint64T                              = uint64
	IntLeast8T                           = int8
	IntLeast16T                          = int16
	IntLeast32T                          = int32
	IntLeast64T                          = int64
	UintLeast8T                          = uint8
	UintLeast16T                         = uint16
	UintLeast32T                         = uint32
	UintLeast64T                         = uint64
	IntFast8T                            = int8
	IntFast16T                           = int32
	IntFast32T                           = int32
	IntFast64T                           = int64
	UintFast8T                           = uint8
	UintFast16T                          = uint32
	UintFast32T                          = uint32
	UintFast64T                          = uint64
	IntmaxT                              = int64
	UintmaxT                             = uint64
	Enum                                 = uint32
	Boolean                              = uint8
	Bitfield                             = uint32
	Byte                                 = int8
	Short                                = int16
	Int                                  = int32
	Sizei                                = int32
	Ubyte                                = uint8
	Ushort                               = uint16
	Uint                                 = uint32
	Float                                = float32
	Clampf                               = float32
	Double                               = float64
	Clampd                               = float64
	Void                                 = void
	Pfnglarrayelementextproc             = unsafe.Pointer
	Pfngldrawarraysextproc               = unsafe.Pointer
	Pfnglvertexpointerextproc            = unsafe.Pointer
	Pfnglnormalpointerextproc            = unsafe.Pointer
	Pfnglcolorpointerextproc             = unsafe.Pointer
	Pfnglindexpointerextproc             = unsafe.Pointer
	Pfngltexcoordpointerextproc          = unsafe.Pointer
	Pfngledgeflagpointerextproc          = unsafe.Pointer
	Pfnglgetpointervextproc              = unsafe.Pointer
	Pfnglarrayelementarrayextproc        = unsafe.Pointer
	Pfngldrawrangeelementswinproc        = unsafe.Pointer
	Pfngladdswaphintrectwinproc          = unsafe.Pointer
	Pfnglcolortableextproc               = unsafe.Pointer
	Pfnglcolorsubtableextproc            = unsafe.Pointer
	Pfnglgetcolortableextproc            = unsafe.Pointer
	Pfnglgetcolortableparameterivextproc = unsafe.Pointer
	Pfnglgetcolortableparameterfvextproc = unsafe.Pointer
)

// @brief Client API function pointer type.
// Generic function pointer used for returning client API function pointers
// without forcing a cast from a regular pointer.
//
// @sa
// @ref context_glext
//
// @sa
// @ref glfwGetProcAddress
//
// @since Added in version 3.0.
type Glproc = unsafe.Pointer

// @brief Vulkan API function pointer type.
// Generic function pointer used for returning Vulkan API function pointers
// without forcing a cast from a regular pointer.
//
// @sa
// @ref vulkan_proc
//
// @sa
// @ref glfwGetInstanceProcAddress
//
// @since Added in version 3.2.
type Vkproc = unsafe.Pointer

// @brief The function pointer type for memory allocation callbacks.
// This is the function pointer type for memory allocation callbacks.  A memory
// allocation callback function has the following signature:
//
// This function must return either a memory block at least `size` bytes long,
// or `NULL` if allocation failed.  Note that not all parts of GLFW handle allocation
// failures gracefully yet.
// This function must support being called during
// @ref glfwInit
// but before the library is
// flagged as initialized, as well as during
// @ref glfwTerminate
// after the library is no
// longer flagged as initialized.
// Any memory allocated via this function will be deallocated via the same allocator
// during library termination or earlier.
// Any memory allocated via this function must be suitably aligned for any object type.
// If you are using C99 or earlier, this alignment is platform-dependent but will be the
// same as what `malloc` provides.  If you are using C11 or later, this is the value of
// `alignof(max_align_t)`.
// The size will always be greater than zero.  Allocations of size zero are filtered out
// before reaching the custom allocator.
// If this function returns `NULL`, GLFW will emit
// @ref GLFW_OUT_OF_MEMORY.
// This function must not call any GLFW function.
//
// @param size The minimum size, in bytes, of the memory block.
//
// @param user The user-defined pointer from the allocator.
//
// @return The address of the newly allocated memory block, or `NULL` if an
// error occurred.
//
// @pointer
// _lifetime The returned memory block must be valid at least until it
// is deallocated.
//
// @reentrancy
// This function should not call any GLFW function.
//
// @thread
// _safety This function must support being called from any thread that calls GLFW
// functions.
//
// @sa
// @ref init_allocator
//
// @sa
// @ref GLFWallocator
//
// @since Added in version 3.4.
type Allocatefun = unsafe.Pointer

// @brief The function pointer type for memory reallocation callbacks.
// This is the function pointer type for memory reallocation callbacks.
// A memory reallocation callback function has the following signature:
//
// This function must return a memory block at least `size` bytes long, or
// `NULL` if allocation failed.  Note that not all parts of GLFW handle allocation
// failures gracefully yet.
// This function must support being called during
// @ref glfwInit
// but before the library is
// flagged as initialized, as well as during
// @ref glfwTerminate
// after the library is no
// longer flagged as initialized.
// Any memory allocated via this function will be deallocated via the same allocator
// during library termination or earlier.
// Any memory allocated via this function must be suitably aligned for any object type.
// If you are using C99 or earlier, this alignment is platform-dependent but will be the
// same as what `realloc` provides.  If you are using C11 or later, this is the value of
// `alignof(max_align_t)`.
// The block address will never be `NULL` and the size will always be greater than zero.
// Reallocations of a block to size zero are converted into deallocations before reaching
// the custom allocator.  Reallocations of `NULL` to a non-zero size are converted into
// regular allocations before reaching the custom allocator.
// If this function returns `NULL`, GLFW will emit
// @ref GLFW_OUT_OF_MEMORY.
// This function must not call any GLFW function.
//
// @param block The address of the memory block to reallocate.
//
// @param size The new minimum size, in bytes, of the memory block.
//
// @param user The user-defined pointer from the allocator.
//
// @return The address of the newly allocated or resized memory block, or
// `NULL` if an error occurred.
//
// @pointer
// _lifetime The returned memory block must be valid at least until it
// is deallocated.
//
// @reentrancy
// This function should not call any GLFW function.
//
// @thread
// _safety This function must support being called from any thread that calls GLFW
// functions.
//
// @sa
// @ref init_allocator
//
// @sa
// @ref GLFWallocator
//
// @since Added in version 3.4.
type Reallocatefun = unsafe.Pointer

// @brief The function pointer type for memory deallocation callbacks.
// This is the function pointer type for memory deallocation callbacks.
// A memory deallocation callback function has the following signature:
//
// This function may deallocate the specified memory block.  This memory block
// will have been allocated with the same allocator.
// This function must support being called during
// @ref glfwInit
// but before the library is
// flagged as initialized, as well as during
// @ref glfwTerminate
// after the library is no
// longer flagged as initialized.
// The block address will never be `NULL`.  Deallocations of `NULL` are filtered out
// before reaching the custom allocator.
// If this function returns `NULL`, GLFW will emit
// @ref GLFW_OUT_OF_MEMORY.
// This function must not call any GLFW function.
//
// @param block The address of the memory block to deallocate.
//
// @param user The user-defined pointer from the allocator.
//
// @pointer
// _lifetime The specified memory block will not be accessed by GLFW
// after this function is called.
//
// @reentrancy
// This function should not call any GLFW function.
//
// @thread
// _safety This function must support being called from any thread that calls GLFW
// functions.
//
// @sa
// @ref init_allocator
//
// @sa
// @ref GLFWallocator
//
// @since Added in version 3.4.
type Deallocatefun = unsafe.Pointer

// @brief The function pointer type for error callbacks.
// This is the function pointer type for error callbacks.  An error callback
// function has the following signature:
//
// @param error_code An [error code](
// @ref errors).
// Future releases may add
// more error codes.
//
// @param description A UTF-8 encoded string describing the error.
//
// @pointer
// _lifetime The error description string is valid until the callback
// function returns.
//
// @sa
// @ref error_handling
//
// @sa
// @ref glfwSetErrorCallback
//
// @since Added in version 3.0.
type Errorfun = unsafe.Pointer

// @brief The function pointer type for window position callbacks.
// This is the function pointer type for window position callbacks.  A window
// position callback function has the following signature:
//
// @param window The window that was moved.
//
// @param xpos The new x-coordinate, in screen coordinates, of the
// upper-left corner of the content area of the window.
//
// @param ypos The new y-coordinate, in screen coordinates, of the
// upper-left corner of the content area of the window.
//
// @sa
// @ref window_pos
//
// @sa
// @ref glfwSetWindowPosCallback
//
// @since Added in version 3.0.
type Windowposfun = unsafe.Pointer

// @brief The function pointer type for window size callbacks.
// This is the function pointer type for window size callbacks.  A window size
// callback function has the following signature:
//
// @param window The window that was resized.
//
// @param width The new width, in screen coordinates, of the window.
//
// @param height The new height, in screen coordinates, of the window.
//
// @sa
// @ref window_size
//
// @sa
// @ref glfwSetWindowSizeCallback
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter.
type Windowsizefun = unsafe.Pointer

// @brief The function pointer type for window close callbacks.
// This is the function pointer type for window close callbacks.  A window
// close callback function has the following signature:
//
// @param window The window that the user attempted to close.
//
// @sa
// @ref window_close
//
// @sa
// @ref glfwSetWindowCloseCallback
//
// @since Added in version 2.5.
//
// @glfw3
// Added window handle parameter.
type Windowclosefun = unsafe.Pointer

// @brief The function pointer type for window content refresh callbacks.
// This is the function pointer type for window content refresh callbacks.
// A window content refresh callback function has the following signature:
//
// @param window The window whose content needs to be refreshed.
//
// @sa
// @ref window_refresh
//
// @sa
// @ref glfwSetWindowRefreshCallback
//
// @since Added in version 2.5.
//
// @glfw3
// Added window handle parameter.
type Windowrefreshfun = unsafe.Pointer

// @brief The function pointer type for window focus callbacks.
// This is the function pointer type for window focus callbacks.  A window
// focus callback function has the following signature:
//
// @param window The window that gained or lost input focus.
//
// @param focused `GLFW_TRUE` if the window was given input focus, or
// `GLFW_FALSE` if it lost it.
//
// @sa
// @ref window_focus
//
// @sa
// @ref glfwSetWindowFocusCallback
//
// @since Added in version 3.0.
type Windowfocusfun = unsafe.Pointer

// @brief The function pointer type for window iconify callbacks.
// This is the function pointer type for window iconify callbacks.  A window
// iconify callback function has the following signature:
//
// @param window The window that was iconified or restored.
//
// @param iconified `GLFW_TRUE` if the window was iconified, or
// `GLFW_FALSE` if it was restored.
//
// @sa
// @ref window_iconify
//
// @sa
// @ref glfwSetWindowIconifyCallback
//
// @since Added in version 3.0.
type Windowiconifyfun = unsafe.Pointer

// @brief The function pointer type for window maximize callbacks.
// This is the function pointer type for window maximize callbacks.  A window
// maximize callback function has the following signature:
//
// @param window The window that was maximized or restored.
//
// @param maximized `GLFW_TRUE` if the window was maximized, or
// `GLFW_FALSE` if it was restored.
//
// @sa
// @ref window_maximize
//
// @sa glfwSetWindowMaximizeCallback
//
// @since Added in version 3.3.
type Windowmaximizefun = unsafe.Pointer

// @brief The function pointer type for framebuffer size callbacks.
// This is the function pointer type for framebuffer size callbacks.
// A framebuffer size callback function has the following signature:
//
// @param window The window whose framebuffer was resized.
//
// @param width The new width, in pixels, of the framebuffer.
//
// @param height The new height, in pixels, of the framebuffer.
//
// @sa
// @ref window_fbsize
//
// @sa
// @ref glfwSetFramebufferSizeCallback
//
// @since Added in version 3.0.
type Framebuffersizefun = unsafe.Pointer

// @brief The function pointer type for window content scale callbacks.
// This is the function pointer type for window content scale callbacks.
// A window content scale callback function has the following signature:
//
// @param window The window whose content scale changed.
//
// @param xscale The new x-axis content scale of the window.
//
// @param yscale The new y-axis content scale of the window.
//
// @sa
// @ref window_scale
//
// @sa
// @ref glfwSetWindowContentScaleCallback
//
// @since Added in version 3.3.
type Windowcontentscalefun = unsafe.Pointer

// @brief The function pointer type for mouse button callbacks.
// This is the function pointer type for mouse button callback functions.
// A mouse button callback function has the following signature:
//
// @param window The window that received the event.
//
// @param button The [mouse button](
// @ref buttons)
// that was pressed or
// released.
//
// @param action One of `GLFW_PRESS` or `GLFW_RELEASE`.  Future releases
// may add more actions.
//
// @param mods Bit field describing which [modifier keys](
// @ref mods)
// were
// held down.
//
// @sa
// @ref input_mouse_button
//
// @sa
// @ref glfwSetMouseButtonCallback
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle and modifier mask parameters.
type Mousebuttonfun = unsafe.Pointer

// @brief The function pointer type for cursor position callbacks.
// This is the function pointer type for cursor position callbacks.  A cursor
// position callback function has the following signature:
//
// @param window The window that received the event.
//
// @param xpos The new cursor x-coordinate, relative to the left edge of
// the content area.
//
// @param ypos The new cursor y-coordinate, relative to the top edge of the
// content area.
//
// @sa
// @ref cursor_pos
//
// @sa
// @ref glfwSetCursorPosCallback
//
// @since Added in version 3.0.  Replaces `GLFWmouseposfun`.
type Cursorposfun = unsafe.Pointer

// @brief The function pointer type for cursor enter/leave callbacks.
// This is the function pointer type for cursor enter/leave callbacks.
// A cursor enter/leave callback function has the following signature:
//
// @param window The window that received the event.
//
// @param entered `GLFW_TRUE` if the cursor entered the window's content
// area, or `GLFW_FALSE` if it left it.
//
// @sa
// @ref cursor_enter
//
// @sa
// @ref glfwSetCursorEnterCallback
//
// @since Added in version 3.0.
type Cursorenterfun = unsafe.Pointer

// @brief The function pointer type for scroll callbacks.
// This is the function pointer type for scroll callbacks.  A scroll callback
// function has the following signature:
//
// @param window The window that received the event.
//
// @param xoffset The scroll offset along the x-axis.
//
// @param yoffset The scroll offset along the y-axis.
//
// @sa
// @ref scrolling
//
// @sa
// @ref glfwSetScrollCallback
//
// @since Added in version 3.0.  Replaces `GLFWmousewheelfun`.
type Scrollfun = unsafe.Pointer

// @brief The function pointer type for keyboard key callbacks.
// This is the function pointer type for keyboard key callbacks.  A keyboard
// key callback function has the following signature:
//
// @param window The window that received the event.
//
// @param key The [keyboard key](
// @ref keys)
// that was pressed or released.
//
// @param scancode The platform-specific scancode of the key.
//
// @param action `GLFW_PRESS`, `GLFW_RELEASE` or `GLFW_REPEAT`.  Future
// releases may add more actions.
//
// @param mods Bit field describing which [modifier keys](
// @ref mods)
// were
// held down.
//
// @sa
// @ref input_key
//
// @sa
// @ref glfwSetKeyCallback
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle, scancode and modifier mask parameters.
type Keyfun = unsafe.Pointer

// @brief The function pointer type for Unicode character callbacks.
// This is the function pointer type for Unicode character callbacks.
// A Unicode character callback function has the following signature:
//
// @param window The window that received the event.
//
// @param codepoint The Unicode code point of the character.
//
// @sa
// @ref input_char
//
// @sa
// @ref glfwSetCharCallback
//
// @since Added in version 2.4.
//
// @glfw3
// Added window handle parameter.
type Charfun = unsafe.Pointer

// @brief The function pointer type for Unicode character with modifiers
// callbacks.
// This is the function pointer type for Unicode character with modifiers
// callbacks.  It is called for each input character, regardless of what
// modifier keys are held down.  A Unicode character with modifiers callback
// function has the following signature:
//
// @param window The window that received the event.
//
// @param codepoint The Unicode code point of the character.
//
// @param mods Bit field describing which [modifier keys](
// @ref mods)
// were
// held down.
//
// @sa
// @ref input_char
//
// @sa
// @ref glfwSetCharModsCallback
//
// @deprecated Scheduled for removal in version 4.0.
//
// @since Added in version 3.1.
type Charmodsfun = unsafe.Pointer

// @brief The function pointer type for path drop callbacks.
// This is the function pointer type for path drop callbacks.  A path drop
// callback function has the following signature:
//
// @param window The window that received the event.
//
// @param path_count The number of dropped paths.
//
// @param paths The UTF-8 encoded file and/or directory path names.
//
// @pointer
// _lifetime The path array and its strings are valid until the
// callback function returns.
//
// @sa
// @ref path_drop
//
// @sa
// @ref glfwSetDropCallback
//
// @since Added in version 3.1.
type Dropfun = unsafe.Pointer

// @brief The function pointer type for monitor configuration callbacks.
// This is the function pointer type for monitor configuration callbacks.
// A monitor callback function has the following signature:
//
// @param monitor The monitor that was connected or disconnected.
//
// @param event One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.  Future
// releases may add more events.
//
// @sa
// @ref monitor_event
//
// @sa
// @ref glfwSetMonitorCallback
//
// @since Added in version 3.0.
type Monitorfun = unsafe.Pointer

// @brief The function pointer type for joystick configuration callbacks.
// This is the function pointer type for joystick configuration callbacks.
// A joystick configuration callback function has the following signature:
//
// @param jid The joystick that was connected or disconnected.
//
// @param event One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.  Future
// releases may add more events.
//
// @sa
// @ref joystick_event
//
// @sa
// @ref glfwSetJoystickCallback
//
// @since Added in version 3.2.
type Joystickfun = unsafe.Pointer

var __imp___va_start bindlib.PreloadProc

// Gengo init function.
func init() {
	__imp___va_start = GengoLibrary.ImportNow("__va_start")
	__imp___va_start = GengoLibrary.ImportNow("__va_start")
	__imp___security_init_cookie = GengoLibrary.ImportNow("__security_init_cookie")
	__imp___security_check_cookie = GengoLibrary.ImportNow("__security_check_cookie")
	__imp___report_gsfailure = GengoLibrary.ImportNow("__report_gsfailure")
	__imp__invalid_parameter_noinfo = GengoLibrary.ImportNow("_invalid_parameter_noinfo")
	__imp__invalid_parameter_noinfo_noreturn = GengoLibrary.ImportNow("_invalid_parameter_noinfo_noreturn")
	__imp__invoke_watson = GengoLibrary.ImportNow("_invoke_watson")
	__imp__errno = GengoLibrary.ImportNow("_errno")
	__imp__set_errno = GengoLibrary.ImportNow("_set_errno")
	__imp__get_errno = GengoLibrary.ImportNow("_get_errno")
	__imp___threadid = GengoLibrary.ImportNow("__threadid")
	__imp___threadhandle = GengoLibrary.ImportNow("__threadhandle")
	__imp_glAccum = GengoLibrary.ImportNow("glAccum")
	__imp_glAlphaFunc = GengoLibrary.ImportNow("glAlphaFunc")
	__imp_glAreTexturesResident = GengoLibrary.ImportNow("glAreTexturesResident")
	__imp_glArrayElement = GengoLibrary.ImportNow("glArrayElement")
	__imp_glBegin = GengoLibrary.ImportNow("glBegin")
	__imp_glBindTexture = GengoLibrary.ImportNow("glBindTexture")
	__imp_glBitmap = GengoLibrary.ImportNow("glBitmap")
	__imp_glBlendFunc = GengoLibrary.ImportNow("glBlendFunc")
	__imp_glCallList = GengoLibrary.ImportNow("glCallList")
	__imp_glCallLists = GengoLibrary.ImportNow("glCallLists")
	__imp_glClear = GengoLibrary.ImportNow("glClear")
	__imp_glClearAccum = GengoLibrary.ImportNow("glClearAccum")
	__imp_glClearColor = GengoLibrary.ImportNow("glClearColor")
	__imp_glClearDepth = GengoLibrary.ImportNow("glClearDepth")
	__imp_glClearIndex = GengoLibrary.ImportNow("glClearIndex")
	__imp_glClearStencil = GengoLibrary.ImportNow("glClearStencil")
	__imp_glClipPlane = GengoLibrary.ImportNow("glClipPlane")
	__imp_glColor3b = GengoLibrary.ImportNow("glColor3b")
	__imp_glColor3bv = GengoLibrary.ImportNow("glColor3bv")
	__imp_glColor3d = GengoLibrary.ImportNow("glColor3d")
	__imp_glColor3dv = GengoLibrary.ImportNow("glColor3dv")
	__imp_glColor3f = GengoLibrary.ImportNow("glColor3f")
	__imp_glColor3fv = GengoLibrary.ImportNow("glColor3fv")
	__imp_glColor3i = GengoLibrary.ImportNow("glColor3i")
	__imp_glColor3iv = GengoLibrary.ImportNow("glColor3iv")
	__imp_glColor3s = GengoLibrary.ImportNow("glColor3s")
	__imp_glColor3sv = GengoLibrary.ImportNow("glColor3sv")
	__imp_glColor3ub = GengoLibrary.ImportNow("glColor3ub")
	__imp_glColor3ubv = GengoLibrary.ImportNow("glColor3ubv")
	__imp_glColor3ui = GengoLibrary.ImportNow("glColor3ui")
	__imp_glColor3uiv = GengoLibrary.ImportNow("glColor3uiv")
	__imp_glColor3us = GengoLibrary.ImportNow("glColor3us")
	__imp_glColor3usv = GengoLibrary.ImportNow("glColor3usv")
	__imp_glColor4b = GengoLibrary.ImportNow("glColor4b")
	__imp_glColor4bv = GengoLibrary.ImportNow("glColor4bv")
	__imp_glColor4d = GengoLibrary.ImportNow("glColor4d")
	__imp_glColor4dv = GengoLibrary.ImportNow("glColor4dv")
	__imp_glColor4f = GengoLibrary.ImportNow("glColor4f")
	__imp_glColor4fv = GengoLibrary.ImportNow("glColor4fv")
	__imp_glColor4i = GengoLibrary.ImportNow("glColor4i")
	__imp_glColor4iv = GengoLibrary.ImportNow("glColor4iv")
	__imp_glColor4s = GengoLibrary.ImportNow("glColor4s")
	__imp_glColor4sv = GengoLibrary.ImportNow("glColor4sv")
	__imp_glColor4ub = GengoLibrary.ImportNow("glColor4ub")
	__imp_glColor4ubv = GengoLibrary.ImportNow("glColor4ubv")
	__imp_glColor4ui = GengoLibrary.ImportNow("glColor4ui")
	__imp_glColor4uiv = GengoLibrary.ImportNow("glColor4uiv")
	__imp_glColor4us = GengoLibrary.ImportNow("glColor4us")
	__imp_glColor4usv = GengoLibrary.ImportNow("glColor4usv")
	__imp_glColorMask = GengoLibrary.ImportNow("glColorMask")
	__imp_glColorMaterial = GengoLibrary.ImportNow("glColorMaterial")
	__imp_glColorPointer = GengoLibrary.ImportNow("glColorPointer")
	__imp_glCopyPixels = GengoLibrary.ImportNow("glCopyPixels")
	__imp_glCopyTexImage1D = GengoLibrary.ImportNow("glCopyTexImage1D")
	__imp_glCopyTexImage2D = GengoLibrary.ImportNow("glCopyTexImage2D")
	__imp_glCopyTexSubImage1D = GengoLibrary.ImportNow("glCopyTexSubImage1D")
	__imp_glCopyTexSubImage2D = GengoLibrary.ImportNow("glCopyTexSubImage2D")
	__imp_glCullFace = GengoLibrary.ImportNow("glCullFace")
	__imp_glDeleteLists = GengoLibrary.ImportNow("glDeleteLists")
	__imp_glDeleteTextures = GengoLibrary.ImportNow("glDeleteTextures")
	__imp_glDepthFunc = GengoLibrary.ImportNow("glDepthFunc")
	__imp_glDepthMask = GengoLibrary.ImportNow("glDepthMask")
	__imp_glDepthRange = GengoLibrary.ImportNow("glDepthRange")
	__imp_glDisable = GengoLibrary.ImportNow("glDisable")
	__imp_glDisableClientState = GengoLibrary.ImportNow("glDisableClientState")
	__imp_glDrawArrays = GengoLibrary.ImportNow("glDrawArrays")
	__imp_glDrawBuffer = GengoLibrary.ImportNow("glDrawBuffer")
	__imp_glDrawElements = GengoLibrary.ImportNow("glDrawElements")
	__imp_glDrawPixels = GengoLibrary.ImportNow("glDrawPixels")
	__imp_glEdgeFlag = GengoLibrary.ImportNow("glEdgeFlag")
	__imp_glEdgeFlagPointer = GengoLibrary.ImportNow("glEdgeFlagPointer")
	__imp_glEdgeFlagv = GengoLibrary.ImportNow("glEdgeFlagv")
	__imp_glEnable = GengoLibrary.ImportNow("glEnable")
	__imp_glEnableClientState = GengoLibrary.ImportNow("glEnableClientState")
	__imp_glEnd = GengoLibrary.ImportNow("glEnd")
	__imp_glEndList = GengoLibrary.ImportNow("glEndList")
	__imp_glEvalCoord1d = GengoLibrary.ImportNow("glEvalCoord1d")
	__imp_glEvalCoord1dv = GengoLibrary.ImportNow("glEvalCoord1dv")
	__imp_glEvalCoord1f = GengoLibrary.ImportNow("glEvalCoord1f")
	__imp_glEvalCoord1fv = GengoLibrary.ImportNow("glEvalCoord1fv")
	__imp_glEvalCoord2d = GengoLibrary.ImportNow("glEvalCoord2d")
	__imp_glEvalCoord2dv = GengoLibrary.ImportNow("glEvalCoord2dv")
	__imp_glEvalCoord2f = GengoLibrary.ImportNow("glEvalCoord2f")
	__imp_glEvalCoord2fv = GengoLibrary.ImportNow("glEvalCoord2fv")
	__imp_glEvalMesh1 = GengoLibrary.ImportNow("glEvalMesh1")
	__imp_glEvalMesh2 = GengoLibrary.ImportNow("glEvalMesh2")
	__imp_glEvalPoint1 = GengoLibrary.ImportNow("glEvalPoint1")
	__imp_glEvalPoint2 = GengoLibrary.ImportNow("glEvalPoint2")
	__imp_glFeedbackBuffer = GengoLibrary.ImportNow("glFeedbackBuffer")
	__imp_glFinish = GengoLibrary.ImportNow("glFinish")
	__imp_glFlush = GengoLibrary.ImportNow("glFlush")
	__imp_glFogf = GengoLibrary.ImportNow("glFogf")
	__imp_glFogfv = GengoLibrary.ImportNow("glFogfv")
	__imp_glFogi = GengoLibrary.ImportNow("glFogi")
	__imp_glFogiv = GengoLibrary.ImportNow("glFogiv")
	__imp_glFrontFace = GengoLibrary.ImportNow("glFrontFace")
	__imp_glFrustum = GengoLibrary.ImportNow("glFrustum")
	__imp_glGenLists = GengoLibrary.ImportNow("glGenLists")
	__imp_glGenTextures = GengoLibrary.ImportNow("glGenTextures")
	__imp_glGetBooleanv = GengoLibrary.ImportNow("glGetBooleanv")
	__imp_glGetClipPlane = GengoLibrary.ImportNow("glGetClipPlane")
	__imp_glGetDoublev = GengoLibrary.ImportNow("glGetDoublev")
	__imp_glGetError = GengoLibrary.ImportNow("glGetError")
	__imp_glGetFloatv = GengoLibrary.ImportNow("glGetFloatv")
	__imp_glGetIntegerv = GengoLibrary.ImportNow("glGetIntegerv")
	__imp_glGetLightfv = GengoLibrary.ImportNow("glGetLightfv")
	__imp_glGetLightiv = GengoLibrary.ImportNow("glGetLightiv")
	__imp_glGetMapdv = GengoLibrary.ImportNow("glGetMapdv")
	__imp_glGetMapfv = GengoLibrary.ImportNow("glGetMapfv")
	__imp_glGetMapiv = GengoLibrary.ImportNow("glGetMapiv")
	__imp_glGetMaterialfv = GengoLibrary.ImportNow("glGetMaterialfv")
	__imp_glGetMaterialiv = GengoLibrary.ImportNow("glGetMaterialiv")
	__imp_glGetPixelMapfv = GengoLibrary.ImportNow("glGetPixelMapfv")
	__imp_glGetPixelMapuiv = GengoLibrary.ImportNow("glGetPixelMapuiv")
	__imp_glGetPixelMapusv = GengoLibrary.ImportNow("glGetPixelMapusv")
	__imp_glGetPointerv = GengoLibrary.ImportNow("glGetPointerv")
	__imp_glGetPolygonStipple = GengoLibrary.ImportNow("glGetPolygonStipple")
	__imp_glGetString = GengoLibrary.ImportNow("glGetString")
	__imp_glGetTexEnvfv = GengoLibrary.ImportNow("glGetTexEnvfv")
	__imp_glGetTexEnviv = GengoLibrary.ImportNow("glGetTexEnviv")
	__imp_glGetTexGendv = GengoLibrary.ImportNow("glGetTexGendv")
	__imp_glGetTexGenfv = GengoLibrary.ImportNow("glGetTexGenfv")
	__imp_glGetTexGeniv = GengoLibrary.ImportNow("glGetTexGeniv")
	__imp_glGetTexImage = GengoLibrary.ImportNow("glGetTexImage")
	__imp_glGetTexLevelParameterfv = GengoLibrary.ImportNow("glGetTexLevelParameterfv")
	__imp_glGetTexLevelParameteriv = GengoLibrary.ImportNow("glGetTexLevelParameteriv")
	__imp_glGetTexParameterfv = GengoLibrary.ImportNow("glGetTexParameterfv")
	__imp_glGetTexParameteriv = GengoLibrary.ImportNow("glGetTexParameteriv")
	__imp_glHint = GengoLibrary.ImportNow("glHint")
	__imp_glIndexMask = GengoLibrary.ImportNow("glIndexMask")
	__imp_glIndexPointer = GengoLibrary.ImportNow("glIndexPointer")
	__imp_glIndexd = GengoLibrary.ImportNow("glIndexd")
	__imp_glIndexdv = GengoLibrary.ImportNow("glIndexdv")
	__imp_glIndexf = GengoLibrary.ImportNow("glIndexf")
	__imp_glIndexfv = GengoLibrary.ImportNow("glIndexfv")
	__imp_glIndexi = GengoLibrary.ImportNow("glIndexi")
	__imp_glIndexiv = GengoLibrary.ImportNow("glIndexiv")
	__imp_glIndexs = GengoLibrary.ImportNow("glIndexs")
	__imp_glIndexsv = GengoLibrary.ImportNow("glIndexsv")
	__imp_glIndexub = GengoLibrary.ImportNow("glIndexub")
	__imp_glIndexubv = GengoLibrary.ImportNow("glIndexubv")
	__imp_glInitNames = GengoLibrary.ImportNow("glInitNames")
	__imp_glInterleavedArrays = GengoLibrary.ImportNow("glInterleavedArrays")
	__imp_glIsEnabled = GengoLibrary.ImportNow("glIsEnabled")
	__imp_glIsList = GengoLibrary.ImportNow("glIsList")
	__imp_glIsTexture = GengoLibrary.ImportNow("glIsTexture")
	__imp_glLightModelf = GengoLibrary.ImportNow("glLightModelf")
	__imp_glLightModelfv = GengoLibrary.ImportNow("glLightModelfv")
	__imp_glLightModeli = GengoLibrary.ImportNow("glLightModeli")
	__imp_glLightModeliv = GengoLibrary.ImportNow("glLightModeliv")
	__imp_glLightf = GengoLibrary.ImportNow("glLightf")
	__imp_glLightfv = GengoLibrary.ImportNow("glLightfv")
	__imp_glLighti = GengoLibrary.ImportNow("glLighti")
	__imp_glLightiv = GengoLibrary.ImportNow("glLightiv")
	__imp_glLineStipple = GengoLibrary.ImportNow("glLineStipple")
	__imp_glLineWidth = GengoLibrary.ImportNow("glLineWidth")
	__imp_glListBase = GengoLibrary.ImportNow("glListBase")
	__imp_glLoadIdentity = GengoLibrary.ImportNow("glLoadIdentity")
	__imp_glLoadMatrixd = GengoLibrary.ImportNow("glLoadMatrixd")
	__imp_glLoadMatrixf = GengoLibrary.ImportNow("glLoadMatrixf")
	__imp_glLoadName = GengoLibrary.ImportNow("glLoadName")
	__imp_glLogicOp = GengoLibrary.ImportNow("glLogicOp")
	__imp_glMap1d = GengoLibrary.ImportNow("glMap1d")
	__imp_glMap1f = GengoLibrary.ImportNow("glMap1f")
	__imp_glMap2d = GengoLibrary.ImportNow("glMap2d")
	__imp_glMap2f = GengoLibrary.ImportNow("glMap2f")
	__imp_glMapGrid1d = GengoLibrary.ImportNow("glMapGrid1d")
	__imp_glMapGrid1f = GengoLibrary.ImportNow("glMapGrid1f")
	__imp_glMapGrid2d = GengoLibrary.ImportNow("glMapGrid2d")
	__imp_glMapGrid2f = GengoLibrary.ImportNow("glMapGrid2f")
	__imp_glMaterialf = GengoLibrary.ImportNow("glMaterialf")
	__imp_glMaterialfv = GengoLibrary.ImportNow("glMaterialfv")
	__imp_glMateriali = GengoLibrary.ImportNow("glMateriali")
	__imp_glMaterialiv = GengoLibrary.ImportNow("glMaterialiv")
	__imp_glMatrixMode = GengoLibrary.ImportNow("glMatrixMode")
	__imp_glMultMatrixd = GengoLibrary.ImportNow("glMultMatrixd")
	__imp_glMultMatrixf = GengoLibrary.ImportNow("glMultMatrixf")
	__imp_glNewList = GengoLibrary.ImportNow("glNewList")
	__imp_glNormal3b = GengoLibrary.ImportNow("glNormal3b")
	__imp_glNormal3bv = GengoLibrary.ImportNow("glNormal3bv")
	__imp_glNormal3d = GengoLibrary.ImportNow("glNormal3d")
	__imp_glNormal3dv = GengoLibrary.ImportNow("glNormal3dv")
	__imp_glNormal3f = GengoLibrary.ImportNow("glNormal3f")
	__imp_glNormal3fv = GengoLibrary.ImportNow("glNormal3fv")
	__imp_glNormal3i = GengoLibrary.ImportNow("glNormal3i")
	__imp_glNormal3iv = GengoLibrary.ImportNow("glNormal3iv")
	__imp_glNormal3s = GengoLibrary.ImportNow("glNormal3s")
	__imp_glNormal3sv = GengoLibrary.ImportNow("glNormal3sv")
	__imp_glNormalPointer = GengoLibrary.ImportNow("glNormalPointer")
	__imp_glOrtho = GengoLibrary.ImportNow("glOrtho")
	__imp_glPassThrough = GengoLibrary.ImportNow("glPassThrough")
	__imp_glPixelMapfv = GengoLibrary.ImportNow("glPixelMapfv")
	__imp_glPixelMapuiv = GengoLibrary.ImportNow("glPixelMapuiv")
	__imp_glPixelMapusv = GengoLibrary.ImportNow("glPixelMapusv")
	__imp_glPixelStoref = GengoLibrary.ImportNow("glPixelStoref")
	__imp_glPixelStorei = GengoLibrary.ImportNow("glPixelStorei")
	__imp_glPixelTransferf = GengoLibrary.ImportNow("glPixelTransferf")
	__imp_glPixelTransferi = GengoLibrary.ImportNow("glPixelTransferi")
	__imp_glPixelZoom = GengoLibrary.ImportNow("glPixelZoom")
	__imp_glPointSize = GengoLibrary.ImportNow("glPointSize")
	__imp_glPolygonMode = GengoLibrary.ImportNow("glPolygonMode")
	__imp_glPolygonOffset = GengoLibrary.ImportNow("glPolygonOffset")
	__imp_glPolygonStipple = GengoLibrary.ImportNow("glPolygonStipple")
	__imp_glPopAttrib = GengoLibrary.ImportNow("glPopAttrib")
	__imp_glPopClientAttrib = GengoLibrary.ImportNow("glPopClientAttrib")
	__imp_glPopMatrix = GengoLibrary.ImportNow("glPopMatrix")
	__imp_glPopName = GengoLibrary.ImportNow("glPopName")
	__imp_glPrioritizeTextures = GengoLibrary.ImportNow("glPrioritizeTextures")
	__imp_glPushAttrib = GengoLibrary.ImportNow("glPushAttrib")
	__imp_glPushClientAttrib = GengoLibrary.ImportNow("glPushClientAttrib")
	__imp_glPushMatrix = GengoLibrary.ImportNow("glPushMatrix")
	__imp_glPushName = GengoLibrary.ImportNow("glPushName")
	__imp_glRasterPos2d = GengoLibrary.ImportNow("glRasterPos2d")
	__imp_glRasterPos2dv = GengoLibrary.ImportNow("glRasterPos2dv")
	__imp_glRasterPos2f = GengoLibrary.ImportNow("glRasterPos2f")
	__imp_glRasterPos2fv = GengoLibrary.ImportNow("glRasterPos2fv")
	__imp_glRasterPos2i = GengoLibrary.ImportNow("glRasterPos2i")
	__imp_glRasterPos2iv = GengoLibrary.ImportNow("glRasterPos2iv")
	__imp_glRasterPos2s = GengoLibrary.ImportNow("glRasterPos2s")
	__imp_glRasterPos2sv = GengoLibrary.ImportNow("glRasterPos2sv")
	__imp_glRasterPos3d = GengoLibrary.ImportNow("glRasterPos3d")
	__imp_glRasterPos3dv = GengoLibrary.ImportNow("glRasterPos3dv")
	__imp_glRasterPos3f = GengoLibrary.ImportNow("glRasterPos3f")
	__imp_glRasterPos3fv = GengoLibrary.ImportNow("glRasterPos3fv")
	__imp_glRasterPos3i = GengoLibrary.ImportNow("glRasterPos3i")
	__imp_glRasterPos3iv = GengoLibrary.ImportNow("glRasterPos3iv")
	__imp_glRasterPos3s = GengoLibrary.ImportNow("glRasterPos3s")
	__imp_glRasterPos3sv = GengoLibrary.ImportNow("glRasterPos3sv")
	__imp_glRasterPos4d = GengoLibrary.ImportNow("glRasterPos4d")
	__imp_glRasterPos4dv = GengoLibrary.ImportNow("glRasterPos4dv")
	__imp_glRasterPos4f = GengoLibrary.ImportNow("glRasterPos4f")
	__imp_glRasterPos4fv = GengoLibrary.ImportNow("glRasterPos4fv")
	__imp_glRasterPos4i = GengoLibrary.ImportNow("glRasterPos4i")
	__imp_glRasterPos4iv = GengoLibrary.ImportNow("glRasterPos4iv")
	__imp_glRasterPos4s = GengoLibrary.ImportNow("glRasterPos4s")
	__imp_glRasterPos4sv = GengoLibrary.ImportNow("glRasterPos4sv")
	__imp_glReadBuffer = GengoLibrary.ImportNow("glReadBuffer")
	__imp_glReadPixels = GengoLibrary.ImportNow("glReadPixels")
	__imp_glRectd = GengoLibrary.ImportNow("glRectd")
	__imp_glRectdv = GengoLibrary.ImportNow("glRectdv")
	__imp_glRectf = GengoLibrary.ImportNow("glRectf")
	__imp_glRectfv = GengoLibrary.ImportNow("glRectfv")
	__imp_glRecti = GengoLibrary.ImportNow("glRecti")
	__imp_glRectiv = GengoLibrary.ImportNow("glRectiv")
	__imp_glRects = GengoLibrary.ImportNow("glRects")
	__imp_glRectsv = GengoLibrary.ImportNow("glRectsv")
	__imp_glRenderMode = GengoLibrary.ImportNow("glRenderMode")
	__imp_glRotated = GengoLibrary.ImportNow("glRotated")
	__imp_glRotatef = GengoLibrary.ImportNow("glRotatef")
	__imp_glScaled = GengoLibrary.ImportNow("glScaled")
	__imp_glScalef = GengoLibrary.ImportNow("glScalef")
	__imp_glScissor = GengoLibrary.ImportNow("glScissor")
	__imp_glSelectBuffer = GengoLibrary.ImportNow("glSelectBuffer")
	__imp_glShadeModel = GengoLibrary.ImportNow("glShadeModel")
	__imp_glStencilFunc = GengoLibrary.ImportNow("glStencilFunc")
	__imp_glStencilMask = GengoLibrary.ImportNow("glStencilMask")
	__imp_glStencilOp = GengoLibrary.ImportNow("glStencilOp")
	__imp_glTexCoord1d = GengoLibrary.ImportNow("glTexCoord1d")
	__imp_glTexCoord1dv = GengoLibrary.ImportNow("glTexCoord1dv")
	__imp_glTexCoord1f = GengoLibrary.ImportNow("glTexCoord1f")
	__imp_glTexCoord1fv = GengoLibrary.ImportNow("glTexCoord1fv")
	__imp_glTexCoord1i = GengoLibrary.ImportNow("glTexCoord1i")
	__imp_glTexCoord1iv = GengoLibrary.ImportNow("glTexCoord1iv")
	__imp_glTexCoord1s = GengoLibrary.ImportNow("glTexCoord1s")
	__imp_glTexCoord1sv = GengoLibrary.ImportNow("glTexCoord1sv")
	__imp_glTexCoord2d = GengoLibrary.ImportNow("glTexCoord2d")
	__imp_glTexCoord2dv = GengoLibrary.ImportNow("glTexCoord2dv")
	__imp_glTexCoord2f = GengoLibrary.ImportNow("glTexCoord2f")
	__imp_glTexCoord2fv = GengoLibrary.ImportNow("glTexCoord2fv")
	__imp_glTexCoord2i = GengoLibrary.ImportNow("glTexCoord2i")
	__imp_glTexCoord2iv = GengoLibrary.ImportNow("glTexCoord2iv")
	__imp_glTexCoord2s = GengoLibrary.ImportNow("glTexCoord2s")
	__imp_glTexCoord2sv = GengoLibrary.ImportNow("glTexCoord2sv")
	__imp_glTexCoord3d = GengoLibrary.ImportNow("glTexCoord3d")
	__imp_glTexCoord3dv = GengoLibrary.ImportNow("glTexCoord3dv")
	__imp_glTexCoord3f = GengoLibrary.ImportNow("glTexCoord3f")
	__imp_glTexCoord3fv = GengoLibrary.ImportNow("glTexCoord3fv")
	__imp_glTexCoord3i = GengoLibrary.ImportNow("glTexCoord3i")
	__imp_glTexCoord3iv = GengoLibrary.ImportNow("glTexCoord3iv")
	__imp_glTexCoord3s = GengoLibrary.ImportNow("glTexCoord3s")
	__imp_glTexCoord3sv = GengoLibrary.ImportNow("glTexCoord3sv")
	__imp_glTexCoord4d = GengoLibrary.ImportNow("glTexCoord4d")
	__imp_glTexCoord4dv = GengoLibrary.ImportNow("glTexCoord4dv")
	__imp_glTexCoord4f = GengoLibrary.ImportNow("glTexCoord4f")
	__imp_glTexCoord4fv = GengoLibrary.ImportNow("glTexCoord4fv")
	__imp_glTexCoord4i = GengoLibrary.ImportNow("glTexCoord4i")
	__imp_glTexCoord4iv = GengoLibrary.ImportNow("glTexCoord4iv")
	__imp_glTexCoord4s = GengoLibrary.ImportNow("glTexCoord4s")
	__imp_glTexCoord4sv = GengoLibrary.ImportNow("glTexCoord4sv")
	__imp_glTexCoordPointer = GengoLibrary.ImportNow("glTexCoordPointer")
	__imp_glTexEnvf = GengoLibrary.ImportNow("glTexEnvf")
	__imp_glTexEnvfv = GengoLibrary.ImportNow("glTexEnvfv")
	__imp_glTexEnvi = GengoLibrary.ImportNow("glTexEnvi")
	__imp_glTexEnviv = GengoLibrary.ImportNow("glTexEnviv")
	__imp_glTexGend = GengoLibrary.ImportNow("glTexGend")
	__imp_glTexGendv = GengoLibrary.ImportNow("glTexGendv")
	__imp_glTexGenf = GengoLibrary.ImportNow("glTexGenf")
	__imp_glTexGenfv = GengoLibrary.ImportNow("glTexGenfv")
	__imp_glTexGeni = GengoLibrary.ImportNow("glTexGeni")
	__imp_glTexGeniv = GengoLibrary.ImportNow("glTexGeniv")
	__imp_glTexImage1D = GengoLibrary.ImportNow("glTexImage1D")
	__imp_glTexImage2D = GengoLibrary.ImportNow("glTexImage2D")
	__imp_glTexParameterf = GengoLibrary.ImportNow("glTexParameterf")
	__imp_glTexParameterfv = GengoLibrary.ImportNow("glTexParameterfv")
	__imp_glTexParameteri = GengoLibrary.ImportNow("glTexParameteri")
	__imp_glTexParameteriv = GengoLibrary.ImportNow("glTexParameteriv")
	__imp_glTexSubImage1D = GengoLibrary.ImportNow("glTexSubImage1D")
	__imp_glTexSubImage2D = GengoLibrary.ImportNow("glTexSubImage2D")
	__imp_glTranslated = GengoLibrary.ImportNow("glTranslated")
	__imp_glTranslatef = GengoLibrary.ImportNow("glTranslatef")
	__imp_glVertex2d = GengoLibrary.ImportNow("glVertex2d")
	__imp_glVertex2dv = GengoLibrary.ImportNow("glVertex2dv")
	__imp_glVertex2f = GengoLibrary.ImportNow("glVertex2f")
	__imp_glVertex2fv = GengoLibrary.ImportNow("glVertex2fv")
	__imp_glVertex2i = GengoLibrary.ImportNow("glVertex2i")
	__imp_glVertex2iv = GengoLibrary.ImportNow("glVertex2iv")
	__imp_glVertex2s = GengoLibrary.ImportNow("glVertex2s")
	__imp_glVertex2sv = GengoLibrary.ImportNow("glVertex2sv")
	__imp_glVertex3d = GengoLibrary.ImportNow("glVertex3d")
	__imp_glVertex3dv = GengoLibrary.ImportNow("glVertex3dv")
	__imp_glVertex3f = GengoLibrary.ImportNow("glVertex3f")
	__imp_glVertex3fv = GengoLibrary.ImportNow("glVertex3fv")
	__imp_glVertex3i = GengoLibrary.ImportNow("glVertex3i")
	__imp_glVertex3iv = GengoLibrary.ImportNow("glVertex3iv")
	__imp_glVertex3s = GengoLibrary.ImportNow("glVertex3s")
	__imp_glVertex3sv = GengoLibrary.ImportNow("glVertex3sv")
	__imp_glVertex4d = GengoLibrary.ImportNow("glVertex4d")
	__imp_glVertex4dv = GengoLibrary.ImportNow("glVertex4dv")
	__imp_glVertex4f = GengoLibrary.ImportNow("glVertex4f")
	__imp_glVertex4fv = GengoLibrary.ImportNow("glVertex4fv")
	__imp_glVertex4i = GengoLibrary.ImportNow("glVertex4i")
	__imp_glVertex4iv = GengoLibrary.ImportNow("glVertex4iv")
	__imp_glVertex4s = GengoLibrary.ImportNow("glVertex4s")
	__imp_glVertex4sv = GengoLibrary.ImportNow("glVertex4sv")
	__imp_glVertexPointer = GengoLibrary.ImportNow("glVertexPointer")
	__imp_glViewport = GengoLibrary.ImportNow("glViewport")
	__imp_glfwInit = GengoLibrary.ImportNow("glfwInit")
	__imp_glfwTerminate = GengoLibrary.ImportNow("glfwTerminate")
	__imp_glfwInitHint = GengoLibrary.ImportNow("glfwInitHint")
	__imp_glfwInitAllocator = GengoLibrary.ImportNow("glfwInitAllocator")
	__imp_glfwGetVersion = GengoLibrary.ImportNow("glfwGetVersion")
	__imp_glfwGetVersionString = GengoLibrary.ImportNow("glfwGetVersionString")
	__imp_glfwGetError = GengoLibrary.ImportNow("glfwGetError")
	__imp_glfwSetErrorCallback = GengoLibrary.ImportNow("glfwSetErrorCallback")
	__imp_glfwGetPlatform = GengoLibrary.ImportNow("glfwGetPlatform")
	__imp_glfwPlatformSupported = GengoLibrary.ImportNow("glfwPlatformSupported")
	__imp_glfwGetMonitors = GengoLibrary.ImportNow("glfwGetMonitors")
	__imp_glfwGetPrimaryMonitor = GengoLibrary.ImportNow("glfwGetPrimaryMonitor")
	__imp_glfwGetMonitorPos = GengoLibrary.ImportNow("glfwGetMonitorPos")
	__imp_glfwGetMonitorWorkarea = GengoLibrary.ImportNow("glfwGetMonitorWorkarea")
	__imp_glfwGetMonitorPhysicalSize = GengoLibrary.ImportNow("glfwGetMonitorPhysicalSize")
	__imp_glfwGetMonitorContentScale = GengoLibrary.ImportNow("glfwGetMonitorContentScale")
	__imp_glfwGetMonitorName = GengoLibrary.ImportNow("glfwGetMonitorName")
	__imp_glfwSetMonitorUserPointer = GengoLibrary.ImportNow("glfwSetMonitorUserPointer")
	__imp_glfwGetMonitorUserPointer = GengoLibrary.ImportNow("glfwGetMonitorUserPointer")
	__imp_glfwSetMonitorCallback = GengoLibrary.ImportNow("glfwSetMonitorCallback")
	__imp_glfwGetVideoModes = GengoLibrary.ImportNow("glfwGetVideoModes")
	__imp_glfwGetVideoMode = GengoLibrary.ImportNow("glfwGetVideoMode")
	__imp_glfwSetGamma = GengoLibrary.ImportNow("glfwSetGamma")
	__imp_glfwGetGammaRamp = GengoLibrary.ImportNow("glfwGetGammaRamp")
	__imp_glfwSetGammaRamp = GengoLibrary.ImportNow("glfwSetGammaRamp")
	__imp_glfwDefaultWindowHints = GengoLibrary.ImportNow("glfwDefaultWindowHints")
	__imp_glfwWindowHint = GengoLibrary.ImportNow("glfwWindowHint")
	__imp_glfwWindowHintString = GengoLibrary.ImportNow("glfwWindowHintString")
	__imp_glfwCreateWindow = GengoLibrary.ImportNow("glfwCreateWindow")
	__imp_glfwDestroyWindow = GengoLibrary.ImportNow("glfwDestroyWindow")
	__imp_glfwWindowShouldClose = GengoLibrary.ImportNow("glfwWindowShouldClose")
	__imp_glfwSetWindowShouldClose = GengoLibrary.ImportNow("glfwSetWindowShouldClose")
	__imp_glfwGetWindowTitle = GengoLibrary.ImportNow("glfwGetWindowTitle")
	__imp_glfwSetWindowTitle = GengoLibrary.ImportNow("glfwSetWindowTitle")
	__imp_glfwSetWindowIcon = GengoLibrary.ImportNow("glfwSetWindowIcon")
	__imp_glfwGetWindowPos = GengoLibrary.ImportNow("glfwGetWindowPos")
	__imp_glfwSetWindowPos = GengoLibrary.ImportNow("glfwSetWindowPos")
	__imp_glfwGetWindowSize = GengoLibrary.ImportNow("glfwGetWindowSize")
	__imp_glfwSetWindowSizeLimits = GengoLibrary.ImportNow("glfwSetWindowSizeLimits")
	__imp_glfwSetWindowAspectRatio = GengoLibrary.ImportNow("glfwSetWindowAspectRatio")
	__imp_glfwSetWindowSize = GengoLibrary.ImportNow("glfwSetWindowSize")
	__imp_glfwGetFramebufferSize = GengoLibrary.ImportNow("glfwGetFramebufferSize")
	__imp_glfwGetWindowFrameSize = GengoLibrary.ImportNow("glfwGetWindowFrameSize")
	__imp_glfwGetWindowContentScale = GengoLibrary.ImportNow("glfwGetWindowContentScale")
	__imp_glfwGetWindowOpacity = GengoLibrary.ImportNow("glfwGetWindowOpacity")
	__imp_glfwSetWindowOpacity = GengoLibrary.ImportNow("glfwSetWindowOpacity")
	__imp_glfwIconifyWindow = GengoLibrary.ImportNow("glfwIconifyWindow")
	__imp_glfwRestoreWindow = GengoLibrary.ImportNow("glfwRestoreWindow")
	__imp_glfwMaximizeWindow = GengoLibrary.ImportNow("glfwMaximizeWindow")
	__imp_glfwShowWindow = GengoLibrary.ImportNow("glfwShowWindow")
	__imp_glfwHideWindow = GengoLibrary.ImportNow("glfwHideWindow")
	__imp_glfwFocusWindow = GengoLibrary.ImportNow("glfwFocusWindow")
	__imp_glfwRequestWindowAttention = GengoLibrary.ImportNow("glfwRequestWindowAttention")
	__imp_glfwGetWindowMonitor = GengoLibrary.ImportNow("glfwGetWindowMonitor")
	__imp_glfwSetWindowMonitor = GengoLibrary.ImportNow("glfwSetWindowMonitor")
	__imp_glfwGetWindowAttrib = GengoLibrary.ImportNow("glfwGetWindowAttrib")
	__imp_glfwSetWindowAttrib = GengoLibrary.ImportNow("glfwSetWindowAttrib")
	__imp_glfwSetWindowUserPointer = GengoLibrary.ImportNow("glfwSetWindowUserPointer")
	__imp_glfwGetWindowUserPointer = GengoLibrary.ImportNow("glfwGetWindowUserPointer")
	__imp_glfwSetWindowPosCallback = GengoLibrary.ImportNow("glfwSetWindowPosCallback")
	__imp_glfwSetWindowSizeCallback = GengoLibrary.ImportNow("glfwSetWindowSizeCallback")
	__imp_glfwSetWindowCloseCallback = GengoLibrary.ImportNow("glfwSetWindowCloseCallback")
	__imp_glfwSetWindowRefreshCallback = GengoLibrary.ImportNow("glfwSetWindowRefreshCallback")
	__imp_glfwSetWindowFocusCallback = GengoLibrary.ImportNow("glfwSetWindowFocusCallback")
	__imp_glfwSetWindowIconifyCallback = GengoLibrary.ImportNow("glfwSetWindowIconifyCallback")
	__imp_glfwSetWindowMaximizeCallback = GengoLibrary.ImportNow("glfwSetWindowMaximizeCallback")
	__imp_glfwSetFramebufferSizeCallback = GengoLibrary.ImportNow("glfwSetFramebufferSizeCallback")
	__imp_glfwSetWindowContentScaleCallback = GengoLibrary.ImportNow("glfwSetWindowContentScaleCallback")
	__imp_glfwPollEvents = GengoLibrary.ImportNow("glfwPollEvents")
	__imp_glfwWaitEvents = GengoLibrary.ImportNow("glfwWaitEvents")
	__imp_glfwWaitEventsTimeout = GengoLibrary.ImportNow("glfwWaitEventsTimeout")
	__imp_glfwPostEmptyEvent = GengoLibrary.ImportNow("glfwPostEmptyEvent")
	__imp_glfwGetInputMode = GengoLibrary.ImportNow("glfwGetInputMode")
	__imp_glfwSetInputMode = GengoLibrary.ImportNow("glfwSetInputMode")
	__imp_glfwRawMouseMotionSupported = GengoLibrary.ImportNow("glfwRawMouseMotionSupported")
	__imp_glfwGetKeyName = GengoLibrary.ImportNow("glfwGetKeyName")
	__imp_glfwGetKeyScancode = GengoLibrary.ImportNow("glfwGetKeyScancode")
	__imp_glfwGetKey = GengoLibrary.ImportNow("glfwGetKey")
	__imp_glfwGetMouseButton = GengoLibrary.ImportNow("glfwGetMouseButton")
	__imp_glfwGetCursorPos = GengoLibrary.ImportNow("glfwGetCursorPos")
	__imp_glfwSetCursorPos = GengoLibrary.ImportNow("glfwSetCursorPos")
	__imp_glfwCreateCursor = GengoLibrary.ImportNow("glfwCreateCursor")
	__imp_glfwCreateStandardCursor = GengoLibrary.ImportNow("glfwCreateStandardCursor")
	__imp_glfwDestroyCursor = GengoLibrary.ImportNow("glfwDestroyCursor")
	__imp_glfwSetCursor = GengoLibrary.ImportNow("glfwSetCursor")
	__imp_glfwSetKeyCallback = GengoLibrary.ImportNow("glfwSetKeyCallback")
	__imp_glfwSetCharCallback = GengoLibrary.ImportNow("glfwSetCharCallback")
	__imp_glfwSetCharModsCallback = GengoLibrary.ImportNow("glfwSetCharModsCallback")
	__imp_glfwSetMouseButtonCallback = GengoLibrary.ImportNow("glfwSetMouseButtonCallback")
	__imp_glfwSetCursorPosCallback = GengoLibrary.ImportNow("glfwSetCursorPosCallback")
	__imp_glfwSetCursorEnterCallback = GengoLibrary.ImportNow("glfwSetCursorEnterCallback")
	__imp_glfwSetScrollCallback = GengoLibrary.ImportNow("glfwSetScrollCallback")
	__imp_glfwSetDropCallback = GengoLibrary.ImportNow("glfwSetDropCallback")
	__imp_glfwJoystickPresent = GengoLibrary.ImportNow("glfwJoystickPresent")
	__imp_glfwGetJoystickAxes = GengoLibrary.ImportNow("glfwGetJoystickAxes")
	__imp_glfwGetJoystickButtons = GengoLibrary.ImportNow("glfwGetJoystickButtons")
	__imp_glfwGetJoystickHats = GengoLibrary.ImportNow("glfwGetJoystickHats")
	__imp_glfwGetJoystickName = GengoLibrary.ImportNow("glfwGetJoystickName")
	__imp_glfwGetJoystickGUID = GengoLibrary.ImportNow("glfwGetJoystickGUID")
	__imp_glfwSetJoystickUserPointer = GengoLibrary.ImportNow("glfwSetJoystickUserPointer")
	__imp_glfwGetJoystickUserPointer = GengoLibrary.ImportNow("glfwGetJoystickUserPointer")
	__imp_glfwJoystickIsGamepad = GengoLibrary.ImportNow("glfwJoystickIsGamepad")
	__imp_glfwSetJoystickCallback = GengoLibrary.ImportNow("glfwSetJoystickCallback")
	__imp_glfwUpdateGamepadMappings = GengoLibrary.ImportNow("glfwUpdateGamepadMappings")
	__imp_glfwGetGamepadName = GengoLibrary.ImportNow("glfwGetGamepadName")
	__imp_glfwGetGamepadState = GengoLibrary.ImportNow("glfwGetGamepadState")
	__imp_glfwSetClipboardString = GengoLibrary.ImportNow("glfwSetClipboardString")
	__imp_glfwGetClipboardString = GengoLibrary.ImportNow("glfwGetClipboardString")
	__imp_glfwGetTime = GengoLibrary.ImportNow("glfwGetTime")
	__imp_glfwSetTime = GengoLibrary.ImportNow("glfwSetTime")
	__imp_glfwGetTimerValue = GengoLibrary.ImportNow("glfwGetTimerValue")
	__imp_glfwGetTimerFrequency = GengoLibrary.ImportNow("glfwGetTimerFrequency")
	__imp_glfwMakeContextCurrent = GengoLibrary.ImportNow("glfwMakeContextCurrent")
	__imp_glfwGetCurrentContext = GengoLibrary.ImportNow("glfwGetCurrentContext")
	__imp_glfwSwapBuffers = GengoLibrary.ImportNow("glfwSwapBuffers")
	__imp_glfwSwapInterval = GengoLibrary.ImportNow("glfwSwapInterval")
	__imp_glfwExtensionSupported = GengoLibrary.ImportNow("glfwExtensionSupported")
	__imp_glfwGetProcAddress = GengoLibrary.ImportNow("glfwGetProcAddress")
	__imp_glfwVulkanSupported = GengoLibrary.ImportNow("glfwVulkanSupported")
	__imp_glfwGetRequiredInstanceExtensions = GengoLibrary.ImportNow("glfwGetRequiredInstanceExtensions")
	bindlib.Validate((*_CrtLocaleDataPublic)(nil), 16, 8, "_LocalePctype", 0, "_LocaleMbCurMax", 8, "_LocaleLcCodepage", 12)
	bindlib.Validate((*_CrtLocalePointers)(nil), 16, 8, "Locinfo", 0, "Mbcinfo", 8)
	bindlib.Validate((*_Mbstatet)(nil), 8, 4, "_Wchar", 0, "_Byte", 4, "_State", 6)
	bindlib.Validate((*Vidmode)(nil), 24, 4, "Width", 0, "Height", 4, "redBits", 8, "greenBits", 12, "blueBits", 16, "refreshRate", 20)
	bindlib.Validate((*Gammaramp)(nil), 32, 8, "Red", 0, "Green", 8, "Blue", 16, "Size", 24)
	bindlib.Validate((*Image)(nil), 16, 8, "Width", 0, "Height", 4, "Pixels", 8)
	bindlib.Validate((*Gamepadstate)(nil), 40, 4, "Buttons", 0, "Axes", 16)
	bindlib.Validate((*Allocator)(nil), 32, 8, "Allocate", 0, "Reallocate", 8, "Deallocate", 16, "User", 24)
}
func _VaStart(arg **byte) { bindlib.CCall1(__imp___va_start.Addr(), bindlib.MarshallSyscall(arg)) }

var __imp___va_start bindlib.PreloadProc

func _VaStart(arg *VaList) { bindlib.CCall1(__imp___va_start.Addr(), bindlib.MarshallSyscall(arg)) }

var __imp___security_init_cookie bindlib.PreloadProc

func _SecurityInitCookie() { bindlib.CCall0(__imp___security_init_cookie.Addr()) }

var __imp___security_check_cookie bindlib.PreloadProc

func _SecurityCheckCookie(_StackCookie uintptr) {
	bindlib.CCall1(__imp___security_check_cookie.Addr(), bindlib.MarshallSyscall(_StackCookie))
}

var __imp___report_gsfailure bindlib.PreloadProc

func _ReportGsfailure(_StackCookie uintptr) {
	bindlib.CCall1(__imp___report_gsfailure.Addr(), bindlib.MarshallSyscall(_StackCookie))
}

var __imp__invalid_parameter_noinfo bindlib.PreloadProc

func _InvalidParameterNoinfo() { bindlib.CCall0(__imp__invalid_parameter_noinfo.Addr()) }

var __imp__invalid_parameter_noinfo_noreturn bindlib.PreloadProc

func _InvalidParameterNoinfoNoreturn() {
	bindlib.CCall0(__imp__invalid_parameter_noinfo_noreturn.Addr())
}

var __imp__invoke_watson bindlib.PreloadProc

func _InvokeWatson(_Expression *WcharT, _FunctionName *WcharT, _FileName *WcharT, _LineNo uint32, _Reserved uintptr) {
	bindlib.CCall5(__imp__invoke_watson.Addr(), bindlib.MarshallSyscall(_Expression), bindlib.MarshallSyscall(_FunctionName), bindlib.MarshallSyscall(_FileName), bindlib.MarshallSyscall(_LineNo), bindlib.MarshallSyscall(_Reserved))
}

var __imp__errno bindlib.PreloadProc

func _Errno() *int32 {
	__res := bindlib.CCall0(__imp__errno.Addr())
	return bindlib.UnmarshallSyscall[*int32](__res)
}

var __imp__set_errno bindlib.PreloadProc

func _SetErrno(_Value int32) ErrnoT {
	__res := bindlib.CCall1(__imp__set_errno.Addr(), bindlib.MarshallSyscall(_Value))
	return bindlib.UnmarshallSyscall[ErrnoT](__res)
}

var __imp__get_errno bindlib.PreloadProc

func _GetErrno(_Value *int32) ErrnoT {
	__res := bindlib.CCall1(__imp__get_errno.Addr(), bindlib.MarshallSyscall(_Value))
	return bindlib.UnmarshallSyscall[ErrnoT](__res)
}

var __imp___threadid bindlib.PreloadProc

func _Threadid() uint64 {
	__res := bindlib.CCall0(__imp___threadid.Addr())
	return bindlib.UnmarshallSyscall[uint64](__res)
}

var __imp___threadhandle bindlib.PreloadProc

func _Threadhandle() uintptr {
	__res := bindlib.CCall0(__imp___threadhandle.Addr())
	return bindlib.UnmarshallSyscall[uintptr](__res)
}

var __imp_glAccum bindlib.PreloadProc

func Accum(op Enum, value Float) {
	bindlib.CCall2(__imp_glAccum.Addr(), bindlib.MarshallSyscall(op), bindlib.MarshallSyscall(value))
}

var __imp_glAlphaFunc bindlib.PreloadProc

func AlphaFunc(_func Enum, ref Clampf) {
	bindlib.CCall2(__imp_glAlphaFunc.Addr(), bindlib.MarshallSyscall(_func), bindlib.MarshallSyscall(ref))
}

var __imp_glAreTexturesResident bindlib.PreloadProc

func AreTexturesResident(n Sizei, textures *Uint, residences *Boolean) Boolean {
	__res := bindlib.CCall3(__imp_glAreTexturesResident.Addr(), bindlib.MarshallSyscall(n), bindlib.MarshallSyscall(textures), bindlib.MarshallSyscall(residences))
	return bindlib.UnmarshallSyscall[Boolean](__res)
}

var __imp_glArrayElement bindlib.PreloadProc

func ArrayElement(i Int) { bindlib.CCall1(__imp_glArrayElement.Addr(), bindlib.MarshallSyscall(i)) }

var __imp_glBegin bindlib.PreloadProc

func Begin(mode Enum) { bindlib.CCall1(__imp_glBegin.Addr(), bindlib.MarshallSyscall(mode)) }

var __imp_glBindTexture bindlib.PreloadProc

func BindTexture(target Enum, texture Uint) {
	bindlib.CCall2(__imp_glBindTexture.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(texture))
}

var __imp_glBitmap bindlib.PreloadProc

func Bitmap(width Sizei, height Sizei, xorig Float, yorig Float, xmove Float, ymove Float, bitmap *Ubyte) {
	bindlib.CCall7(__imp_glBitmap.Addr(), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height), bindlib.MarshallSyscall(xorig), bindlib.MarshallSyscall(yorig), bindlib.MarshallSyscall(xmove), bindlib.MarshallSyscall(ymove), bindlib.MarshallSyscall(bitmap))
}

var __imp_glBlendFunc bindlib.PreloadProc

func BlendFunc(sfactor Enum, dfactor Enum) {
	bindlib.CCall2(__imp_glBlendFunc.Addr(), bindlib.MarshallSyscall(sfactor), bindlib.MarshallSyscall(dfactor))
}

var __imp_glCallList bindlib.PreloadProc

func CallList(list Uint) { bindlib.CCall1(__imp_glCallList.Addr(), bindlib.MarshallSyscall(list)) }

var __imp_glCallLists bindlib.PreloadProc

func CallLists(n Sizei, _type Enum, lists *Void) {
	bindlib.CCall3(__imp_glCallLists.Addr(), bindlib.MarshallSyscall(n), bindlib.MarshallSyscall(_type), bindlib.MarshallSyscall(lists))
}

var __imp_glClear bindlib.PreloadProc

func Clear(mask Bitfield) { bindlib.CCall1(__imp_glClear.Addr(), bindlib.MarshallSyscall(mask)) }

var __imp_glClearAccum bindlib.PreloadProc

func ClearAccum(red Float, green Float, blue Float, alpha Float) {
	bindlib.CCall4(__imp_glClearAccum.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue), bindlib.MarshallSyscall(alpha))
}

var __imp_glClearColor bindlib.PreloadProc

func ClearColor(red Clampf, green Clampf, blue Clampf, alpha Clampf) {
	bindlib.CCall4(__imp_glClearColor.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue), bindlib.MarshallSyscall(alpha))
}

var __imp_glClearDepth bindlib.PreloadProc

func ClearDepth(depth Clampd) {
	bindlib.CCall1(__imp_glClearDepth.Addr(), bindlib.MarshallSyscall(depth))
}

var __imp_glClearIndex bindlib.PreloadProc

func ClearIndex(c Float) { bindlib.CCall1(__imp_glClearIndex.Addr(), bindlib.MarshallSyscall(c)) }

var __imp_glClearStencil bindlib.PreloadProc

func ClearStencil(s Int) { bindlib.CCall1(__imp_glClearStencil.Addr(), bindlib.MarshallSyscall(s)) }

var __imp_glClipPlane bindlib.PreloadProc

func ClipPlane(plane Enum, equation *Double) {
	bindlib.CCall2(__imp_glClipPlane.Addr(), bindlib.MarshallSyscall(plane), bindlib.MarshallSyscall(equation))
}

var __imp_glColor3b bindlib.PreloadProc

func Color3b(red Byte, green Byte, blue Byte) {
	bindlib.CCall3(__imp_glColor3b.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue))
}

var __imp_glColor3bv bindlib.PreloadProc

func Color3bv(v *Byte) { bindlib.CCall1(__imp_glColor3bv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glColor3d bindlib.PreloadProc

func Color3d(red Double, green Double, blue Double) {
	bindlib.CCall3(__imp_glColor3d.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue))
}

var __imp_glColor3dv bindlib.PreloadProc

func Color3dv(v *Double) { bindlib.CCall1(__imp_glColor3dv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glColor3f bindlib.PreloadProc

func Color3f(red Float, green Float, blue Float) {
	bindlib.CCall3(__imp_glColor3f.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue))
}

var __imp_glColor3fv bindlib.PreloadProc

func Color3fv(v *Float) { bindlib.CCall1(__imp_glColor3fv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glColor3i bindlib.PreloadProc

func Color3i(red Int, green Int, blue Int) {
	bindlib.CCall3(__imp_glColor3i.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue))
}

var __imp_glColor3iv bindlib.PreloadProc

func Color3iv(v *Int) { bindlib.CCall1(__imp_glColor3iv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glColor3s bindlib.PreloadProc

func Color3s(red Short, green Short, blue Short) {
	bindlib.CCall3(__imp_glColor3s.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue))
}

var __imp_glColor3sv bindlib.PreloadProc

func Color3sv(v *Short) { bindlib.CCall1(__imp_glColor3sv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glColor3ub bindlib.PreloadProc

func Color3ub(red Ubyte, green Ubyte, blue Ubyte) {
	bindlib.CCall3(__imp_glColor3ub.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue))
}

var __imp_glColor3ubv bindlib.PreloadProc

func Color3ubv(v *Ubyte) { bindlib.CCall1(__imp_glColor3ubv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glColor3ui bindlib.PreloadProc

func Color3ui(red Uint, green Uint, blue Uint) {
	bindlib.CCall3(__imp_glColor3ui.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue))
}

var __imp_glColor3uiv bindlib.PreloadProc

func Color3uiv(v *Uint) { bindlib.CCall1(__imp_glColor3uiv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glColor3us bindlib.PreloadProc

func Color3us(red Ushort, green Ushort, blue Ushort) {
	bindlib.CCall3(__imp_glColor3us.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue))
}

var __imp_glColor3usv bindlib.PreloadProc

func Color3usv(v *Ushort) { bindlib.CCall1(__imp_glColor3usv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glColor4b bindlib.PreloadProc

func Color4b(red Byte, green Byte, blue Byte, alpha Byte) {
	bindlib.CCall4(__imp_glColor4b.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue), bindlib.MarshallSyscall(alpha))
}

var __imp_glColor4bv bindlib.PreloadProc

func Color4bv(v *Byte) { bindlib.CCall1(__imp_glColor4bv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glColor4d bindlib.PreloadProc

func Color4d(red Double, green Double, blue Double, alpha Double) {
	bindlib.CCall4(__imp_glColor4d.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue), bindlib.MarshallSyscall(alpha))
}

var __imp_glColor4dv bindlib.PreloadProc

func Color4dv(v *Double) { bindlib.CCall1(__imp_glColor4dv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glColor4f bindlib.PreloadProc

func Color4f(red Float, green Float, blue Float, alpha Float) {
	bindlib.CCall4(__imp_glColor4f.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue), bindlib.MarshallSyscall(alpha))
}

var __imp_glColor4fv bindlib.PreloadProc

func Color4fv(v *Float) { bindlib.CCall1(__imp_glColor4fv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glColor4i bindlib.PreloadProc

func Color4i(red Int, green Int, blue Int, alpha Int) {
	bindlib.CCall4(__imp_glColor4i.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue), bindlib.MarshallSyscall(alpha))
}

var __imp_glColor4iv bindlib.PreloadProc

func Color4iv(v *Int) { bindlib.CCall1(__imp_glColor4iv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glColor4s bindlib.PreloadProc

func Color4s(red Short, green Short, blue Short, alpha Short) {
	bindlib.CCall4(__imp_glColor4s.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue), bindlib.MarshallSyscall(alpha))
}

var __imp_glColor4sv bindlib.PreloadProc

func Color4sv(v *Short) { bindlib.CCall1(__imp_glColor4sv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glColor4ub bindlib.PreloadProc

func Color4ub(red Ubyte, green Ubyte, blue Ubyte, alpha Ubyte) {
	bindlib.CCall4(__imp_glColor4ub.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue), bindlib.MarshallSyscall(alpha))
}

var __imp_glColor4ubv bindlib.PreloadProc

func Color4ubv(v *Ubyte) { bindlib.CCall1(__imp_glColor4ubv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glColor4ui bindlib.PreloadProc

func Color4ui(red Uint, green Uint, blue Uint, alpha Uint) {
	bindlib.CCall4(__imp_glColor4ui.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue), bindlib.MarshallSyscall(alpha))
}

var __imp_glColor4uiv bindlib.PreloadProc

func Color4uiv(v *Uint) { bindlib.CCall1(__imp_glColor4uiv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glColor4us bindlib.PreloadProc

func Color4us(red Ushort, green Ushort, blue Ushort, alpha Ushort) {
	bindlib.CCall4(__imp_glColor4us.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue), bindlib.MarshallSyscall(alpha))
}

var __imp_glColor4usv bindlib.PreloadProc

func Color4usv(v *Ushort) { bindlib.CCall1(__imp_glColor4usv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glColorMask bindlib.PreloadProc

func ColorMask(red Boolean, green Boolean, blue Boolean, alpha Boolean) {
	bindlib.CCall4(__imp_glColorMask.Addr(), bindlib.MarshallSyscall(red), bindlib.MarshallSyscall(green), bindlib.MarshallSyscall(blue), bindlib.MarshallSyscall(alpha))
}

var __imp_glColorMaterial bindlib.PreloadProc

func ColorMaterial(face Enum, mode Enum) {
	bindlib.CCall2(__imp_glColorMaterial.Addr(), bindlib.MarshallSyscall(face), bindlib.MarshallSyscall(mode))
}

var __imp_glColorPointer bindlib.PreloadProc

func ColorPointer(size Int, _type Enum, stride Sizei, pointer *Void) {
	bindlib.CCall4(__imp_glColorPointer.Addr(), bindlib.MarshallSyscall(size), bindlib.MarshallSyscall(_type), bindlib.MarshallSyscall(stride), bindlib.MarshallSyscall(pointer))
}

var __imp_glCopyPixels bindlib.PreloadProc

func CopyPixels(x Int, y Int, width Sizei, height Sizei, _type Enum) {
	bindlib.CCall5(__imp_glCopyPixels.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height), bindlib.MarshallSyscall(_type))
}

var __imp_glCopyTexImage1D bindlib.PreloadProc

func CopyTexImage1D(target Enum, level Int, internalFormat Enum, x Int, y Int, width Sizei, border Int) {
	bindlib.CCall7(__imp_glCopyTexImage1D.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(level), bindlib.MarshallSyscall(internalFormat), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(border))
}

var __imp_glCopyTexImage2D bindlib.PreloadProc

func CopyTexImage2D(target Enum, level Int, internalFormat Enum, x Int, y Int, width Sizei, height Sizei, border Int) {
	bindlib.CCall8(__imp_glCopyTexImage2D.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(level), bindlib.MarshallSyscall(internalFormat), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height), bindlib.MarshallSyscall(border))
}

var __imp_glCopyTexSubImage1D bindlib.PreloadProc

func CopyTexSubImage1D(target Enum, level Int, xoffset Int, x Int, y Int, width Sizei) {
	bindlib.CCall6(__imp_glCopyTexSubImage1D.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(level), bindlib.MarshallSyscall(xoffset), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(width))
}

var __imp_glCopyTexSubImage2D bindlib.PreloadProc

func CopyTexSubImage2D(target Enum, level Int, xoffset Int, yoffset Int, x Int, y Int, width Sizei, height Sizei) {
	bindlib.CCall8(__imp_glCopyTexSubImage2D.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(level), bindlib.MarshallSyscall(xoffset), bindlib.MarshallSyscall(yoffset), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height))
}

var __imp_glCullFace bindlib.PreloadProc

func CullFace(mode Enum) { bindlib.CCall1(__imp_glCullFace.Addr(), bindlib.MarshallSyscall(mode)) }

var __imp_glDeleteLists bindlib.PreloadProc

func DeleteLists(list Uint, _range Sizei) {
	bindlib.CCall2(__imp_glDeleteLists.Addr(), bindlib.MarshallSyscall(list), bindlib.MarshallSyscall(_range))
}

var __imp_glDeleteTextures bindlib.PreloadProc

func DeleteTextures(n Sizei, textures *Uint) {
	bindlib.CCall2(__imp_glDeleteTextures.Addr(), bindlib.MarshallSyscall(n), bindlib.MarshallSyscall(textures))
}

var __imp_glDepthFunc bindlib.PreloadProc

func DepthFunc(_func Enum) { bindlib.CCall1(__imp_glDepthFunc.Addr(), bindlib.MarshallSyscall(_func)) }

var __imp_glDepthMask bindlib.PreloadProc

func DepthMask(flag Boolean) { bindlib.CCall1(__imp_glDepthMask.Addr(), bindlib.MarshallSyscall(flag)) }

var __imp_glDepthRange bindlib.PreloadProc

func DepthRange(zNear Clampd, zFar Clampd) {
	bindlib.CCall2(__imp_glDepthRange.Addr(), bindlib.MarshallSyscall(zNear), bindlib.MarshallSyscall(zFar))
}

var __imp_glDisable bindlib.PreloadProc

func Disable(_cap Enum) { bindlib.CCall1(__imp_glDisable.Addr(), bindlib.MarshallSyscall(_cap)) }

var __imp_glDisableClientState bindlib.PreloadProc

func DisableClientState(array Enum) {
	bindlib.CCall1(__imp_glDisableClientState.Addr(), bindlib.MarshallSyscall(array))
}

var __imp_glDrawArrays bindlib.PreloadProc

func DrawArrays(mode Enum, first Int, count Sizei) {
	bindlib.CCall3(__imp_glDrawArrays.Addr(), bindlib.MarshallSyscall(mode), bindlib.MarshallSyscall(first), bindlib.MarshallSyscall(count))
}

var __imp_glDrawBuffer bindlib.PreloadProc

func DrawBuffer(mode Enum) { bindlib.CCall1(__imp_glDrawBuffer.Addr(), bindlib.MarshallSyscall(mode)) }

var __imp_glDrawElements bindlib.PreloadProc

func DrawElements(mode Enum, count Sizei, _type Enum, indices *Void) {
	bindlib.CCall4(__imp_glDrawElements.Addr(), bindlib.MarshallSyscall(mode), bindlib.MarshallSyscall(count), bindlib.MarshallSyscall(_type), bindlib.MarshallSyscall(indices))
}

var __imp_glDrawPixels bindlib.PreloadProc

func DrawPixels(width Sizei, height Sizei, format Enum, _type Enum, pixels *Void) {
	bindlib.CCall5(__imp_glDrawPixels.Addr(), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height), bindlib.MarshallSyscall(format), bindlib.MarshallSyscall(_type), bindlib.MarshallSyscall(pixels))
}

var __imp_glEdgeFlag bindlib.PreloadProc

func EdgeFlag(flag Boolean) { bindlib.CCall1(__imp_glEdgeFlag.Addr(), bindlib.MarshallSyscall(flag)) }

var __imp_glEdgeFlagPointer bindlib.PreloadProc

func EdgeFlagPointer(stride Sizei, pointer *Void) {
	bindlib.CCall2(__imp_glEdgeFlagPointer.Addr(), bindlib.MarshallSyscall(stride), bindlib.MarshallSyscall(pointer))
}

var __imp_glEdgeFlagv bindlib.PreloadProc

func EdgeFlagv(flag *Boolean) {
	bindlib.CCall1(__imp_glEdgeFlagv.Addr(), bindlib.MarshallSyscall(flag))
}

var __imp_glEnable bindlib.PreloadProc

func Enable(_cap Enum) { bindlib.CCall1(__imp_glEnable.Addr(), bindlib.MarshallSyscall(_cap)) }

var __imp_glEnableClientState bindlib.PreloadProc

func EnableClientState(array Enum) {
	bindlib.CCall1(__imp_glEnableClientState.Addr(), bindlib.MarshallSyscall(array))
}

var __imp_glEnd bindlib.PreloadProc

func End() { bindlib.CCall0(__imp_glEnd.Addr()) }

var __imp_glEndList bindlib.PreloadProc

func EndList() { bindlib.CCall0(__imp_glEndList.Addr()) }

var __imp_glEvalCoord1d bindlib.PreloadProc

func EvalCoord1d(u Double) { bindlib.CCall1(__imp_glEvalCoord1d.Addr(), bindlib.MarshallSyscall(u)) }

var __imp_glEvalCoord1dv bindlib.PreloadProc

func EvalCoord1dv(u *Double) { bindlib.CCall1(__imp_glEvalCoord1dv.Addr(), bindlib.MarshallSyscall(u)) }

var __imp_glEvalCoord1f bindlib.PreloadProc

func EvalCoord1f(u Float) { bindlib.CCall1(__imp_glEvalCoord1f.Addr(), bindlib.MarshallSyscall(u)) }

var __imp_glEvalCoord1fv bindlib.PreloadProc

func EvalCoord1fv(u *Float) { bindlib.CCall1(__imp_glEvalCoord1fv.Addr(), bindlib.MarshallSyscall(u)) }

var __imp_glEvalCoord2d bindlib.PreloadProc

func EvalCoord2d(u Double, v Double) {
	bindlib.CCall2(__imp_glEvalCoord2d.Addr(), bindlib.MarshallSyscall(u), bindlib.MarshallSyscall(v))
}

var __imp_glEvalCoord2dv bindlib.PreloadProc

func EvalCoord2dv(u *Double) { bindlib.CCall1(__imp_glEvalCoord2dv.Addr(), bindlib.MarshallSyscall(u)) }

var __imp_glEvalCoord2f bindlib.PreloadProc

func EvalCoord2f(u Float, v Float) {
	bindlib.CCall2(__imp_glEvalCoord2f.Addr(), bindlib.MarshallSyscall(u), bindlib.MarshallSyscall(v))
}

var __imp_glEvalCoord2fv bindlib.PreloadProc

func EvalCoord2fv(u *Float) { bindlib.CCall1(__imp_glEvalCoord2fv.Addr(), bindlib.MarshallSyscall(u)) }

var __imp_glEvalMesh1 bindlib.PreloadProc

func EvalMesh1(mode Enum, i1 Int, i2 Int) {
	bindlib.CCall3(__imp_glEvalMesh1.Addr(), bindlib.MarshallSyscall(mode), bindlib.MarshallSyscall(i1), bindlib.MarshallSyscall(i2))
}

var __imp_glEvalMesh2 bindlib.PreloadProc

func EvalMesh2(mode Enum, i1 Int, i2 Int, j1 Int, j2 Int) {
	bindlib.CCall5(__imp_glEvalMesh2.Addr(), bindlib.MarshallSyscall(mode), bindlib.MarshallSyscall(i1), bindlib.MarshallSyscall(i2), bindlib.MarshallSyscall(j1), bindlib.MarshallSyscall(j2))
}

var __imp_glEvalPoint1 bindlib.PreloadProc

func EvalPoint1(i Int) { bindlib.CCall1(__imp_glEvalPoint1.Addr(), bindlib.MarshallSyscall(i)) }

var __imp_glEvalPoint2 bindlib.PreloadProc

func EvalPoint2(i Int, j Int) {
	bindlib.CCall2(__imp_glEvalPoint2.Addr(), bindlib.MarshallSyscall(i), bindlib.MarshallSyscall(j))
}

var __imp_glFeedbackBuffer bindlib.PreloadProc

func FeedbackBuffer(size Sizei, _type Enum, buffer *Float) {
	bindlib.CCall3(__imp_glFeedbackBuffer.Addr(), bindlib.MarshallSyscall(size), bindlib.MarshallSyscall(_type), bindlib.MarshallSyscall(buffer))
}

var __imp_glFinish bindlib.PreloadProc

func Finish() { bindlib.CCall0(__imp_glFinish.Addr()) }

var __imp_glFlush bindlib.PreloadProc

func Flush() { bindlib.CCall0(__imp_glFlush.Addr()) }

var __imp_glFogf bindlib.PreloadProc

func Fogf(pname Enum, param Float) {
	bindlib.CCall2(__imp_glFogf.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glFogfv bindlib.PreloadProc

func Fogfv(pname Enum, params *Float) {
	bindlib.CCall2(__imp_glFogfv.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glFogi bindlib.PreloadProc

func Fogi(pname Enum, param Int) {
	bindlib.CCall2(__imp_glFogi.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glFogiv bindlib.PreloadProc

func Fogiv(pname Enum, params *Int) {
	bindlib.CCall2(__imp_glFogiv.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glFrontFace bindlib.PreloadProc

func FrontFace(mode Enum) { bindlib.CCall1(__imp_glFrontFace.Addr(), bindlib.MarshallSyscall(mode)) }

var __imp_glFrustum bindlib.PreloadProc

func Frustum(left Double, right Double, bottom Double, top Double, zNear Double, zFar Double) {
	bindlib.CCall6(__imp_glFrustum.Addr(), bindlib.MarshallSyscall(left), bindlib.MarshallSyscall(right), bindlib.MarshallSyscall(bottom), bindlib.MarshallSyscall(top), bindlib.MarshallSyscall(zNear), bindlib.MarshallSyscall(zFar))
}

var __imp_glGenLists bindlib.PreloadProc

func GenLists(_range Sizei) Uint {
	__res := bindlib.CCall1(__imp_glGenLists.Addr(), bindlib.MarshallSyscall(_range))
	return bindlib.UnmarshallSyscall[Uint](__res)
}

var __imp_glGenTextures bindlib.PreloadProc

func GenTextures(n Sizei, textures *Uint) {
	bindlib.CCall2(__imp_glGenTextures.Addr(), bindlib.MarshallSyscall(n), bindlib.MarshallSyscall(textures))
}

var __imp_glGetBooleanv bindlib.PreloadProc

func GetBooleanv(pname Enum, params *Boolean) {
	bindlib.CCall2(__imp_glGetBooleanv.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetClipPlane bindlib.PreloadProc

func GetClipPlane(plane Enum, equation *Double) {
	bindlib.CCall2(__imp_glGetClipPlane.Addr(), bindlib.MarshallSyscall(plane), bindlib.MarshallSyscall(equation))
}

var __imp_glGetDoublev bindlib.PreloadProc

func GetDoublev(pname Enum, params *Double) {
	bindlib.CCall2(__imp_glGetDoublev.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetError bindlib.PreloadProc

func GetError() Enum {
	__res := bindlib.CCall0(__imp_glGetError.Addr())
	return bindlib.UnmarshallSyscall[Enum](__res)
}

var __imp_glGetFloatv bindlib.PreloadProc

func GetFloatv(pname Enum, params *Float) {
	bindlib.CCall2(__imp_glGetFloatv.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetIntegerv bindlib.PreloadProc

func GetIntegerv(pname Enum, params *Int) {
	bindlib.CCall2(__imp_glGetIntegerv.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetLightfv bindlib.PreloadProc

func GetLightfv(light Enum, pname Enum, params *Float) {
	bindlib.CCall3(__imp_glGetLightfv.Addr(), bindlib.MarshallSyscall(light), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetLightiv bindlib.PreloadProc

func GetLightiv(light Enum, pname Enum, params *Int) {
	bindlib.CCall3(__imp_glGetLightiv.Addr(), bindlib.MarshallSyscall(light), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetMapdv bindlib.PreloadProc

func GetMapdv(target Enum, query Enum, v *Double) {
	bindlib.CCall3(__imp_glGetMapdv.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(query), bindlib.MarshallSyscall(v))
}

var __imp_glGetMapfv bindlib.PreloadProc

func GetMapfv(target Enum, query Enum, v *Float) {
	bindlib.CCall3(__imp_glGetMapfv.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(query), bindlib.MarshallSyscall(v))
}

var __imp_glGetMapiv bindlib.PreloadProc

func GetMapiv(target Enum, query Enum, v *Int) {
	bindlib.CCall3(__imp_glGetMapiv.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(query), bindlib.MarshallSyscall(v))
}

var __imp_glGetMaterialfv bindlib.PreloadProc

func GetMaterialfv(face Enum, pname Enum, params *Float) {
	bindlib.CCall3(__imp_glGetMaterialfv.Addr(), bindlib.MarshallSyscall(face), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetMaterialiv bindlib.PreloadProc

func GetMaterialiv(face Enum, pname Enum, params *Int) {
	bindlib.CCall3(__imp_glGetMaterialiv.Addr(), bindlib.MarshallSyscall(face), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetPixelMapfv bindlib.PreloadProc

func GetPixelMapfv(_map Enum, values *Float) {
	bindlib.CCall2(__imp_glGetPixelMapfv.Addr(), bindlib.MarshallSyscall(_map), bindlib.MarshallSyscall(values))
}

var __imp_glGetPixelMapuiv bindlib.PreloadProc

func GetPixelMapuiv(_map Enum, values *Uint) {
	bindlib.CCall2(__imp_glGetPixelMapuiv.Addr(), bindlib.MarshallSyscall(_map), bindlib.MarshallSyscall(values))
}

var __imp_glGetPixelMapusv bindlib.PreloadProc

func GetPixelMapusv(_map Enum, values *Ushort) {
	bindlib.CCall2(__imp_glGetPixelMapusv.Addr(), bindlib.MarshallSyscall(_map), bindlib.MarshallSyscall(values))
}

var __imp_glGetPointerv bindlib.PreloadProc

func GetPointerv(pname Enum, params **Void) {
	bindlib.CCall2(__imp_glGetPointerv.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetPolygonStipple bindlib.PreloadProc

func GetPolygonStipple(mask *Ubyte) {
	bindlib.CCall1(__imp_glGetPolygonStipple.Addr(), bindlib.MarshallSyscall(mask))
}

var __imp_glGetString bindlib.PreloadProc

func GetString(name Enum) *Ubyte {
	__res := bindlib.CCall1(__imp_glGetString.Addr(), bindlib.MarshallSyscall(name))
	return bindlib.UnmarshallSyscall[*Ubyte](__res)
}

var __imp_glGetTexEnvfv bindlib.PreloadProc

func GetTexEnvfv(target Enum, pname Enum, params *Float) {
	bindlib.CCall3(__imp_glGetTexEnvfv.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetTexEnviv bindlib.PreloadProc

func GetTexEnviv(target Enum, pname Enum, params *Int) {
	bindlib.CCall3(__imp_glGetTexEnviv.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetTexGendv bindlib.PreloadProc

func GetTexGendv(coord Enum, pname Enum, params *Double) {
	bindlib.CCall3(__imp_glGetTexGendv.Addr(), bindlib.MarshallSyscall(coord), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetTexGenfv bindlib.PreloadProc

func GetTexGenfv(coord Enum, pname Enum, params *Float) {
	bindlib.CCall3(__imp_glGetTexGenfv.Addr(), bindlib.MarshallSyscall(coord), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetTexGeniv bindlib.PreloadProc

func GetTexGeniv(coord Enum, pname Enum, params *Int) {
	bindlib.CCall3(__imp_glGetTexGeniv.Addr(), bindlib.MarshallSyscall(coord), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetTexImage bindlib.PreloadProc

func GetTexImage(target Enum, level Int, format Enum, _type Enum, pixels *Void) {
	bindlib.CCall5(__imp_glGetTexImage.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(level), bindlib.MarshallSyscall(format), bindlib.MarshallSyscall(_type), bindlib.MarshallSyscall(pixels))
}

var __imp_glGetTexLevelParameterfv bindlib.PreloadProc

func GetTexLevelParameterfv(target Enum, level Int, pname Enum, params *Float) {
	bindlib.CCall4(__imp_glGetTexLevelParameterfv.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(level), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetTexLevelParameteriv bindlib.PreloadProc

func GetTexLevelParameteriv(target Enum, level Int, pname Enum, params *Int) {
	bindlib.CCall4(__imp_glGetTexLevelParameteriv.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(level), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetTexParameterfv bindlib.PreloadProc

func GetTexParameterfv(target Enum, pname Enum, params *Float) {
	bindlib.CCall3(__imp_glGetTexParameterfv.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glGetTexParameteriv bindlib.PreloadProc

func GetTexParameteriv(target Enum, pname Enum, params *Int) {
	bindlib.CCall3(__imp_glGetTexParameteriv.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glHint bindlib.PreloadProc

func Hint(target Enum, mode Enum) {
	bindlib.CCall2(__imp_glHint.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(mode))
}

var __imp_glIndexMask bindlib.PreloadProc

func IndexMask(mask Uint) { bindlib.CCall1(__imp_glIndexMask.Addr(), bindlib.MarshallSyscall(mask)) }

var __imp_glIndexPointer bindlib.PreloadProc

func IndexPointer(_type Enum, stride Sizei, pointer *Void) {
	bindlib.CCall3(__imp_glIndexPointer.Addr(), bindlib.MarshallSyscall(_type), bindlib.MarshallSyscall(stride), bindlib.MarshallSyscall(pointer))
}

var __imp_glIndexd bindlib.PreloadProc

func Indexd(c Double) { bindlib.CCall1(__imp_glIndexd.Addr(), bindlib.MarshallSyscall(c)) }

var __imp_glIndexdv bindlib.PreloadProc

func Indexdv(c *Double) { bindlib.CCall1(__imp_glIndexdv.Addr(), bindlib.MarshallSyscall(c)) }

var __imp_glIndexf bindlib.PreloadProc

func Indexf(c Float) { bindlib.CCall1(__imp_glIndexf.Addr(), bindlib.MarshallSyscall(c)) }

var __imp_glIndexfv bindlib.PreloadProc

func Indexfv(c *Float) { bindlib.CCall1(__imp_glIndexfv.Addr(), bindlib.MarshallSyscall(c)) }

var __imp_glIndexi bindlib.PreloadProc

func Indexi(c Int) { bindlib.CCall1(__imp_glIndexi.Addr(), bindlib.MarshallSyscall(c)) }

var __imp_glIndexiv bindlib.PreloadProc

func Indexiv(c *Int) { bindlib.CCall1(__imp_glIndexiv.Addr(), bindlib.MarshallSyscall(c)) }

var __imp_glIndexs bindlib.PreloadProc

func Indexs(c Short) { bindlib.CCall1(__imp_glIndexs.Addr(), bindlib.MarshallSyscall(c)) }

var __imp_glIndexsv bindlib.PreloadProc

func Indexsv(c *Short) { bindlib.CCall1(__imp_glIndexsv.Addr(), bindlib.MarshallSyscall(c)) }

var __imp_glIndexub bindlib.PreloadProc

func Indexub(c Ubyte) { bindlib.CCall1(__imp_glIndexub.Addr(), bindlib.MarshallSyscall(c)) }

var __imp_glIndexubv bindlib.PreloadProc

func Indexubv(c *Ubyte) { bindlib.CCall1(__imp_glIndexubv.Addr(), bindlib.MarshallSyscall(c)) }

var __imp_glInitNames bindlib.PreloadProc

func InitNames() { bindlib.CCall0(__imp_glInitNames.Addr()) }

var __imp_glInterleavedArrays bindlib.PreloadProc

func InterleavedArrays(format Enum, stride Sizei, pointer *Void) {
	bindlib.CCall3(__imp_glInterleavedArrays.Addr(), bindlib.MarshallSyscall(format), bindlib.MarshallSyscall(stride), bindlib.MarshallSyscall(pointer))
}

var __imp_glIsEnabled bindlib.PreloadProc

func IsEnabled(_cap Enum) Boolean {
	__res := bindlib.CCall1(__imp_glIsEnabled.Addr(), bindlib.MarshallSyscall(_cap))
	return bindlib.UnmarshallSyscall[Boolean](__res)
}

var __imp_glIsList bindlib.PreloadProc

func IsList(list Uint) Boolean {
	__res := bindlib.CCall1(__imp_glIsList.Addr(), bindlib.MarshallSyscall(list))
	return bindlib.UnmarshallSyscall[Boolean](__res)
}

var __imp_glIsTexture bindlib.PreloadProc

func IsTexture(texture Uint) Boolean {
	__res := bindlib.CCall1(__imp_glIsTexture.Addr(), bindlib.MarshallSyscall(texture))
	return bindlib.UnmarshallSyscall[Boolean](__res)
}

var __imp_glLightModelf bindlib.PreloadProc

func LightModelf(pname Enum, param Float) {
	bindlib.CCall2(__imp_glLightModelf.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glLightModelfv bindlib.PreloadProc

func LightModelfv(pname Enum, params *Float) {
	bindlib.CCall2(__imp_glLightModelfv.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glLightModeli bindlib.PreloadProc

func LightModeli(pname Enum, param Int) {
	bindlib.CCall2(__imp_glLightModeli.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glLightModeliv bindlib.PreloadProc

func LightModeliv(pname Enum, params *Int) {
	bindlib.CCall2(__imp_glLightModeliv.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glLightf bindlib.PreloadProc

func Lightf(light Enum, pname Enum, param Float) {
	bindlib.CCall3(__imp_glLightf.Addr(), bindlib.MarshallSyscall(light), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glLightfv bindlib.PreloadProc

func Lightfv(light Enum, pname Enum, params *Float) {
	bindlib.CCall3(__imp_glLightfv.Addr(), bindlib.MarshallSyscall(light), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glLighti bindlib.PreloadProc

func Lighti(light Enum, pname Enum, param Int) {
	bindlib.CCall3(__imp_glLighti.Addr(), bindlib.MarshallSyscall(light), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glLightiv bindlib.PreloadProc

func Lightiv(light Enum, pname Enum, params *Int) {
	bindlib.CCall3(__imp_glLightiv.Addr(), bindlib.MarshallSyscall(light), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glLineStipple bindlib.PreloadProc

func LineStipple(factor Int, pattern Ushort) {
	bindlib.CCall2(__imp_glLineStipple.Addr(), bindlib.MarshallSyscall(factor), bindlib.MarshallSyscall(pattern))
}

var __imp_glLineWidth bindlib.PreloadProc

func LineWidth(width Float) { bindlib.CCall1(__imp_glLineWidth.Addr(), bindlib.MarshallSyscall(width)) }

var __imp_glListBase bindlib.PreloadProc

func ListBase(base Uint) { bindlib.CCall1(__imp_glListBase.Addr(), bindlib.MarshallSyscall(base)) }

var __imp_glLoadIdentity bindlib.PreloadProc

func LoadIdentity() { bindlib.CCall0(__imp_glLoadIdentity.Addr()) }

var __imp_glLoadMatrixd bindlib.PreloadProc

func LoadMatrixd(m *Double) { bindlib.CCall1(__imp_glLoadMatrixd.Addr(), bindlib.MarshallSyscall(m)) }

var __imp_glLoadMatrixf bindlib.PreloadProc

func LoadMatrixf(m *Float) { bindlib.CCall1(__imp_glLoadMatrixf.Addr(), bindlib.MarshallSyscall(m)) }

var __imp_glLoadName bindlib.PreloadProc

func LoadName(name Uint) { bindlib.CCall1(__imp_glLoadName.Addr(), bindlib.MarshallSyscall(name)) }

var __imp_glLogicOp bindlib.PreloadProc

func LogicOp(opcode Enum) { bindlib.CCall1(__imp_glLogicOp.Addr(), bindlib.MarshallSyscall(opcode)) }

var __imp_glMap1d bindlib.PreloadProc

func Map1d(target Enum, u1 Double, u2 Double, stride Int, order Int, points *Double) {
	bindlib.CCall6(__imp_glMap1d.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(u1), bindlib.MarshallSyscall(u2), bindlib.MarshallSyscall(stride), bindlib.MarshallSyscall(order), bindlib.MarshallSyscall(points))
}

var __imp_glMap1f bindlib.PreloadProc

func Map1f(target Enum, u1 Float, u2 Float, stride Int, order Int, points *Float) {
	bindlib.CCall6(__imp_glMap1f.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(u1), bindlib.MarshallSyscall(u2), bindlib.MarshallSyscall(stride), bindlib.MarshallSyscall(order), bindlib.MarshallSyscall(points))
}

var __imp_glMap2d bindlib.PreloadProc

func Map2d(target Enum, u1 Double, u2 Double, ustride Int, uorder Int, v1 Double, v2 Double, vstride Int, vorder Int, points *Double) {
	bindlib.CCall10(__imp_glMap2d.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(u1), bindlib.MarshallSyscall(u2), bindlib.MarshallSyscall(ustride), bindlib.MarshallSyscall(uorder), bindlib.MarshallSyscall(v1), bindlib.MarshallSyscall(v2), bindlib.MarshallSyscall(vstride), bindlib.MarshallSyscall(vorder), bindlib.MarshallSyscall(points))
}

var __imp_glMap2f bindlib.PreloadProc

func Map2f(target Enum, u1 Float, u2 Float, ustride Int, uorder Int, v1 Float, v2 Float, vstride Int, vorder Int, points *Float) {
	bindlib.CCall10(__imp_glMap2f.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(u1), bindlib.MarshallSyscall(u2), bindlib.MarshallSyscall(ustride), bindlib.MarshallSyscall(uorder), bindlib.MarshallSyscall(v1), bindlib.MarshallSyscall(v2), bindlib.MarshallSyscall(vstride), bindlib.MarshallSyscall(vorder), bindlib.MarshallSyscall(points))
}

var __imp_glMapGrid1d bindlib.PreloadProc

func MapGrid1d(un Int, u1 Double, u2 Double) {
	bindlib.CCall3(__imp_glMapGrid1d.Addr(), bindlib.MarshallSyscall(un), bindlib.MarshallSyscall(u1), bindlib.MarshallSyscall(u2))
}

var __imp_glMapGrid1f bindlib.PreloadProc

func MapGrid1f(un Int, u1 Float, u2 Float) {
	bindlib.CCall3(__imp_glMapGrid1f.Addr(), bindlib.MarshallSyscall(un), bindlib.MarshallSyscall(u1), bindlib.MarshallSyscall(u2))
}

var __imp_glMapGrid2d bindlib.PreloadProc

func MapGrid2d(un Int, u1 Double, u2 Double, vn Int, v1 Double, v2 Double) {
	bindlib.CCall6(__imp_glMapGrid2d.Addr(), bindlib.MarshallSyscall(un), bindlib.MarshallSyscall(u1), bindlib.MarshallSyscall(u2), bindlib.MarshallSyscall(vn), bindlib.MarshallSyscall(v1), bindlib.MarshallSyscall(v2))
}

var __imp_glMapGrid2f bindlib.PreloadProc

func MapGrid2f(un Int, u1 Float, u2 Float, vn Int, v1 Float, v2 Float) {
	bindlib.CCall6(__imp_glMapGrid2f.Addr(), bindlib.MarshallSyscall(un), bindlib.MarshallSyscall(u1), bindlib.MarshallSyscall(u2), bindlib.MarshallSyscall(vn), bindlib.MarshallSyscall(v1), bindlib.MarshallSyscall(v2))
}

var __imp_glMaterialf bindlib.PreloadProc

func Materialf(face Enum, pname Enum, param Float) {
	bindlib.CCall3(__imp_glMaterialf.Addr(), bindlib.MarshallSyscall(face), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glMaterialfv bindlib.PreloadProc

func Materialfv(face Enum, pname Enum, params *Float) {
	bindlib.CCall3(__imp_glMaterialfv.Addr(), bindlib.MarshallSyscall(face), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glMateriali bindlib.PreloadProc

func Materiali(face Enum, pname Enum, param Int) {
	bindlib.CCall3(__imp_glMateriali.Addr(), bindlib.MarshallSyscall(face), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glMaterialiv bindlib.PreloadProc

func Materialiv(face Enum, pname Enum, params *Int) {
	bindlib.CCall3(__imp_glMaterialiv.Addr(), bindlib.MarshallSyscall(face), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glMatrixMode bindlib.PreloadProc

func MatrixMode(mode Enum) { bindlib.CCall1(__imp_glMatrixMode.Addr(), bindlib.MarshallSyscall(mode)) }

var __imp_glMultMatrixd bindlib.PreloadProc

func MultMatrixd(m *Double) { bindlib.CCall1(__imp_glMultMatrixd.Addr(), bindlib.MarshallSyscall(m)) }

var __imp_glMultMatrixf bindlib.PreloadProc

func MultMatrixf(m *Float) { bindlib.CCall1(__imp_glMultMatrixf.Addr(), bindlib.MarshallSyscall(m)) }

var __imp_glNewList bindlib.PreloadProc

func NewList(list Uint, mode Enum) {
	bindlib.CCall2(__imp_glNewList.Addr(), bindlib.MarshallSyscall(list), bindlib.MarshallSyscall(mode))
}

var __imp_glNormal3b bindlib.PreloadProc

func Normal3b(nx Byte, ny Byte, nz Byte) {
	bindlib.CCall3(__imp_glNormal3b.Addr(), bindlib.MarshallSyscall(nx), bindlib.MarshallSyscall(ny), bindlib.MarshallSyscall(nz))
}

var __imp_glNormal3bv bindlib.PreloadProc

func Normal3bv(v *Byte) { bindlib.CCall1(__imp_glNormal3bv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glNormal3d bindlib.PreloadProc

func Normal3d(nx Double, ny Double, nz Double) {
	bindlib.CCall3(__imp_glNormal3d.Addr(), bindlib.MarshallSyscall(nx), bindlib.MarshallSyscall(ny), bindlib.MarshallSyscall(nz))
}

var __imp_glNormal3dv bindlib.PreloadProc

func Normal3dv(v *Double) { bindlib.CCall1(__imp_glNormal3dv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glNormal3f bindlib.PreloadProc

func Normal3f(nx Float, ny Float, nz Float) {
	bindlib.CCall3(__imp_glNormal3f.Addr(), bindlib.MarshallSyscall(nx), bindlib.MarshallSyscall(ny), bindlib.MarshallSyscall(nz))
}

var __imp_glNormal3fv bindlib.PreloadProc

func Normal3fv(v *Float) { bindlib.CCall1(__imp_glNormal3fv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glNormal3i bindlib.PreloadProc

func Normal3i(nx Int, ny Int, nz Int) {
	bindlib.CCall3(__imp_glNormal3i.Addr(), bindlib.MarshallSyscall(nx), bindlib.MarshallSyscall(ny), bindlib.MarshallSyscall(nz))
}

var __imp_glNormal3iv bindlib.PreloadProc

func Normal3iv(v *Int) { bindlib.CCall1(__imp_glNormal3iv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glNormal3s bindlib.PreloadProc

func Normal3s(nx Short, ny Short, nz Short) {
	bindlib.CCall3(__imp_glNormal3s.Addr(), bindlib.MarshallSyscall(nx), bindlib.MarshallSyscall(ny), bindlib.MarshallSyscall(nz))
}

var __imp_glNormal3sv bindlib.PreloadProc

func Normal3sv(v *Short) { bindlib.CCall1(__imp_glNormal3sv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glNormalPointer bindlib.PreloadProc

func NormalPointer(_type Enum, stride Sizei, pointer *Void) {
	bindlib.CCall3(__imp_glNormalPointer.Addr(), bindlib.MarshallSyscall(_type), bindlib.MarshallSyscall(stride), bindlib.MarshallSyscall(pointer))
}

var __imp_glOrtho bindlib.PreloadProc

func Ortho(left Double, right Double, bottom Double, top Double, zNear Double, zFar Double) {
	bindlib.CCall6(__imp_glOrtho.Addr(), bindlib.MarshallSyscall(left), bindlib.MarshallSyscall(right), bindlib.MarshallSyscall(bottom), bindlib.MarshallSyscall(top), bindlib.MarshallSyscall(zNear), bindlib.MarshallSyscall(zFar))
}

var __imp_glPassThrough bindlib.PreloadProc

func PassThrough(token Float) {
	bindlib.CCall1(__imp_glPassThrough.Addr(), bindlib.MarshallSyscall(token))
}

var __imp_glPixelMapfv bindlib.PreloadProc

func PixelMapfv(_map Enum, mapsize Sizei, values *Float) {
	bindlib.CCall3(__imp_glPixelMapfv.Addr(), bindlib.MarshallSyscall(_map), bindlib.MarshallSyscall(mapsize), bindlib.MarshallSyscall(values))
}

var __imp_glPixelMapuiv bindlib.PreloadProc

func PixelMapuiv(_map Enum, mapsize Sizei, values *Uint) {
	bindlib.CCall3(__imp_glPixelMapuiv.Addr(), bindlib.MarshallSyscall(_map), bindlib.MarshallSyscall(mapsize), bindlib.MarshallSyscall(values))
}

var __imp_glPixelMapusv bindlib.PreloadProc

func PixelMapusv(_map Enum, mapsize Sizei, values *Ushort) {
	bindlib.CCall3(__imp_glPixelMapusv.Addr(), bindlib.MarshallSyscall(_map), bindlib.MarshallSyscall(mapsize), bindlib.MarshallSyscall(values))
}

var __imp_glPixelStoref bindlib.PreloadProc

func PixelStoref(pname Enum, param Float) {
	bindlib.CCall2(__imp_glPixelStoref.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glPixelStorei bindlib.PreloadProc

func PixelStorei(pname Enum, param Int) {
	bindlib.CCall2(__imp_glPixelStorei.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glPixelTransferf bindlib.PreloadProc

func PixelTransferf(pname Enum, param Float) {
	bindlib.CCall2(__imp_glPixelTransferf.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glPixelTransferi bindlib.PreloadProc

func PixelTransferi(pname Enum, param Int) {
	bindlib.CCall2(__imp_glPixelTransferi.Addr(), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glPixelZoom bindlib.PreloadProc

func PixelZoom(xfactor Float, yfactor Float) {
	bindlib.CCall2(__imp_glPixelZoom.Addr(), bindlib.MarshallSyscall(xfactor), bindlib.MarshallSyscall(yfactor))
}

var __imp_glPointSize bindlib.PreloadProc

func PointSize(size Float) { bindlib.CCall1(__imp_glPointSize.Addr(), bindlib.MarshallSyscall(size)) }

var __imp_glPolygonMode bindlib.PreloadProc

func PolygonMode(face Enum, mode Enum) {
	bindlib.CCall2(__imp_glPolygonMode.Addr(), bindlib.MarshallSyscall(face), bindlib.MarshallSyscall(mode))
}

var __imp_glPolygonOffset bindlib.PreloadProc

func PolygonOffset(factor Float, units Float) {
	bindlib.CCall2(__imp_glPolygonOffset.Addr(), bindlib.MarshallSyscall(factor), bindlib.MarshallSyscall(units))
}

var __imp_glPolygonStipple bindlib.PreloadProc

func PolygonStipple(mask *Ubyte) {
	bindlib.CCall1(__imp_glPolygonStipple.Addr(), bindlib.MarshallSyscall(mask))
}

var __imp_glPopAttrib bindlib.PreloadProc

func PopAttrib() { bindlib.CCall0(__imp_glPopAttrib.Addr()) }

var __imp_glPopClientAttrib bindlib.PreloadProc

func PopClientAttrib() { bindlib.CCall0(__imp_glPopClientAttrib.Addr()) }

var __imp_glPopMatrix bindlib.PreloadProc

func PopMatrix() { bindlib.CCall0(__imp_glPopMatrix.Addr()) }

var __imp_glPopName bindlib.PreloadProc

func PopName() { bindlib.CCall0(__imp_glPopName.Addr()) }

var __imp_glPrioritizeTextures bindlib.PreloadProc

func PrioritizeTextures(n Sizei, textures *Uint, priorities *Clampf) {
	bindlib.CCall3(__imp_glPrioritizeTextures.Addr(), bindlib.MarshallSyscall(n), bindlib.MarshallSyscall(textures), bindlib.MarshallSyscall(priorities))
}

var __imp_glPushAttrib bindlib.PreloadProc

func PushAttrib(mask Bitfield) {
	bindlib.CCall1(__imp_glPushAttrib.Addr(), bindlib.MarshallSyscall(mask))
}

var __imp_glPushClientAttrib bindlib.PreloadProc

func PushClientAttrib(mask Bitfield) {
	bindlib.CCall1(__imp_glPushClientAttrib.Addr(), bindlib.MarshallSyscall(mask))
}

var __imp_glPushMatrix bindlib.PreloadProc

func PushMatrix() { bindlib.CCall0(__imp_glPushMatrix.Addr()) }

var __imp_glPushName bindlib.PreloadProc

func PushName(name Uint) { bindlib.CCall1(__imp_glPushName.Addr(), bindlib.MarshallSyscall(name)) }

var __imp_glRasterPos2d bindlib.PreloadProc

func RasterPos2d(x Double, y Double) {
	bindlib.CCall2(__imp_glRasterPos2d.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y))
}

var __imp_glRasterPos2dv bindlib.PreloadProc

func RasterPos2dv(v *Double) { bindlib.CCall1(__imp_glRasterPos2dv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glRasterPos2f bindlib.PreloadProc

func RasterPos2f(x Float, y Float) {
	bindlib.CCall2(__imp_glRasterPos2f.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y))
}

var __imp_glRasterPos2fv bindlib.PreloadProc

func RasterPos2fv(v *Float) { bindlib.CCall1(__imp_glRasterPos2fv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glRasterPos2i bindlib.PreloadProc

func RasterPos2i(x Int, y Int) {
	bindlib.CCall2(__imp_glRasterPos2i.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y))
}

var __imp_glRasterPos2iv bindlib.PreloadProc

func RasterPos2iv(v *Int) { bindlib.CCall1(__imp_glRasterPos2iv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glRasterPos2s bindlib.PreloadProc

func RasterPos2s(x Short, y Short) {
	bindlib.CCall2(__imp_glRasterPos2s.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y))
}

var __imp_glRasterPos2sv bindlib.PreloadProc

func RasterPos2sv(v *Short) { bindlib.CCall1(__imp_glRasterPos2sv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glRasterPos3d bindlib.PreloadProc

func RasterPos3d(x Double, y Double, z Double) {
	bindlib.CCall3(__imp_glRasterPos3d.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z))
}

var __imp_glRasterPos3dv bindlib.PreloadProc

func RasterPos3dv(v *Double) { bindlib.CCall1(__imp_glRasterPos3dv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glRasterPos3f bindlib.PreloadProc

func RasterPos3f(x Float, y Float, z Float) {
	bindlib.CCall3(__imp_glRasterPos3f.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z))
}

var __imp_glRasterPos3fv bindlib.PreloadProc

func RasterPos3fv(v *Float) { bindlib.CCall1(__imp_glRasterPos3fv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glRasterPos3i bindlib.PreloadProc

func RasterPos3i(x Int, y Int, z Int) {
	bindlib.CCall3(__imp_glRasterPos3i.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z))
}

var __imp_glRasterPos3iv bindlib.PreloadProc

func RasterPos3iv(v *Int) { bindlib.CCall1(__imp_glRasterPos3iv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glRasterPos3s bindlib.PreloadProc

func RasterPos3s(x Short, y Short, z Short) {
	bindlib.CCall3(__imp_glRasterPos3s.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z))
}

var __imp_glRasterPos3sv bindlib.PreloadProc

func RasterPos3sv(v *Short) { bindlib.CCall1(__imp_glRasterPos3sv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glRasterPos4d bindlib.PreloadProc

func RasterPos4d(x Double, y Double, z Double, w Double) {
	bindlib.CCall4(__imp_glRasterPos4d.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z), bindlib.MarshallSyscall(w))
}

var __imp_glRasterPos4dv bindlib.PreloadProc

func RasterPos4dv(v *Double) { bindlib.CCall1(__imp_glRasterPos4dv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glRasterPos4f bindlib.PreloadProc

func RasterPos4f(x Float, y Float, z Float, w Float) {
	bindlib.CCall4(__imp_glRasterPos4f.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z), bindlib.MarshallSyscall(w))
}

var __imp_glRasterPos4fv bindlib.PreloadProc

func RasterPos4fv(v *Float) { bindlib.CCall1(__imp_glRasterPos4fv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glRasterPos4i bindlib.PreloadProc

func RasterPos4i(x Int, y Int, z Int, w Int) {
	bindlib.CCall4(__imp_glRasterPos4i.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z), bindlib.MarshallSyscall(w))
}

var __imp_glRasterPos4iv bindlib.PreloadProc

func RasterPos4iv(v *Int) { bindlib.CCall1(__imp_glRasterPos4iv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glRasterPos4s bindlib.PreloadProc

func RasterPos4s(x Short, y Short, z Short, w Short) {
	bindlib.CCall4(__imp_glRasterPos4s.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z), bindlib.MarshallSyscall(w))
}

var __imp_glRasterPos4sv bindlib.PreloadProc

func RasterPos4sv(v *Short) { bindlib.CCall1(__imp_glRasterPos4sv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glReadBuffer bindlib.PreloadProc

func ReadBuffer(mode Enum) { bindlib.CCall1(__imp_glReadBuffer.Addr(), bindlib.MarshallSyscall(mode)) }

var __imp_glReadPixels bindlib.PreloadProc

func ReadPixels(x Int, y Int, width Sizei, height Sizei, format Enum, _type Enum, pixels *Void) {
	bindlib.CCall7(__imp_glReadPixels.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height), bindlib.MarshallSyscall(format), bindlib.MarshallSyscall(_type), bindlib.MarshallSyscall(pixels))
}

var __imp_glRectd bindlib.PreloadProc

func Rectd(x1 Double, y1 Double, x2 Double, y2 Double) {
	bindlib.CCall4(__imp_glRectd.Addr(), bindlib.MarshallSyscall(x1), bindlib.MarshallSyscall(y1), bindlib.MarshallSyscall(x2), bindlib.MarshallSyscall(y2))
}

var __imp_glRectdv bindlib.PreloadProc

func Rectdv(v1 *Double, v2 *Double) {
	bindlib.CCall2(__imp_glRectdv.Addr(), bindlib.MarshallSyscall(v1), bindlib.MarshallSyscall(v2))
}

var __imp_glRectf bindlib.PreloadProc

func Rectf(x1 Float, y1 Float, x2 Float, y2 Float) {
	bindlib.CCall4(__imp_glRectf.Addr(), bindlib.MarshallSyscall(x1), bindlib.MarshallSyscall(y1), bindlib.MarshallSyscall(x2), bindlib.MarshallSyscall(y2))
}

var __imp_glRectfv bindlib.PreloadProc

func Rectfv(v1 *Float, v2 *Float) {
	bindlib.CCall2(__imp_glRectfv.Addr(), bindlib.MarshallSyscall(v1), bindlib.MarshallSyscall(v2))
}

var __imp_glRecti bindlib.PreloadProc

func Recti(x1 Int, y1 Int, x2 Int, y2 Int) {
	bindlib.CCall4(__imp_glRecti.Addr(), bindlib.MarshallSyscall(x1), bindlib.MarshallSyscall(y1), bindlib.MarshallSyscall(x2), bindlib.MarshallSyscall(y2))
}

var __imp_glRectiv bindlib.PreloadProc

func Rectiv(v1 *Int, v2 *Int) {
	bindlib.CCall2(__imp_glRectiv.Addr(), bindlib.MarshallSyscall(v1), bindlib.MarshallSyscall(v2))
}

var __imp_glRects bindlib.PreloadProc

func Rects(x1 Short, y1 Short, x2 Short, y2 Short) {
	bindlib.CCall4(__imp_glRects.Addr(), bindlib.MarshallSyscall(x1), bindlib.MarshallSyscall(y1), bindlib.MarshallSyscall(x2), bindlib.MarshallSyscall(y2))
}

var __imp_glRectsv bindlib.PreloadProc

func Rectsv(v1 *Short, v2 *Short) {
	bindlib.CCall2(__imp_glRectsv.Addr(), bindlib.MarshallSyscall(v1), bindlib.MarshallSyscall(v2))
}

var __imp_glRenderMode bindlib.PreloadProc

func RenderMode(mode Enum) Int {
	__res := bindlib.CCall1(__imp_glRenderMode.Addr(), bindlib.MarshallSyscall(mode))
	return bindlib.UnmarshallSyscall[Int](__res)
}

var __imp_glRotated bindlib.PreloadProc

func Rotated(angle Double, x Double, y Double, z Double) {
	bindlib.CCall4(__imp_glRotated.Addr(), bindlib.MarshallSyscall(angle), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z))
}

var __imp_glRotatef bindlib.PreloadProc

func Rotatef(angle Float, x Float, y Float, z Float) {
	bindlib.CCall4(__imp_glRotatef.Addr(), bindlib.MarshallSyscall(angle), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z))
}

var __imp_glScaled bindlib.PreloadProc

func Scaled(x Double, y Double, z Double) {
	bindlib.CCall3(__imp_glScaled.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z))
}

var __imp_glScalef bindlib.PreloadProc

func Scalef(x Float, y Float, z Float) {
	bindlib.CCall3(__imp_glScalef.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z))
}

var __imp_glScissor bindlib.PreloadProc

func Scissor(x Int, y Int, width Sizei, height Sizei) {
	bindlib.CCall4(__imp_glScissor.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height))
}

var __imp_glSelectBuffer bindlib.PreloadProc

func SelectBuffer(size Sizei, buffer *Uint) {
	bindlib.CCall2(__imp_glSelectBuffer.Addr(), bindlib.MarshallSyscall(size), bindlib.MarshallSyscall(buffer))
}

var __imp_glShadeModel bindlib.PreloadProc

func ShadeModel(mode Enum) { bindlib.CCall1(__imp_glShadeModel.Addr(), bindlib.MarshallSyscall(mode)) }

var __imp_glStencilFunc bindlib.PreloadProc

func StencilFunc(_func Enum, ref Int, mask Uint) {
	bindlib.CCall3(__imp_glStencilFunc.Addr(), bindlib.MarshallSyscall(_func), bindlib.MarshallSyscall(ref), bindlib.MarshallSyscall(mask))
}

var __imp_glStencilMask bindlib.PreloadProc

func StencilMask(mask Uint) {
	bindlib.CCall1(__imp_glStencilMask.Addr(), bindlib.MarshallSyscall(mask))
}

var __imp_glStencilOp bindlib.PreloadProc

func StencilOp(fail Enum, zfail Enum, zpass Enum) {
	bindlib.CCall3(__imp_glStencilOp.Addr(), bindlib.MarshallSyscall(fail), bindlib.MarshallSyscall(zfail), bindlib.MarshallSyscall(zpass))
}

var __imp_glTexCoord1d bindlib.PreloadProc

func TexCoord1d(s Double) { bindlib.CCall1(__imp_glTexCoord1d.Addr(), bindlib.MarshallSyscall(s)) }

var __imp_glTexCoord1dv bindlib.PreloadProc

func TexCoord1dv(v *Double) { bindlib.CCall1(__imp_glTexCoord1dv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glTexCoord1f bindlib.PreloadProc

func TexCoord1f(s Float) { bindlib.CCall1(__imp_glTexCoord1f.Addr(), bindlib.MarshallSyscall(s)) }

var __imp_glTexCoord1fv bindlib.PreloadProc

func TexCoord1fv(v *Float) { bindlib.CCall1(__imp_glTexCoord1fv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glTexCoord1i bindlib.PreloadProc

func TexCoord1i(s Int) { bindlib.CCall1(__imp_glTexCoord1i.Addr(), bindlib.MarshallSyscall(s)) }

var __imp_glTexCoord1iv bindlib.PreloadProc

func TexCoord1iv(v *Int) { bindlib.CCall1(__imp_glTexCoord1iv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glTexCoord1s bindlib.PreloadProc

func TexCoord1s(s Short) { bindlib.CCall1(__imp_glTexCoord1s.Addr(), bindlib.MarshallSyscall(s)) }

var __imp_glTexCoord1sv bindlib.PreloadProc

func TexCoord1sv(v *Short) { bindlib.CCall1(__imp_glTexCoord1sv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glTexCoord2d bindlib.PreloadProc

func TexCoord2d(s Double, t Double) {
	bindlib.CCall2(__imp_glTexCoord2d.Addr(), bindlib.MarshallSyscall(s), bindlib.MarshallSyscall(t))
}

var __imp_glTexCoord2dv bindlib.PreloadProc

func TexCoord2dv(v *Double) { bindlib.CCall1(__imp_glTexCoord2dv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glTexCoord2f bindlib.PreloadProc

func TexCoord2f(s Float, t Float) {
	bindlib.CCall2(__imp_glTexCoord2f.Addr(), bindlib.MarshallSyscall(s), bindlib.MarshallSyscall(t))
}

var __imp_glTexCoord2fv bindlib.PreloadProc

func TexCoord2fv(v *Float) { bindlib.CCall1(__imp_glTexCoord2fv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glTexCoord2i bindlib.PreloadProc

func TexCoord2i(s Int, t Int) {
	bindlib.CCall2(__imp_glTexCoord2i.Addr(), bindlib.MarshallSyscall(s), bindlib.MarshallSyscall(t))
}

var __imp_glTexCoord2iv bindlib.PreloadProc

func TexCoord2iv(v *Int) { bindlib.CCall1(__imp_glTexCoord2iv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glTexCoord2s bindlib.PreloadProc

func TexCoord2s(s Short, t Short) {
	bindlib.CCall2(__imp_glTexCoord2s.Addr(), bindlib.MarshallSyscall(s), bindlib.MarshallSyscall(t))
}

var __imp_glTexCoord2sv bindlib.PreloadProc

func TexCoord2sv(v *Short) { bindlib.CCall1(__imp_glTexCoord2sv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glTexCoord3d bindlib.PreloadProc

func TexCoord3d(s Double, t Double, r Double) {
	bindlib.CCall3(__imp_glTexCoord3d.Addr(), bindlib.MarshallSyscall(s), bindlib.MarshallSyscall(t), bindlib.MarshallSyscall(r))
}

var __imp_glTexCoord3dv bindlib.PreloadProc

func TexCoord3dv(v *Double) { bindlib.CCall1(__imp_glTexCoord3dv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glTexCoord3f bindlib.PreloadProc

func TexCoord3f(s Float, t Float, r Float) {
	bindlib.CCall3(__imp_glTexCoord3f.Addr(), bindlib.MarshallSyscall(s), bindlib.MarshallSyscall(t), bindlib.MarshallSyscall(r))
}

var __imp_glTexCoord3fv bindlib.PreloadProc

func TexCoord3fv(v *Float) { bindlib.CCall1(__imp_glTexCoord3fv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glTexCoord3i bindlib.PreloadProc

func TexCoord3i(s Int, t Int, r Int) {
	bindlib.CCall3(__imp_glTexCoord3i.Addr(), bindlib.MarshallSyscall(s), bindlib.MarshallSyscall(t), bindlib.MarshallSyscall(r))
}

var __imp_glTexCoord3iv bindlib.PreloadProc

func TexCoord3iv(v *Int) { bindlib.CCall1(__imp_glTexCoord3iv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glTexCoord3s bindlib.PreloadProc

func TexCoord3s(s Short, t Short, r Short) {
	bindlib.CCall3(__imp_glTexCoord3s.Addr(), bindlib.MarshallSyscall(s), bindlib.MarshallSyscall(t), bindlib.MarshallSyscall(r))
}

var __imp_glTexCoord3sv bindlib.PreloadProc

func TexCoord3sv(v *Short) { bindlib.CCall1(__imp_glTexCoord3sv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glTexCoord4d bindlib.PreloadProc

func TexCoord4d(s Double, t Double, r Double, q Double) {
	bindlib.CCall4(__imp_glTexCoord4d.Addr(), bindlib.MarshallSyscall(s), bindlib.MarshallSyscall(t), bindlib.MarshallSyscall(r), bindlib.MarshallSyscall(q))
}

var __imp_glTexCoord4dv bindlib.PreloadProc

func TexCoord4dv(v *Double) { bindlib.CCall1(__imp_glTexCoord4dv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glTexCoord4f bindlib.PreloadProc

func TexCoord4f(s Float, t Float, r Float, q Float) {
	bindlib.CCall4(__imp_glTexCoord4f.Addr(), bindlib.MarshallSyscall(s), bindlib.MarshallSyscall(t), bindlib.MarshallSyscall(r), bindlib.MarshallSyscall(q))
}

var __imp_glTexCoord4fv bindlib.PreloadProc

func TexCoord4fv(v *Float) { bindlib.CCall1(__imp_glTexCoord4fv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glTexCoord4i bindlib.PreloadProc

func TexCoord4i(s Int, t Int, r Int, q Int) {
	bindlib.CCall4(__imp_glTexCoord4i.Addr(), bindlib.MarshallSyscall(s), bindlib.MarshallSyscall(t), bindlib.MarshallSyscall(r), bindlib.MarshallSyscall(q))
}

var __imp_glTexCoord4iv bindlib.PreloadProc

func TexCoord4iv(v *Int) { bindlib.CCall1(__imp_glTexCoord4iv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glTexCoord4s bindlib.PreloadProc

func TexCoord4s(s Short, t Short, r Short, q Short) {
	bindlib.CCall4(__imp_glTexCoord4s.Addr(), bindlib.MarshallSyscall(s), bindlib.MarshallSyscall(t), bindlib.MarshallSyscall(r), bindlib.MarshallSyscall(q))
}

var __imp_glTexCoord4sv bindlib.PreloadProc

func TexCoord4sv(v *Short) { bindlib.CCall1(__imp_glTexCoord4sv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glTexCoordPointer bindlib.PreloadProc

func TexCoordPointer(size Int, _type Enum, stride Sizei, pointer *Void) {
	bindlib.CCall4(__imp_glTexCoordPointer.Addr(), bindlib.MarshallSyscall(size), bindlib.MarshallSyscall(_type), bindlib.MarshallSyscall(stride), bindlib.MarshallSyscall(pointer))
}

var __imp_glTexEnvf bindlib.PreloadProc

func TexEnvf(target Enum, pname Enum, param Float) {
	bindlib.CCall3(__imp_glTexEnvf.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glTexEnvfv bindlib.PreloadProc

func TexEnvfv(target Enum, pname Enum, params *Float) {
	bindlib.CCall3(__imp_glTexEnvfv.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glTexEnvi bindlib.PreloadProc

func TexEnvi(target Enum, pname Enum, param Int) {
	bindlib.CCall3(__imp_glTexEnvi.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glTexEnviv bindlib.PreloadProc

func TexEnviv(target Enum, pname Enum, params *Int) {
	bindlib.CCall3(__imp_glTexEnviv.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glTexGend bindlib.PreloadProc

func TexGend(coord Enum, pname Enum, param Double) {
	bindlib.CCall3(__imp_glTexGend.Addr(), bindlib.MarshallSyscall(coord), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glTexGendv bindlib.PreloadProc

func TexGendv(coord Enum, pname Enum, params *Double) {
	bindlib.CCall3(__imp_glTexGendv.Addr(), bindlib.MarshallSyscall(coord), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glTexGenf bindlib.PreloadProc

func TexGenf(coord Enum, pname Enum, param Float) {
	bindlib.CCall3(__imp_glTexGenf.Addr(), bindlib.MarshallSyscall(coord), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glTexGenfv bindlib.PreloadProc

func TexGenfv(coord Enum, pname Enum, params *Float) {
	bindlib.CCall3(__imp_glTexGenfv.Addr(), bindlib.MarshallSyscall(coord), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glTexGeni bindlib.PreloadProc

func TexGeni(coord Enum, pname Enum, param Int) {
	bindlib.CCall3(__imp_glTexGeni.Addr(), bindlib.MarshallSyscall(coord), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glTexGeniv bindlib.PreloadProc

func TexGeniv(coord Enum, pname Enum, params *Int) {
	bindlib.CCall3(__imp_glTexGeniv.Addr(), bindlib.MarshallSyscall(coord), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glTexImage1D bindlib.PreloadProc

func TexImage1D(target Enum, level Int, internalformat Int, width Sizei, border Int, format Enum, _type Enum, pixels *Void) {
	bindlib.CCall8(__imp_glTexImage1D.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(level), bindlib.MarshallSyscall(internalformat), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(border), bindlib.MarshallSyscall(format), bindlib.MarshallSyscall(_type), bindlib.MarshallSyscall(pixels))
}

var __imp_glTexImage2D bindlib.PreloadProc

func TexImage2D(target Enum, level Int, internalformat Int, width Sizei, height Sizei, border Int, format Enum, _type Enum, pixels *Void) {
	bindlib.CCall9(__imp_glTexImage2D.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(level), bindlib.MarshallSyscall(internalformat), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height), bindlib.MarshallSyscall(border), bindlib.MarshallSyscall(format), bindlib.MarshallSyscall(_type), bindlib.MarshallSyscall(pixels))
}

var __imp_glTexParameterf bindlib.PreloadProc

func TexParameterf(target Enum, pname Enum, param Float) {
	bindlib.CCall3(__imp_glTexParameterf.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glTexParameterfv bindlib.PreloadProc

func TexParameterfv(target Enum, pname Enum, params *Float) {
	bindlib.CCall3(__imp_glTexParameterfv.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glTexParameteri bindlib.PreloadProc

func TexParameteri(target Enum, pname Enum, param Int) {
	bindlib.CCall3(__imp_glTexParameteri.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(param))
}

var __imp_glTexParameteriv bindlib.PreloadProc

func TexParameteriv(target Enum, pname Enum, params *Int) {
	bindlib.CCall3(__imp_glTexParameteriv.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(pname), bindlib.MarshallSyscall(params))
}

var __imp_glTexSubImage1D bindlib.PreloadProc

func TexSubImage1D(target Enum, level Int, xoffset Int, width Sizei, format Enum, _type Enum, pixels *Void) {
	bindlib.CCall7(__imp_glTexSubImage1D.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(level), bindlib.MarshallSyscall(xoffset), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(format), bindlib.MarshallSyscall(_type), bindlib.MarshallSyscall(pixels))
}

var __imp_glTexSubImage2D bindlib.PreloadProc

func TexSubImage2D(target Enum, level Int, xoffset Int, yoffset Int, width Sizei, height Sizei, format Enum, _type Enum, pixels *Void) {
	bindlib.CCall9(__imp_glTexSubImage2D.Addr(), bindlib.MarshallSyscall(target), bindlib.MarshallSyscall(level), bindlib.MarshallSyscall(xoffset), bindlib.MarshallSyscall(yoffset), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height), bindlib.MarshallSyscall(format), bindlib.MarshallSyscall(_type), bindlib.MarshallSyscall(pixels))
}

var __imp_glTranslated bindlib.PreloadProc

func Translated(x Double, y Double, z Double) {
	bindlib.CCall3(__imp_glTranslated.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z))
}

var __imp_glTranslatef bindlib.PreloadProc

func Translatef(x Float, y Float, z Float) {
	bindlib.CCall3(__imp_glTranslatef.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z))
}

var __imp_glVertex2d bindlib.PreloadProc

func Vertex2d(x Double, y Double) {
	bindlib.CCall2(__imp_glVertex2d.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y))
}

var __imp_glVertex2dv bindlib.PreloadProc

func Vertex2dv(v *Double) { bindlib.CCall1(__imp_glVertex2dv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glVertex2f bindlib.PreloadProc

func Vertex2f(x Float, y Float) {
	bindlib.CCall2(__imp_glVertex2f.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y))
}

var __imp_glVertex2fv bindlib.PreloadProc

func Vertex2fv(v *Float) { bindlib.CCall1(__imp_glVertex2fv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glVertex2i bindlib.PreloadProc

func Vertex2i(x Int, y Int) {
	bindlib.CCall2(__imp_glVertex2i.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y))
}

var __imp_glVertex2iv bindlib.PreloadProc

func Vertex2iv(v *Int) { bindlib.CCall1(__imp_glVertex2iv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glVertex2s bindlib.PreloadProc

func Vertex2s(x Short, y Short) {
	bindlib.CCall2(__imp_glVertex2s.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y))
}

var __imp_glVertex2sv bindlib.PreloadProc

func Vertex2sv(v *Short) { bindlib.CCall1(__imp_glVertex2sv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glVertex3d bindlib.PreloadProc

func Vertex3d(x Double, y Double, z Double) {
	bindlib.CCall3(__imp_glVertex3d.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z))
}

var __imp_glVertex3dv bindlib.PreloadProc

func Vertex3dv(v *Double) { bindlib.CCall1(__imp_glVertex3dv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glVertex3f bindlib.PreloadProc

func Vertex3f(x Float, y Float, z Float) {
	bindlib.CCall3(__imp_glVertex3f.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z))
}

var __imp_glVertex3fv bindlib.PreloadProc

func Vertex3fv(v *Float) { bindlib.CCall1(__imp_glVertex3fv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glVertex3i bindlib.PreloadProc

func Vertex3i(x Int, y Int, z Int) {
	bindlib.CCall3(__imp_glVertex3i.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z))
}

var __imp_glVertex3iv bindlib.PreloadProc

func Vertex3iv(v *Int) { bindlib.CCall1(__imp_glVertex3iv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glVertex3s bindlib.PreloadProc

func Vertex3s(x Short, y Short, z Short) {
	bindlib.CCall3(__imp_glVertex3s.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z))
}

var __imp_glVertex3sv bindlib.PreloadProc

func Vertex3sv(v *Short) { bindlib.CCall1(__imp_glVertex3sv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glVertex4d bindlib.PreloadProc

func Vertex4d(x Double, y Double, z Double, w Double) {
	bindlib.CCall4(__imp_glVertex4d.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z), bindlib.MarshallSyscall(w))
}

var __imp_glVertex4dv bindlib.PreloadProc

func Vertex4dv(v *Double) { bindlib.CCall1(__imp_glVertex4dv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glVertex4f bindlib.PreloadProc

func Vertex4f(x Float, y Float, z Float, w Float) {
	bindlib.CCall4(__imp_glVertex4f.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z), bindlib.MarshallSyscall(w))
}

var __imp_glVertex4fv bindlib.PreloadProc

func Vertex4fv(v *Float) { bindlib.CCall1(__imp_glVertex4fv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glVertex4i bindlib.PreloadProc

func Vertex4i(x Int, y Int, z Int, w Int) {
	bindlib.CCall4(__imp_glVertex4i.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z), bindlib.MarshallSyscall(w))
}

var __imp_glVertex4iv bindlib.PreloadProc

func Vertex4iv(v *Int) { bindlib.CCall1(__imp_glVertex4iv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glVertex4s bindlib.PreloadProc

func Vertex4s(x Short, y Short, z Short, w Short) {
	bindlib.CCall4(__imp_glVertex4s.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(z), bindlib.MarshallSyscall(w))
}

var __imp_glVertex4sv bindlib.PreloadProc

func Vertex4sv(v *Short) { bindlib.CCall1(__imp_glVertex4sv.Addr(), bindlib.MarshallSyscall(v)) }

var __imp_glVertexPointer bindlib.PreloadProc

func VertexPointer(size Int, _type Enum, stride Sizei, pointer *Void) {
	bindlib.CCall4(__imp_glVertexPointer.Addr(), bindlib.MarshallSyscall(size), bindlib.MarshallSyscall(_type), bindlib.MarshallSyscall(stride), bindlib.MarshallSyscall(pointer))
}

var __imp_glViewport bindlib.PreloadProc

func Viewport(x Int, y Int, width Sizei, height Sizei) {
	bindlib.CCall4(__imp_glViewport.Addr(), bindlib.MarshallSyscall(x), bindlib.MarshallSyscall(y), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height))
}

var __imp_glfwInit bindlib.PreloadProc

// @brief Initializes the GLFW library.
// This function initializes the GLFW library.  Before most GLFW functions can
// be used, GLFW must be initialized, and before an application terminates GLFW
// should be terminated in order to free any resources allocated during or
// after initialization.
// If this function fails, it calls
// @ref glfwTerminate
// before returning.  If it
// succeeds, you should call
// @ref glfwTerminate
// before the application exits.
// Additional calls to this function after successful initialization but before
// termination will return `GLFW_TRUE` immediately.
// The
// @ref GLFW_PLATFORM
// init hint controls which platforms are considered during
// initialization.  This also depends on which platforms the library was compiled to
// support.
//
// @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_PLATFORM_UNAVAILABLE
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @macos
// This function will change the current directory of the
// application to the `Contents/Resources` subdirectory of the application's
// bundle, if present.  This can be disabled with the
// @ref GLFW_COCOA_CHDIR_RESOURCES
// init hint.
//
// @remark
// @macos
// This function will create the main menu and dock icon for the
// application.  If GLFW finds a `MainMenu.nib` it is loaded and assumed to
// contain a menu bar.  Otherwise a minimal menu bar is created manually with
// common commands like Hide, Quit and About.  The About entry opens a minimal
// about dialog with information from the application's bundle.  The menu bar
// and dock icon can be disabled entirely with the
// @ref GLFW_COCOA_MENUBAR
// init
// hint.
//
// @remark __Wayland, X11:__ If the library was compiled with support for both
// Wayland and X11, and the
// @ref GLFW_PLATFORM
// init hint is set to
// `GLFW_ANY_PLATFORM`, the `XDG_SESSION_TYPE` environment variable affects
// which platform is picked.  If the environment variable is not set, or is set
// to something other than `wayland` or `x11`, the regular detection mechanism
// will be used instead.
//
// @remark
// @x11
// This function will set the `LC_CTYPE` category of the
// application locale according to the current environment if that category is
// still "C".  This is because the "C" locale breaks Unicode text input.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref intro_init
//
// @sa
// @ref glfwInitHint
//
// @sa
// @ref glfwInitAllocator
//
// @sa
// @ref glfwTerminate
//
// @since Added in version 1.0.
func Init() int32 {
	__res := bindlib.CCall0(__imp_glfwInit.Addr())
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwTerminate bindlib.PreloadProc

// @brief Terminates the GLFW library.
// This function destroys all remaining windows and cursors, restores any
// modified gamma ramps and frees any other allocated resources.  Once this
// function is called, you must again call
// @ref glfwInit
// successfully before
// you will be able to use most GLFW functions.
// If GLFW has been successfully initialized, this function should be called
// before the application exits.  If initialization fails, there is no need to
// call this function, as it is called by
// @ref glfwInit
// before it returns
// failure.
// This function has no effect if GLFW is not initialized.
//
// @errors
// Possible errors include
// @ref GLFW_PLATFORM_ERROR.
//
// @remark This function may be called before
// @ref glfwInit.
//
// @warning The contexts of any remaining windows must not be current on any
// other thread when this function is called.
//
// @reentrancy
// This function must not be called from a callback.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref intro_init
//
// @sa
// @ref glfwInit
//
// @since Added in version 1.0.
func Terminate() { bindlib.CCall0(__imp_glfwTerminate.Addr()) }

var __imp_glfwInitHint bindlib.PreloadProc

// @brief Sets the specified init hint to the desired value.
// This function sets hints for the next initialization of GLFW.
// The values you set hints to are never reset by GLFW, but they only take
// effect during initialization.  Once GLFW has been initialized, any values
// you set will be ignored until the library is terminated and initialized
// again.
// Some hints are platform specific.  These may be set on any platform but they
// will only affect their specific platform.  Other platforms will ignore them.
// Setting these hints requires no platform specific headers or functions.
//
// @param hint The [init hint](
// @ref init_hints)
// to set.
//
// @param value The new value of the init hint.
//
// @errors
// Possible errors include
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_INVALID_VALUE.
//
// @remarks This function may be called before
// @ref glfwInit.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa init_hints
//
// @sa glfwInit
//
// @since Added in version 3.3.
func InitHint(hint int32, value int32) {
	bindlib.CCall2(__imp_glfwInitHint.Addr(), bindlib.MarshallSyscall(hint), bindlib.MarshallSyscall(value))
}

var __imp_glfwInitAllocator bindlib.PreloadProc

// @brief Sets the init allocator to the desired value.
// To use the default allocator, call this function with a `NULL` argument.
// If you specify an allocator struct, every member must be a valid function
// pointer.  If any member is `NULL`, this function will emit
// @ref GLFW_INVALID_VALUE
// and the init allocator will be unchanged.
// The functions in the allocator must fulfil a number of requirements.  See the
// documentation for
// @ref GLFWallocatefun,
//
// @ref GLFWreallocatefun
// and
// @ref GLFWdeallocatefun
// for details.
//
// @param allocator The allocator to use at the next initialization, or
// `NULL` to use the default one.
//
// @errors
// Possible errors include
// @ref GLFW_INVALID_VALUE.
//
// @pointer
// _lifetime The specified allocator is copied before this function
// returns.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref init_allocator
//
// @sa
// @ref glfwInit
//
// @since Added in version 3.4.
func InitAllocator(allocator unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwInitAllocator.Addr(), bindlib.MarshallSyscall(allocator))
}

var __imp_glfwGetVersion bindlib.PreloadProc

// @brief Retrieves the version of the GLFW library.
// This function retrieves the major, minor and revision numbers of the GLFW
// library.  It is intended for when you are using GLFW as a shared library and
// want to ensure that you are using the minimum required version.
// Any or all of the version arguments may be `NULL`.
//
// @param major Where to store the major version number, or `NULL`.
//
// @param minor Where to store the minor version number, or `NULL`.
//
// @param rev Where to store the revision number, or `NULL`.
//
// @errors
// None.
//
// @remark This function may be called before
// @ref glfwInit.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref intro_version
//
// @sa
// @ref glfwGetVersionString
//
// @since Added in version 1.0.
func GetVersion(major *int32, minor *int32, rev *int32) {
	bindlib.CCall3(__imp_glfwGetVersion.Addr(), bindlib.MarshallSyscall(major), bindlib.MarshallSyscall(minor), bindlib.MarshallSyscall(rev))
}

var __imp_glfwGetVersionString bindlib.PreloadProc

// @brief Returns a string describing the compile-time configuration.
// This function returns the compile-time generated
// [version string](
// @ref intro_version_string)
// of the GLFW library binary.  It describes
// the version, platforms, compiler and any platform or operating system specific
// compile-time options.  It should not be confused with the OpenGL or OpenGL ES version
// string, queried with `glGetString`.
// __Do not use the version string__ to parse the GLFW library version.  The
//
// @ref glfwGetVersion
// function provides the version of the running library
// binary in numerical format.
// __Do not use the version string__ to parse what platforms are supported.  The
// @ref glfwPlatformSupported
// function lets you query platform support.
//
// @return The ASCII encoded GLFW version string.
//
// @errors
// None.
//
// @remark This function may be called before
// @ref glfwInit.
//
// @pointer
// _lifetime The returned string is static and compile-time generated.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref intro_version
//
// @sa
// @ref glfwGetVersion
//
// @since Added in version 3.0.
func GetVersionString() *byte {
	__res := bindlib.CCall0(__imp_glfwGetVersionString.Addr())
	return bindlib.UnmarshallSyscall[*byte](__res)
}

var __imp_glfwGetError bindlib.PreloadProc

// @brief Returns and clears the last error for the calling thread.
// This function returns and clears the [error code](
// @ref errors)
// of the last
// error that occurred on the calling thread, and optionally a UTF-8 encoded
// human-readable description of it.  If no error has occurred since the last
// call, it returns
// @ref GLFW_NO_ERROR
// (zero) and the description pointer is
// set to `NULL`.
//
// @param description Where to store the error description pointer, or `NULL`.
//
// @return The last error code for the calling thread, or
// @ref GLFW_NO_ERROR
// (zero).
//
// @errors
// None.
//
// @pointer
// _lifetime The returned string is allocated and freed by GLFW.  You
// should not free it yourself.  It is guaranteed to be valid only until the
// next error occurs or the library is terminated.
//
// @remark This function may be called before
// @ref glfwInit.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref error_handling
//
// @sa
// @ref glfwSetErrorCallback
//
// @since Added in version 3.3.
func GetError(description **byte) int32 {
	__res := bindlib.CCall1(__imp_glfwGetError.Addr(), bindlib.MarshallSyscall(description))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwSetErrorCallback bindlib.PreloadProc

// @brief Sets the error callback.
// This function sets the error callback, which is called with an error code
// and a human-readable description each time a GLFW error occurs.
// The error code is set before the callback is called.  Calling
// @ref glfwGetError
// from the error callback will return the same value as the error
// code argument.
// The error callback is called on the thread where the error occurred.  If you
// are using GLFW from multiple threads, your error callback needs to be
// written accordingly.
// Because the description string may have been generated specifically for that
// error, it is not guaranteed to be valid after the callback has returned.  If
// you wish to use it after the callback returns, you need to make a copy.
// Once set, the error callback remains set even after the library has been
// terminated.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set.
//
// For more information about the callback parameters, see the
// [callback pointer type](
// @ref GLFWerrorfun).
//
// @errors
// None.
//
// @remark This function may be called before
// @ref glfwInit.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref error_handling
//
// @sa
// @ref glfwGetError
//
// @since Added in version 3.0.
func SetErrorCallback(callback Errorfun) Errorfun {
	__res := bindlib.CCall1(__imp_glfwSetErrorCallback.Addr(), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Errorfun](__res)
}

var __imp_glfwGetPlatform bindlib.PreloadProc

// @brief Returns the currently selected platform.
// This function returns the platform that was selected during initialization.  The
// returned value will be one of `GLFW_PLATFORM_WIN32`, `GLFW_PLATFORM_COCOA`,
// `GLFW_PLATFORM_WAYLAND`, `GLFW_PLATFORM_X11` or `GLFW_PLATFORM_NULL`.
//
// @return The currently selected platform, or zero if an error occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref platform
//
// @sa
// @ref glfwPlatformSupported
//
// @since Added in version 3.4.
func GetPlatform() int32 {
	__res := bindlib.CCall0(__imp_glfwGetPlatform.Addr())
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwPlatformSupported bindlib.PreloadProc

// @brief Returns whether the library includes support for the specified platform.
// This function returns whether the library was compiled with support for the specified
// platform.  The platform must be one of `GLFW_PLATFORM_WIN32`, `GLFW_PLATFORM_COCOA`,
// `GLFW_PLATFORM_WAYLAND`, `GLFW_PLATFORM_X11` or `GLFW_PLATFORM_NULL`.
//
// @param platform The platform to query.
//
// @return `GLFW_TRUE` if the platform is supported, or `GLFW_FALSE` otherwise.
//
// @errors
// Possible errors include
// @ref GLFW_INVALID_ENUM.
//
// @remark This function may be called before
// @ref glfwInit.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref platform
//
// @sa
// @ref glfwGetPlatform
//
// @since Added in version 3.4.
func PlatformSupported(platform int32) int32 {
	__res := bindlib.CCall1(__imp_glfwPlatformSupported.Addr(), bindlib.MarshallSyscall(platform))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetMonitors bindlib.PreloadProc

// @brief Returns the currently connected monitors.
// This function returns an array of handles for all currently connected
// monitors.  The primary monitor is always first in the returned array.  If no
// monitors were found, this function returns `NULL`.
//
// @param count Where to store the number of monitors in the returned
// array.  This is set to zero if an error occurred.
//
// @return An array of monitor handles, or `NULL` if no monitors were found or
// if an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @pointer
// _lifetime The returned array is allocated and freed by GLFW.  You
// should not free it yourself.  It is guaranteed to be valid only until the
// monitor configuration changes or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_monitors
//
// @sa
// @ref monitor_event
//
// @sa
// @ref glfwGetPrimaryMonitor
//
// @since Added in version 3.0.
func GetMonitors(count *int32) *unsafe.Pointer {
	__res := bindlib.CCall1(__imp_glfwGetMonitors.Addr(), bindlib.MarshallSyscall(count))
	return bindlib.UnmarshallSyscall[*unsafe.Pointer](__res)
}

var __imp_glfwGetPrimaryMonitor bindlib.PreloadProc

// @brief Returns the primary monitor.
// This function returns the primary monitor.  This is usually the monitor
// where elements like the task bar or global menu bar are located.
//
// @return The primary monitor, or `NULL` if no monitors were found or if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @remark The primary monitor is always first in the array returned by
// @ref glfwGetMonitors.
//
// @sa
// @ref monitor_monitors
//
// @sa
// @ref glfwGetMonitors
//
// @since Added in version 3.0.
func GetPrimaryMonitor() unsafe.Pointer {
	__res := bindlib.CCall0(__imp_glfwGetPrimaryMonitor.Addr())
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwGetMonitorPos bindlib.PreloadProc

// @brief Returns the position of the monitor's viewport on the virtual screen.
// This function returns the position, in screen coordinates, of the upper-left
// corner of the specified monitor.
// Any or all of the position arguments may be `NULL`.  If an error occurs, all
// non-`NULL` position arguments will be set to zero.
//
// @param monitor The monitor to query.
//
// @param xpos Where to store the monitor x-coordinate, or `NULL`.
//
// @param ypos Where to store the monitor y-coordinate, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_properties
//
// @since Added in version 3.0.
func GetMonitorPos(monitor unsafe.Pointer, xpos *int32, ypos *int32) {
	bindlib.CCall3(__imp_glfwGetMonitorPos.Addr(), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(xpos), bindlib.MarshallSyscall(ypos))
}

var __imp_glfwGetMonitorWorkarea bindlib.PreloadProc

// @brief Retrieves the work area of the monitor.
// This function returns the position, in screen coordinates, of the upper-left
// corner of the work area of the specified monitor along with the work area
// size in screen coordinates. The work area is defined as the area of the
// monitor not occluded by the window system task bar where present. If no
// task bar exists then the work area is the monitor resolution in screen
// coordinates.
// Any or all of the position and size arguments may be `NULL`.  If an error
// occurs, all non-`NULL` position and size arguments will be set to zero.
//
// @param monitor The monitor to query.
//
// @param xpos Where to store the monitor x-coordinate, or `NULL`.
//
// @param ypos Where to store the monitor y-coordinate, or `NULL`.
//
// @param width Where to store the monitor width, or `NULL`.
//
// @param height Where to store the monitor height, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_workarea
//
// @since Added in version 3.3.
func GetMonitorWorkarea(monitor unsafe.Pointer, xpos *int32, ypos *int32, width *int32, height *int32) {
	bindlib.CCall5(__imp_glfwGetMonitorWorkarea.Addr(), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(xpos), bindlib.MarshallSyscall(ypos), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height))
}

var __imp_glfwGetMonitorPhysicalSize bindlib.PreloadProc

// @brief Returns the physical size of the monitor.
// This function returns the size, in millimetres, of the display area of the
// specified monitor.
// Some platforms do not provide accurate monitor size information, either
// because the monitor [EDID][] data is incorrect or because the driver does
// not report it accurately.
// [EDID]: https://en.wikipedia.org/wiki/Extended_display_identification_data
// Any or all of the size arguments may be `NULL`.  If an error occurs, all
// non-`NULL` size arguments will be set to zero.
//
// @param monitor The monitor to query.
//
// @param widthMM Where to store the width, in millimetres, of the
// monitor's display area, or `NULL`.
//
// @param heightMM Where to store the height, in millimetres, of the
// monitor's display area, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @remark
// @win32
// On Windows 8 and earlier the physical size is calculated from
// the current resolution and system DPI instead of querying the monitor EDID data.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_properties
//
// @since Added in version 3.0.
func GetMonitorPhysicalSize(monitor unsafe.Pointer, widthMM *int32, heightMM *int32) {
	bindlib.CCall3(__imp_glfwGetMonitorPhysicalSize.Addr(), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(widthMM), bindlib.MarshallSyscall(heightMM))
}

var __imp_glfwGetMonitorContentScale bindlib.PreloadProc

// @brief Retrieves the content scale for the specified monitor.
// This function retrieves the content scale for the specified monitor.  The
// content scale is the ratio between the current DPI and the platform's
// default DPI.  This is especially important for text and any UI elements.  If
// the pixel dimensions of your UI scaled by this look appropriate on your
// machine then it should appear at a reasonable size on other machines
// regardless of their DPI and scaling settings.  This relies on the system DPI
// and scaling settings being somewhat correct.
// The content scale may depend on both the monitor resolution and pixel
// density and on user settings.  It may be very different from the raw DPI
// calculated from the physical size and current resolution.
//
// @param monitor The monitor to query.
//
// @param xscale Where to store the x-axis content scale, or `NULL`.
//
// @param yscale Where to store the y-axis content scale, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @wayland
// Fractional scaling information is not yet available for
// monitors, so this function only returns integer content scales.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_scale
//
// @sa
// @ref glfwGetWindowContentScale
//
// @since Added in version 3.3.
func GetMonitorContentScale(monitor unsafe.Pointer, xscale *float32, yscale *float32) {
	bindlib.CCall3(__imp_glfwGetMonitorContentScale.Addr(), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(xscale), bindlib.MarshallSyscall(yscale))
}

var __imp_glfwGetMonitorName bindlib.PreloadProc

// @brief Returns the name of the specified monitor.
// This function returns a human-readable name, encoded as UTF-8, of the
// specified monitor.  The name typically reflects the make and model of the
// monitor and is not guaranteed to be unique among the connected monitors.
//
// @param monitor The monitor to query.
//
// @return The UTF-8 encoded name of the monitor, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @pointer
// _lifetime The returned string is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified monitor is
// disconnected or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_properties
//
// @since Added in version 3.0.
func GetMonitorName(monitor unsafe.Pointer) *byte {
	__res := bindlib.CCall1(__imp_glfwGetMonitorName.Addr(), bindlib.MarshallSyscall(monitor))
	return bindlib.UnmarshallSyscall[*byte](__res)
}

var __imp_glfwSetMonitorUserPointer bindlib.PreloadProc

// @brief Sets the user pointer of the specified monitor.
// This function sets the user-defined pointer of the specified monitor.  The
// current value is retained until the monitor is disconnected.  The initial
// value is `NULL`.
// This function may be called from the monitor callback, even for a monitor
// that is being disconnected.
//
// @param monitor The monitor whose pointer to set.
//
// @param pointer The new value.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Access is not
// synchronized.
//
// @sa
// @ref monitor_userptr
//
// @sa
// @ref glfwGetMonitorUserPointer
//
// @since Added in version 3.3.
func SetMonitorUserPointer(monitor unsafe.Pointer, pointer unsafe.Pointer) {
	bindlib.CCall2(__imp_glfwSetMonitorUserPointer.Addr(), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(pointer))
}

var __imp_glfwGetMonitorUserPointer bindlib.PreloadProc

// @brief Returns the user pointer of the specified monitor.
// This function returns the current value of the user-defined pointer of the
// specified monitor.  The initial value is `NULL`.
// This function may be called from the monitor callback, even for a monitor
// that is being disconnected.
//
// @param monitor The monitor whose pointer to return.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Access is not
// synchronized.
//
// @sa
// @ref monitor_userptr
//
// @sa
// @ref glfwSetMonitorUserPointer
//
// @since Added in version 3.3.
func GetMonitorUserPointer(monitor unsafe.Pointer) unsafe.Pointer {
	__res := bindlib.CCall1(__imp_glfwGetMonitorUserPointer.Addr(), bindlib.MarshallSyscall(monitor))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwSetMonitorCallback bindlib.PreloadProc

// @brief Sets the monitor configuration callback.
// This function sets the monitor configuration callback, or removes the
// currently set callback.  This is called when a monitor is connected to or
// disconnected from the system.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWmonitorfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_event
//
// @since Added in version 3.0.
func SetMonitorCallback(callback Monitorfun) Monitorfun {
	__res := bindlib.CCall1(__imp_glfwSetMonitorCallback.Addr(), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Monitorfun](__res)
}

var __imp_glfwGetVideoModes bindlib.PreloadProc

// @brief Returns the available video modes for the specified monitor.
// This function returns an array of all video modes supported by the specified
// monitor.  The returned array is sorted in ascending order, first by color
// bit depth (the sum of all channel depths), then by resolution area (the
// product of width and height), then resolution width and finally by refresh
// rate.
//
// @param monitor The monitor to query.
//
// @param count Where to store the number of video modes in the returned
// array.  This is set to zero if an error occurred.
//
// @return An array of video modes, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @pointer
// _lifetime The returned array is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified monitor is
// disconnected, this function is called again for that monitor or the library
// is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_modes
//
// @sa
// @ref glfwGetVideoMode
//
// @since Added in version 1.0.
//
// @glfw3
// Changed to return an array of modes for a specific monitor.
func GetVideoModes(monitor unsafe.Pointer, count *int32) unsafe.Pointer {
	__res := bindlib.CCall2(__imp_glfwGetVideoModes.Addr(), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(count))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwGetVideoMode bindlib.PreloadProc

// @brief Returns the current mode of the specified monitor.
// This function returns the current video mode of the specified monitor.  If
// you have created a full screen window for that monitor, the return value
// will depend on whether that window is iconified.
//
// @param monitor The monitor to query.
//
// @return The current mode of the monitor, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @pointer
// _lifetime The returned array is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified monitor is
// disconnected or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_modes
//
// @sa
// @ref glfwGetVideoModes
//
// @since Added in version 3.0.  Replaces `glfwGetDesktopMode`.
func GetVideoMode(monitor unsafe.Pointer) unsafe.Pointer {
	__res := bindlib.CCall1(__imp_glfwGetVideoMode.Addr(), bindlib.MarshallSyscall(monitor))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwSetGamma bindlib.PreloadProc

// @brief Generates a gamma ramp and sets it for the specified monitor.
// This function generates an appropriately sized gamma ramp from the specified
// exponent and then calls
// @ref glfwSetGammaRamp
// with it.  The value must be
// a finite number greater than zero.
// The software controlled gamma ramp is applied _in addition_ to the hardware
// gamma correction, which today is usually an approximation of sRGB gamma.
// This means that setting a perfectly linear ramp, or gamma 1.0, will produce
// the default (usually sRGB-like) behavior.
// For gamma correct rendering with OpenGL or OpenGL ES, see the
// @ref GLFW_SRGB_CAPABLE
// hint.
//
// @param monitor The monitor whose gamma ramp to set.
//
// @param gamma The desired exponent.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_VALUE,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @remark
// @wayland
// Gamma handling is a privileged protocol, this function
// will thus never be implemented and emits
// @ref GLFW_FEATURE_UNAVAILABLE.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_gamma
//
// @since Added in version 3.0.
func SetGamma(monitor unsafe.Pointer, gamma float32) {
	bindlib.CCall2(__imp_glfwSetGamma.Addr(), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(gamma))
}

var __imp_glfwGetGammaRamp bindlib.PreloadProc

// @brief Returns the current gamma ramp for the specified monitor.
// This function returns the current gamma ramp of the specified monitor.
//
// @param monitor The monitor to query.
//
// @return The current gamma ramp, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @remark
// @wayland
// Gamma handling is a privileged protocol, this function
// will thus never be implemented and emits
// @ref GLFW_FEATURE_UNAVAILABLE
// while
// returning `NULL`.
//
// @pointer
// _lifetime The returned structure and its arrays are allocated and
// freed by GLFW.  You should not free them yourself.  They are valid until the
// specified monitor is disconnected, this function is called again for that
// monitor or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_gamma
//
// @since Added in version 3.0.
func GetGammaRamp(monitor unsafe.Pointer) unsafe.Pointer {
	__res := bindlib.CCall1(__imp_glfwGetGammaRamp.Addr(), bindlib.MarshallSyscall(monitor))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwSetGammaRamp bindlib.PreloadProc

// @brief Sets the current gamma ramp for the specified monitor.
// This function sets the current gamma ramp for the specified monitor.  The
// original gamma ramp for that monitor is saved by GLFW the first time this
// function is called and is restored by
// @ref glfwTerminate.
// The software controlled gamma ramp is applied _in addition_ to the hardware
// gamma correction, which today is usually an approximation of sRGB gamma.
// This means that setting a perfectly linear ramp, or gamma 1.0, will produce
// the default (usually sRGB-like) behavior.
// For gamma correct rendering with OpenGL or OpenGL ES, see the
// @ref GLFW_SRGB_CAPABLE
// hint.
//
// @param monitor The monitor whose gamma ramp to set.
//
// @param ramp The gamma ramp to use.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @remark The size of the specified gamma ramp should match the size of the
// current ramp for that monitor.
//
// @remark
// @win32
// The gamma ramp size must be 256.
//
// @remark
// @wayland
// Gamma handling is a privileged protocol, this function
// will thus never be implemented and emits
// @ref GLFW_FEATURE_UNAVAILABLE.
//
// @pointer
// _lifetime The specified gamma ramp is copied before this function
// returns.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_gamma
//
// @since Added in version 3.0.
func SetGammaRamp(monitor unsafe.Pointer, ramp unsafe.Pointer) {
	bindlib.CCall2(__imp_glfwSetGammaRamp.Addr(), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(ramp))
}

var __imp_glfwDefaultWindowHints bindlib.PreloadProc

// @brief Resets all window hints to their default values.
// This function resets all window hints to their
// [default values](
// @ref window_hints_values).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_hints
//
// @sa
// @ref glfwWindowHint
//
// @sa
// @ref glfwWindowHintString
//
// @since Added in version 3.0.
func DefaultWindowHints() { bindlib.CCall0(__imp_glfwDefaultWindowHints.Addr()) }

var __imp_glfwWindowHint bindlib.PreloadProc

// @brief Sets the specified window hint to the desired value.
// This function sets hints for the next call to
// @ref glfwCreateWindow.
// The
// hints, once set, retain their values until changed by a call to this
// function or
// @ref glfwDefaultWindowHints,
// or until the library is terminated.
// Only integer value hints can be set with this function.  String value hints
// are set with
// @ref glfwWindowHintString.
// This function does not check whether the specified hint values are valid.
// If you set hints to invalid values this will instead be reported by the next
// call to
// @ref glfwCreateWindow.
// Some hints are platform specific.  These may be set on any platform but they
// will only affect their specific platform.  Other platforms will ignore them.
// Setting these hints requires no platform specific headers or functions.
//
// @param hint The [window hint](
// @ref window_hints)
// to set.
//
// @param value The new value of the window hint.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_hints
//
// @sa
// @ref glfwWindowHintString
//
// @sa
// @ref glfwDefaultWindowHints
//
// @since Added in version 3.0.  Replaces `glfwOpenWindowHint`.
func WindowHint(hint int32, value int32) {
	bindlib.CCall2(__imp_glfwWindowHint.Addr(), bindlib.MarshallSyscall(hint), bindlib.MarshallSyscall(value))
}

var __imp_glfwWindowHintString bindlib.PreloadProc

// @brief Sets the specified window hint to the desired value.
// This function sets hints for the next call to
// @ref glfwCreateWindow.
// The
// hints, once set, retain their values until changed by a call to this
// function or
// @ref glfwDefaultWindowHints,
// or until the library is terminated.
// Only string type hints can be set with this function.  Integer value hints
// are set with
// @ref glfwWindowHint.
// This function does not check whether the specified hint values are valid.
// If you set hints to invalid values this will instead be reported by the next
// call to
// @ref glfwCreateWindow.
// Some hints are platform specific.  These may be set on any platform but they
// will only affect their specific platform.  Other platforms will ignore them.
// Setting these hints requires no platform specific headers or functions.
//
// @param hint The [window hint](
// @ref window_hints)
// to set.
//
// @param value The new value of the window hint.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @pointer
// _lifetime The specified string is copied before this function
// returns.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_hints
//
// @sa
// @ref glfwWindowHint
//
// @sa
// @ref glfwDefaultWindowHints
//
// @since Added in version 3.3.
func WindowHintString(hint int32, value *byte) {
	bindlib.CCall2(__imp_glfwWindowHintString.Addr(), bindlib.MarshallSyscall(hint), bindlib.MarshallSyscall(value))
}

var __imp_glfwCreateWindow bindlib.PreloadProc

// @brief Creates a window and its associated context.
// This function creates a window and its associated OpenGL or OpenGL ES
// context.  Most of the options controlling how the window and its context
// should be created are specified with [window hints](
// @ref window_hints).
// Successful creation does not change which context is current.  Before you
// can use the newly created context, you need to
// [make it current](
// @ref context_current).
// For information about the `share`
// parameter, see
// @ref context_sharing.
// The created window, framebuffer and context may differ from what you
// requested, as not all parameters and hints are
// [hard constraints](
// @ref window_hints_hard).
// This includes the size of the
// window, especially for full screen windows.  To query the actual attributes
// of the created window, framebuffer and context, see
// @ref glfwGetWindowAttrib,
//
// @ref glfwGetWindowSize
// and
// @ref glfwGetFramebufferSize.
// To create a full screen window, you need to specify the monitor the window
// will cover.  If no monitor is specified, the window will be windowed mode.
// Unless you have a way for the user to choose a specific monitor, it is
// recommended that you pick the primary monitor.  For more information on how
// to query connected monitors, see
// @ref monitor_monitors.
// For full screen windows, the specified size becomes the resolution of the
// window's _desired video mode_.  As long as a full screen window is not
// iconified, the supported video mode most closely matching the desired video
// mode is set for the specified monitor.  For more information about full
// screen windows, including the creation of so called _windowed full screen_
// or _borderless full screen_ windows, see
// @ref window_windowed_full_screen.
// Once you have created the window, you can switch it between windowed and
// full screen mode with
// @ref glfwSetWindowMonitor.
// This will not affect its
// OpenGL or OpenGL ES context.
// By default, newly created windows use the placement recommended by the
// window system.  To create the window at a specific position, set the
// @ref GLFW_POSITION_X
// and
// @ref GLFW_POSITION_Y
// window hints before creation.  To
// restore the default behavior, set either or both hints back to
// `GLFW_ANY_POSITION`.
// As long as at least one full screen window is not iconified, the screensaver
// is prohibited from starting.
// Window systems put limits on window sizes.  Very large or very small window
// dimensions may be overridden by the window system on creation.  Check the
// actual [size](
// @ref window_size)
// after creation.
// The [swap interval](
// @ref buffer_swap)
// is not set during window creation and
// the initial value may vary depending on driver settings and defaults.
//
// @param width The desired width, in screen coordinates, of the window.
// This must be greater than zero.
//
// @param height The desired height, in screen coordinates, of the window.
// This must be greater than zero.
//
// @param title The initial, UTF-8 encoded window title.
//
// @param monitor The monitor to use for full screen mode, or `NULL` for
// windowed mode.
//
// @param share The window whose context to share resources with, or `NULL`
// to not share resources.
//
// @return The handle of the created window, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM,
//
// @ref GLFW_INVALID_VALUE,
//
// @ref GLFW_API_UNAVAILABLE,
//
// @ref GLFW_VERSION_UNAVAILABLE,
//
// @ref GLFW_FORMAT_UNAVAILABLE,
//
// @ref GLFW_NO_WINDOW_CONTEXT
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @win32
// Window creation will fail if the Microsoft GDI software
// OpenGL implementation is the only one available.
//
// @remark
// @win32
// If the executable has an icon resource named `GLFW_ICON,` it
// will be set as the initial icon for the window.  If no such icon is present,
// the `IDI_APPLICATION` icon will be used instead.  To set a different icon,
// see
// @ref glfwSetWindowIcon.
//
// @remark
// @win32
// The context to share resources with must not be current on
// any other thread.
//
// @remark
// @macos
// The OS only supports core profile contexts for OpenGL
// versions 3.2 and later.  Before creating an OpenGL context of version 3.2 or
// later you must set the [GLFW_OPENGL_PROFILE](
// @ref GLFW_OPENGL_PROFILE_hint)
// hint accordingly.  OpenGL 3.0 and 3.1 contexts are not supported at all
// on macOS.
//
// @remark
// @macos
// The GLFW window has no icon, as it is not a document
// window, but the dock icon will be the same as the application bundle's icon.
// For more information on bundles, see the
// [Bundle Programming Guide][bundle-guide] in the Mac Developer Library.
// [bundle-guide]: https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/
//
// @remark
// @macos
// The window frame will not be rendered at full resolution on
// Retina displays unless the
// [GLFW_SCALE_FRAMEBUFFER](
// @ref GLFW_SCALE_FRAMEBUFFER_hint)
// hint is `GLFW_TRUE` and the `NSHighResolutionCapable` key is enabled in the
// application bundle's `Info.plist`.  For more information, see
// [High Resolution Guidelines for OS X][hidpi-guide] in the Mac Developer
// Library.  The GLFW test and example programs use a custom `Info.plist`
// template for this, which can be found as `CMake/Info.plist.in` in the source
// tree.
// [hidpi-guide]: https://developer.apple.com/library/mac/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Explained/Explained.html
//
// @remark
// @macos
// When activating frame autosaving with
// [GLFW_COCOA_FRAME_NAME](
// @ref GLFW_COCOA_FRAME_NAME_hint),
// the specified
// window size and position may be overridden by previously saved values.
//
// @remark
// @wayland
// GLFW uses [libdecor][] where available to create its window
// decorations.  This in turn uses server-side XDG decorations where available
// and provides high quality client-side decorations on compositors like GNOME.
// If both XDG decorations and libdecor are unavailable, GLFW falls back to
// a very simple set of window decorations that only support moving, resizing
// and the window manager's right-click menu.
// [libdecor]: https://gitlab.freedesktop.org/libdecor/libdecor
//
// @remark
// @x11
// Some window managers will not respect the placement of
// initially hidden windows.
//
// @remark
// @x11
// Due to the asynchronous nature of X11, it may take a moment for
// a window to reach its requested state.  This means you may not be able to
// query the final size, position or other attributes directly after window
// creation.
//
// @remark
// @x11
// The class part of the `WM_CLASS` window property will by
// default be set to the window title passed to this function.  The instance
// part will use the contents of the `RESOURCE_NAME` environment variable, if
// present and not empty, or fall back to the window title.  Set the
// [GLFW_X11_CLASS_NAME](
// @ref GLFW_X11_CLASS_NAME_hint)
// and
// [GLFW_X11_INSTANCE_NAME](
// @ref GLFW_X11_INSTANCE_NAME_hint)
// window hints to
// override this.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_creation
//
// @sa
// @ref glfwDestroyWindow
//
// @since Added in version 3.0.  Replaces `glfwOpenWindow`.
func CreateWindow(width int32, height int32, title *byte, monitor unsafe.Pointer, share unsafe.Pointer) unsafe.Pointer {
	__res := bindlib.CCall5(__imp_glfwCreateWindow.Addr(), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height), bindlib.MarshallSyscall(title), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(share))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwDestroyWindow bindlib.PreloadProc

// @brief Destroys the specified window and its context.
// This function destroys the specified window and its context.  On calling
// this function, no further callbacks will be called for that window.
// If the context of the specified window is current on the main thread, it is
// detached before being destroyed.
//
// @param window The window to destroy.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @note The context of the specified window must not be current on any other
// thread when this function is called.
//
// @reentrancy
// This function must not be called from a callback.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_creation
//
// @sa
// @ref glfwCreateWindow
//
// @since Added in version 3.0.  Replaces `glfwCloseWindow`.
func DestroyWindow(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwDestroyWindow.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwWindowShouldClose bindlib.PreloadProc

// @brief Checks the close flag of the specified window.
// This function returns the value of the close flag of the specified window.
//
// @param window The window to query.
//
// @return The value of the close flag.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Access is not
// synchronized.
//
// @sa
// @ref window_close
//
// @since Added in version 3.0.
func WindowShouldClose(window unsafe.Pointer) int32 {
	__res := bindlib.CCall1(__imp_glfwWindowShouldClose.Addr(), bindlib.MarshallSyscall(window))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwSetWindowShouldClose bindlib.PreloadProc

// @brief Sets the close flag of the specified window.
// This function sets the value of the close flag of the specified window.
// This can be used to override the user's attempt to close the window, or
// to signal that it should be closed.
//
// @param window The window whose flag to change.
//
// @param value The new value.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Access is not
// synchronized.
//
// @sa
// @ref window_close
//
// @since Added in version 3.0.
func SetWindowShouldClose(window unsafe.Pointer, value int32) {
	bindlib.CCall2(__imp_glfwSetWindowShouldClose.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(value))
}

var __imp_glfwGetWindowTitle bindlib.PreloadProc

// @brief Returns the title of the specified window.
// This function returns the window title, encoded as UTF-8, of the specified
// window.  This is the title set previously by
// @ref glfwCreateWindow
// or
// @ref glfwSetWindowTitle.
//
// @param window The window to query.
//
// @return The UTF-8 encoded window title, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @remark The returned title is currently a copy of the title last set by
// @ref glfwCreateWindow
// or
// @ref glfwSetWindowTitle.
// It does not include any
// additional text which may be appended by the platform or another program.
//
// @pointer
// _lifetime The returned string is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the next call to
// @ref glfwGetWindowTitle
// or
// @ref glfwSetWindowTitle,
// or until the library is
// terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_title
//
// @sa
// @ref glfwSetWindowTitle
//
// @since Added in version 3.4.
func GetWindowTitle(window unsafe.Pointer) *byte {
	__res := bindlib.CCall1(__imp_glfwGetWindowTitle.Addr(), bindlib.MarshallSyscall(window))
	return bindlib.UnmarshallSyscall[*byte](__res)
}

var __imp_glfwSetWindowTitle bindlib.PreloadProc

// @brief Sets the title of the specified window.
// This function sets the window title, encoded as UTF-8, of the specified
// window.
//
// @param window The window whose title to change.
//
// @param title The UTF-8 encoded window title.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @macos
// The window title will not be updated until the next time you
// process events.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_title
//
// @sa
// @ref glfwGetWindowTitle
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter.
func SetWindowTitle(window unsafe.Pointer, title *byte) {
	bindlib.CCall2(__imp_glfwSetWindowTitle.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(title))
}

var __imp_glfwSetWindowIcon bindlib.PreloadProc

// @brief Sets the icon for the specified window.
// This function sets the icon of the specified window.  If passed an array of
// candidate images, those of or closest to the sizes desired by the system are
// selected.  If no images are specified, the window reverts to its default
// icon.
// The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight
// bits per channel with the red channel first.  They are arranged canonically
// as packed sequential rows, starting from the top-left corner.
// The desired image sizes varies depending on platform and system settings.
// The selected images will be rescaled as needed.  Good sizes include 16x16,
// 32x32 and 48x48.
//
// @param window The window whose icon to set.
//
// @param count The number of images in the specified array, or zero to
// revert to the default window icon.
//
// @param images The images to create the icon from.  This is ignored if
// count is zero.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_VALUE,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @pointer
// _lifetime The specified image data is copied before this function
// returns.
//
// @remark
// @macos
// Regular windows do not have icons on macOS.  This function
// will emit
// @ref GLFW_FEATURE_UNAVAILABLE.
// The dock icon will be the same as
// the application bundle's icon.  For more information on bundles, see the
// [Bundle Programming Guide][bundle-guide] in the Mac Developer Library.
// [bundle-guide]: https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/
//
// @remark
// @wayland
// There is no existing protocol to change an icon, the
// window will thus inherit the one defined in the application's desktop file.
// This function will emit
// @ref GLFW_FEATURE_UNAVAILABLE.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_icon
//
// @since Added in version 3.2.
func SetWindowIcon(window unsafe.Pointer, count int32, images unsafe.Pointer) {
	bindlib.CCall3(__imp_glfwSetWindowIcon.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(count), bindlib.MarshallSyscall(images))
}

var __imp_glfwGetWindowPos bindlib.PreloadProc

// @brief Retrieves the position of the content area of the specified window.
// This function retrieves the position, in screen coordinates, of the
// upper-left corner of the content area of the specified window.
// Any or all of the position arguments may be `NULL`.  If an error occurs, all
// non-`NULL` position arguments will be set to zero.
//
// @param window The window to query.
//
// @param xpos Where to store the x-coordinate of the upper-left corner of
// the content area, or `NULL`.
//
// @param ypos Where to store the y-coordinate of the upper-left corner of
// the content area, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @remark
// @wayland
// There is no way for an application to retrieve the global
// position of its windows.  This function will emit
// @ref GLFW_FEATURE_UNAVAILABLE.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_pos
//
// @sa
// @ref glfwSetWindowPos
//
// @since Added in version 3.0.
func GetWindowPos(window unsafe.Pointer, xpos *int32, ypos *int32) {
	bindlib.CCall3(__imp_glfwGetWindowPos.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(xpos), bindlib.MarshallSyscall(ypos))
}

var __imp_glfwSetWindowPos bindlib.PreloadProc

// @brief Sets the position of the content area of the specified window.
// This function sets the position, in screen coordinates, of the upper-left
// corner of the content area of the specified windowed mode window.  If the
// window is a full screen window, this function does nothing.
// __Do not use this function__ to move an already visible window unless you
// have very good reasons for doing so, as it will confuse and annoy the user.
// The window manager may put limits on what positions are allowed.  GLFW
// cannot and should not override these limits.
//
// @param window The window to query.
//
// @param xpos The x-coordinate of the upper-left corner of the content area.
//
// @param ypos The y-coordinate of the upper-left corner of the content area.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @remark
// @wayland
// There is no way for an application to set the global
// position of its windows.  This function will emit
// @ref GLFW_FEATURE_UNAVAILABLE.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_pos
//
// @sa
// @ref glfwGetWindowPos
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter.
func SetWindowPos(window unsafe.Pointer, xpos int32, ypos int32) {
	bindlib.CCall3(__imp_glfwSetWindowPos.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(xpos), bindlib.MarshallSyscall(ypos))
}

var __imp_glfwGetWindowSize bindlib.PreloadProc

// @brief Retrieves the size of the content area of the specified window.
// This function retrieves the size, in screen coordinates, of the content area
// of the specified window.  If you wish to retrieve the size of the
// framebuffer of the window in pixels, see
// @ref glfwGetFramebufferSize.
// Any or all of the size arguments may be `NULL`.  If an error occurs, all
// non-`NULL` size arguments will be set to zero.
//
// @param window The window whose size to retrieve.
//
// @param width Where to store the width, in screen coordinates, of the
// content area, or `NULL`.
//
// @param height Where to store the height, in screen coordinates, of the
// content area, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_size
//
// @sa
// @ref glfwSetWindowSize
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter.
func GetWindowSize(window unsafe.Pointer, width *int32, height *int32) {
	bindlib.CCall3(__imp_glfwGetWindowSize.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height))
}

var __imp_glfwSetWindowSizeLimits bindlib.PreloadProc

// @brief Sets the size limits of the specified window.
// This function sets the size limits of the content area of the specified
// window.  If the window is full screen, the size limits only take effect
// once it is made windowed.  If the window is not resizable, this function
// does nothing.
// The size limits are applied immediately to a windowed mode window and may
// cause it to be resized.
// The maximum dimensions must be greater than or equal to the minimum
// dimensions and all must be greater than or equal to zero.
//
// @param window The window to set limits for.
//
// @param minwidth The minimum width, in screen coordinates, of the content
// area, or `GLFW_DONT_CARE`.
//
// @param minheight The minimum height, in screen coordinates, of the
// content area, or `GLFW_DONT_CARE`.
//
// @param maxwidth The maximum width, in screen coordinates, of the content
// area, or `GLFW_DONT_CARE`.
//
// @param maxheight The maximum height, in screen coordinates, of the
// content area, or `GLFW_DONT_CARE`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_VALUE
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark If you set size limits and an aspect ratio that conflict, the
// results are undefined.
//
// @remark
// @wayland
// The size limits will not be applied until the window is
// actually resized, either by the user or by the compositor.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_sizelimits
//
// @sa
// @ref glfwSetWindowAspectRatio
//
// @since Added in version 3.2.
func SetWindowSizeLimits(window unsafe.Pointer, minwidth int32, minheight int32, maxwidth int32, maxheight int32) {
	bindlib.CCall5(__imp_glfwSetWindowSizeLimits.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(minwidth), bindlib.MarshallSyscall(minheight), bindlib.MarshallSyscall(maxwidth), bindlib.MarshallSyscall(maxheight))
}

var __imp_glfwSetWindowAspectRatio bindlib.PreloadProc

// @brief Sets the aspect ratio of the specified window.
// This function sets the required aspect ratio of the content area of the
// specified window.  If the window is full screen, the aspect ratio only takes
// effect once it is made windowed.  If the window is not resizable, this
// function does nothing.
// The aspect ratio is specified as a numerator and a denominator and both
// values must be greater than zero.  For example, the common 16:9 aspect ratio
// is specified as 16 and 9, respectively.
// If the numerator and denominator is set to `GLFW_DONT_CARE` then the aspect
// ratio limit is disabled.
// The aspect ratio is applied immediately to a windowed mode window and may
// cause it to be resized.
//
// @param window The window to set limits for.
//
// @param numer The numerator of the desired aspect ratio, or
// `GLFW_DONT_CARE`.
//
// @param denom The denominator of the desired aspect ratio, or
// `GLFW_DONT_CARE`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_VALUE
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark If you set size limits and an aspect ratio that conflict, the
// results are undefined.
//
// @remark
// @wayland
// The aspect ratio will not be applied until the window is
// actually resized, either by the user or by the compositor.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_sizelimits
//
// @sa
// @ref glfwSetWindowSizeLimits
//
// @since Added in version 3.2.
func SetWindowAspectRatio(window unsafe.Pointer, numer int32, denom int32) {
	bindlib.CCall3(__imp_glfwSetWindowAspectRatio.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(numer), bindlib.MarshallSyscall(denom))
}

var __imp_glfwSetWindowSize bindlib.PreloadProc

// @brief Sets the size of the content area of the specified window.
// This function sets the size, in screen coordinates, of the content area of
// the specified window.
// For full screen windows, this function updates the resolution of its desired
// video mode and switches to the video mode closest to it, without affecting
// the window's context.  As the context is unaffected, the bit depths of the
// framebuffer remain unchanged.
// If you wish to update the refresh rate of the desired video mode in addition
// to its resolution, see
// @ref glfwSetWindowMonitor.
// The window manager may put limits on what sizes are allowed.  GLFW cannot
// and should not override these limits.
//
// @param window The window to resize.
//
// @param width The desired width, in screen coordinates, of the window
// content area.
//
// @param height The desired height, in screen coordinates, of the window
// content area.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_size
//
// @sa
// @ref glfwGetWindowSize
//
// @sa
// @ref glfwSetWindowMonitor
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter.
func SetWindowSize(window unsafe.Pointer, width int32, height int32) {
	bindlib.CCall3(__imp_glfwSetWindowSize.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height))
}

var __imp_glfwGetFramebufferSize bindlib.PreloadProc

// @brief Retrieves the size of the framebuffer of the specified window.
// This function retrieves the size, in pixels, of the framebuffer of the
// specified window.  If you wish to retrieve the size of the window in screen
// coordinates, see
// @ref glfwGetWindowSize.
// Any or all of the size arguments may be `NULL`.  If an error occurs, all
// non-`NULL` size arguments will be set to zero.
//
// @param window The window whose framebuffer to query.
//
// @param width Where to store the width, in pixels, of the framebuffer,
// or `NULL`.
//
// @param height Where to store the height, in pixels, of the framebuffer,
// or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_fbsize
//
// @sa
// @ref glfwSetFramebufferSizeCallback
//
// @since Added in version 3.0.
func GetFramebufferSize(window unsafe.Pointer, width *int32, height *int32) {
	bindlib.CCall3(__imp_glfwGetFramebufferSize.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height))
}

var __imp_glfwGetWindowFrameSize bindlib.PreloadProc

// @brief Retrieves the size of the frame of the window.
// This function retrieves the size, in screen coordinates, of each edge of the
// frame of the specified window.  This size includes the title bar, if the
// window has one.  The size of the frame may vary depending on the
// [window-related hints](
// @ref window_hints_wnd)
// used to create it.
// Because this function retrieves the size of each window frame edge and not
// the offset along a particular coordinate axis, the retrieved values will
// always be zero or positive.
// Any or all of the size arguments may be `NULL`.  If an error occurs, all
// non-`NULL` size arguments will be set to zero.
//
// @param window The window whose frame size to query.
//
// @param left Where to store the size, in screen coordinates, of the left
// edge of the window frame, or `NULL`.
//
// @param top Where to store the size, in screen coordinates, of the top
// edge of the window frame, or `NULL`.
//
// @param right Where to store the size, in screen coordinates, of the
// right edge of the window frame, or `NULL`.
//
// @param bottom Where to store the size, in screen coordinates, of the
// bottom edge of the window frame, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_size
//
// @since Added in version 3.1.
func GetWindowFrameSize(window unsafe.Pointer, left *int32, top *int32, right *int32, bottom *int32) {
	bindlib.CCall5(__imp_glfwGetWindowFrameSize.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(left), bindlib.MarshallSyscall(top), bindlib.MarshallSyscall(right), bindlib.MarshallSyscall(bottom))
}

var __imp_glfwGetWindowContentScale bindlib.PreloadProc

// @brief Retrieves the content scale for the specified window.
// This function retrieves the content scale for the specified window.  The
// content scale is the ratio between the current DPI and the platform's
// default DPI.  This is especially important for text and any UI elements.  If
// the pixel dimensions of your UI scaled by this look appropriate on your
// machine then it should appear at a reasonable size on other machines
// regardless of their DPI and scaling settings.  This relies on the system DPI
// and scaling settings being somewhat correct.
// On platforms where each monitors can have its own content scale, the window
// content scale will depend on which monitor the system considers the window
// to be on.
//
// @param window The window to query.
//
// @param xscale Where to store the x-axis content scale, or `NULL`.
//
// @param yscale Where to store the y-axis content scale, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_scale
//
// @sa
// @ref glfwSetWindowContentScaleCallback
//
// @sa
// @ref glfwGetMonitorContentScale
//
// @since Added in version 3.3.
func GetWindowContentScale(window unsafe.Pointer, xscale *float32, yscale *float32) {
	bindlib.CCall3(__imp_glfwGetWindowContentScale.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(xscale), bindlib.MarshallSyscall(yscale))
}

var __imp_glfwGetWindowOpacity bindlib.PreloadProc

// @brief Returns the opacity of the whole window.
// This function returns the opacity of the window, including any decorations.
// The opacity (or alpha) value is a positive finite number between zero and
// one, where zero is fully transparent and one is fully opaque.  If the system
// does not support whole window transparency, this function always returns one.
// The initial opacity value for newly created windows is one.
//
// @param window The window to query.
//
// @return The opacity value of the specified window.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_transparency
//
// @sa
// @ref glfwSetWindowOpacity
//
// @since Added in version 3.3.
func GetWindowOpacity(window unsafe.Pointer) float32 {
	__res := bindlib.CCall1(__imp_glfwGetWindowOpacity.Addr(), bindlib.MarshallSyscall(window))
	return bindlib.UnmarshallSyscall[float32](__res)
}

var __imp_glfwSetWindowOpacity bindlib.PreloadProc

// @brief Sets the opacity of the whole window.
// This function sets the opacity of the window, including any decorations.
// The opacity (or alpha) value is a positive finite number between zero and
// one, where zero is fully transparent and one is fully opaque.
// The initial opacity value for newly created windows is one.
// A window created with framebuffer transparency may not use whole window
// transparency.  The results of doing this are undefined.
//
// @param window The window to set the opacity for.
//
// @param opacity The desired opacity of the specified window.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @remark
// @wayland
// There is no way to set an opacity factor for a window.
// This function will emit
// @ref GLFW_FEATURE_UNAVAILABLE.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_transparency
//
// @sa
// @ref glfwGetWindowOpacity
//
// @since Added in version 3.3.
func SetWindowOpacity(window unsafe.Pointer, opacity float32) {
	bindlib.CCall2(__imp_glfwSetWindowOpacity.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(opacity))
}

var __imp_glfwIconifyWindow bindlib.PreloadProc

// @brief Iconifies the specified window.
// This function iconifies (minimizes) the specified window if it was
// previously restored.  If the window is already iconified, this function does
// nothing.
// If the specified window is a full screen window, GLFW restores the original
// video mode of the monitor.  The window's desired video mode is set again
// when the window is restored.
//
// @param window The window to iconify.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @wayland
// Once a window is iconified,
// @ref glfwRestoreWindow
// won’t
// be able to restore it.  This is a design decision of the xdg-shell
// protocol.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_iconify
//
// @sa
// @ref glfwRestoreWindow
//
// @sa
// @ref glfwMaximizeWindow
//
// @since Added in version 2.1.
//
// @glfw3
// Added window handle parameter.
func IconifyWindow(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwIconifyWindow.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwRestoreWindow bindlib.PreloadProc

// @brief Restores the specified window.
// This function restores the specified window if it was previously iconified
// (minimized) or maximized.  If the window is already restored, this function
// does nothing.
// If the specified window is an iconified full screen window, its desired
// video mode is set again for its monitor when the window is restored.
//
// @param window The window to restore.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_iconify
//
// @sa
// @ref glfwIconifyWindow
//
// @sa
// @ref glfwMaximizeWindow
//
// @since Added in version 2.1.
//
// @glfw3
// Added window handle parameter.
func RestoreWindow(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwRestoreWindow.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwMaximizeWindow bindlib.PreloadProc

// @brief Maximizes the specified window.
// This function maximizes the specified window if it was previously not
// maximized.  If the window is already maximized, this function does nothing.
// If the specified window is a full screen window, this function does nothing.
//
// @param window The window to maximize.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @par Thread Safety
// This function may only be called from the main thread.
//
// @sa
// @ref window_iconify
//
// @sa
// @ref glfwIconifyWindow
//
// @sa
// @ref glfwRestoreWindow
//
// @since Added in GLFW 3.2.
func MaximizeWindow(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwMaximizeWindow.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwShowWindow bindlib.PreloadProc

// @brief Makes the specified window visible.
// This function makes the specified window visible if it was previously
// hidden.  If the window is already visible or is in full screen mode, this
// function does nothing.
// By default, windowed mode windows are focused when shown
// Set the [GLFW_FOCUS_ON_SHOW](
// @ref GLFW_FOCUS_ON_SHOW_hint)
// window hint
// to change this behavior for all newly created windows, or change the
// behavior for an existing window with
// @ref glfwSetWindowAttrib.
//
// @param window The window to make visible.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @wayland
// Because Wayland wants every frame of the desktop to be
// complete, this function does not immediately make the window visible.
// Instead it will become visible the next time the window framebuffer is
// updated after this call.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_hide
//
// @sa
// @ref glfwHideWindow
//
// @since Added in version 3.0.
func ShowWindow(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwShowWindow.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwHideWindow bindlib.PreloadProc

// @brief Hides the specified window.
// This function hides the specified window if it was previously visible.  If
// the window is already hidden or is in full screen mode, this function does
// nothing.
//
// @param window The window to hide.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_hide
//
// @sa
// @ref glfwShowWindow
//
// @since Added in version 3.0.
func HideWindow(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwHideWindow.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwFocusWindow bindlib.PreloadProc

// @brief Brings the specified window to front and sets input focus.
// This function brings the specified window to front and sets input focus.
// The window should already be visible and not iconified.
// By default, both windowed and full screen mode windows are focused when
// initially created.  Set the [GLFW_FOCUSED](
// @ref GLFW_FOCUSED_hint)
// to
// disable this behavior.
// Also by default, windowed mode windows are focused when shown
// with
// @ref glfwShowWindow.
// Set the
// [GLFW_FOCUS_ON_SHOW](
// @ref GLFW_FOCUS_ON_SHOW_hint)
// to disable this behavior.
// __Do not use this function__ to steal focus from other applications unless
// you are certain that is what the user wants.  Focus stealing can be
// extremely disruptive.
// For a less disruptive way of getting the user's attention, see
// [attention requests](
// @ref window_attention).
//
// @param window The window to give input focus.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @wayland
// The compositor will likely ignore focus requests unless
// another window created by the same application already has input focus.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_focus
//
// @sa
// @ref window_attention
//
// @since Added in version 3.2.
func FocusWindow(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwFocusWindow.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwRequestWindowAttention bindlib.PreloadProc

// @brief Requests user attention to the specified window.
// This function requests user attention to the specified window.  On
// platforms where this is not supported, attention is requested to the
// application as a whole.
// Once the user has given attention, usually by focusing the window or
// application, the system will end the request automatically.
//
// @param window The window to request attention to.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @macos
// Attention is requested to the application as a whole, not the
// specific window.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_attention
//
// @since Added in version 3.3.
func RequestWindowAttention(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwRequestWindowAttention.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwGetWindowMonitor bindlib.PreloadProc

// @brief Returns the monitor that the window uses for full screen mode.
// This function returns the handle of the monitor that the specified window is
// in full screen on.
//
// @param window The window to query.
//
// @return The monitor, or `NULL` if the window is in windowed mode or an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_monitor
//
// @sa
// @ref glfwSetWindowMonitor
//
// @since Added in version 3.0.
func GetWindowMonitor(window unsafe.Pointer) unsafe.Pointer {
	__res := bindlib.CCall1(__imp_glfwGetWindowMonitor.Addr(), bindlib.MarshallSyscall(window))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwSetWindowMonitor bindlib.PreloadProc

// @brief Sets the mode, monitor, video mode and placement of a window.
// This function sets the monitor that the window uses for full screen mode or,
// if the monitor is `NULL`, makes it windowed mode.
// When setting a monitor, this function updates the width, height and refresh
// rate of the desired video mode and switches to the video mode closest to it.
// The window position is ignored when setting a monitor.
// When the monitor is `NULL`, the position, width and height are used to
// place the window content area.  The refresh rate is ignored when no monitor
// is specified.
// If you only wish to update the resolution of a full screen window or the
// size of a windowed mode window, see
// @ref glfwSetWindowSize.
// When a window transitions from full screen to windowed mode, this function
// restores any previous window settings such as whether it is decorated,
// floating, resizable, has size or aspect ratio limits, etc.
//
// @param window The window whose monitor, size or video mode to set.
//
// @param monitor The desired monitor, or `NULL` to set windowed mode.
//
// @param xpos The desired x-coordinate of the upper-left corner of the
// content area.
//
// @param ypos The desired y-coordinate of the upper-left corner of the
// content area.
//
// @param width The desired with, in screen coordinates, of the content
// area or video mode.
//
// @param height The desired height, in screen coordinates, of the content
// area or video mode.
//
// @param refreshRate The desired refresh rate, in Hz, of the video mode,
// or `GLFW_DONT_CARE`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark The OpenGL or OpenGL ES context will not be destroyed or otherwise
// affected by any resizing or mode switching, although you may need to update
// your viewport if the framebuffer size has changed.
//
// @remark
// @wayland
// The desired window position is ignored, as there is no way
// for an application to set this property.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_monitor
//
// @sa
// @ref window_full_screen
//
// @sa
// @ref glfwGetWindowMonitor
//
// @sa
// @ref glfwSetWindowSize
//
// @since Added in version 3.2.
func SetWindowMonitor(window unsafe.Pointer, monitor unsafe.Pointer, xpos int32, ypos int32, width int32, height int32, refreshRate int32) {
	bindlib.CCall7(__imp_glfwSetWindowMonitor.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(xpos), bindlib.MarshallSyscall(ypos), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height), bindlib.MarshallSyscall(refreshRate))
}

var __imp_glfwGetWindowAttrib bindlib.PreloadProc

// @brief Returns an attribute of the specified window.
// This function returns the value of an attribute of the specified window or
// its OpenGL or OpenGL ES context.
//
// @param window The window to query.
//
// @param attrib The [window attribute](
// @ref window_attribs)
// whose value to
// return.
//
// @return The value of the attribute, or zero if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark Framebuffer related hints are not window attributes.  See
// @ref window_attribs_fb
// for more information.
//
// @remark Zero is a valid value for many window and context related
// attributes so you cannot use a return value of zero as an indication of
// errors.  However, this function should not fail as long as it is passed
// valid arguments and the library has been [initialized](
// @ref intro_init).
//
// @remark
// @wayland
// The Wayland protocol provides no way to check whether a
// window is iconfied, so
// @ref GLFW_ICONIFIED
// always returns `GLFW_FALSE`.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_attribs
//
// @sa
// @ref glfwSetWindowAttrib
//
// @since Added in version 3.0.  Replaces `glfwGetWindowParam` and
// `glfwGetGLVersion`.
func GetWindowAttrib(window unsafe.Pointer, attrib int32) int32 {
	__res := bindlib.CCall2(__imp_glfwGetWindowAttrib.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(attrib))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwSetWindowAttrib bindlib.PreloadProc

// @brief Sets an attribute of the specified window.
// This function sets the value of an attribute of the specified window.
// The supported attributes are [GLFW_DECORATED](
// @ref GLFW_DECORATED_attrib),
// [GLFW_RESIZABLE](
// @ref GLFW_RESIZABLE_attrib),
// [GLFW_FLOATING](
// @ref GLFW_FLOATING_attrib),
// [GLFW_AUTO_ICONIFY](
// @ref GLFW_AUTO_ICONIFY_attrib)
// and
// [GLFW_FOCUS_ON_SHOW](
// @ref GLFW_FOCUS_ON_SHOW_attrib).
// [GLFW_MOUSE_PASSTHROUGH](
// @ref GLFW_MOUSE_PASSTHROUGH_attrib)
// Some of these attributes are ignored for full screen windows.  The new
// value will take effect if the window is later made windowed.
// Some of these attributes are ignored for windowed mode windows.  The new
// value will take effect if the window is later made full screen.
//
// @param window The window to set the attribute for.
//
// @param attrib A supported window attribute.
//
// @param value `GLFW_TRUE` or `GLFW_FALSE`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM,
//
// @ref GLFW_INVALID_VALUE,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @remark Calling
// @ref glfwGetWindowAttrib
// will always return the latest
// value, even if that value is ignored by the current mode of the window.
//
// @remark
// @wayland
// The [GLFW_FLOATING](
// @ref GLFW_FLOATING_attrib)
// window attribute is
// not supported.  Setting this will emit
// @ref GLFW_FEATURE_UNAVAILABLE.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_attribs
//
// @sa
// @ref glfwGetWindowAttrib
//
// @since Added in version 3.3.
func SetWindowAttrib(window unsafe.Pointer, attrib int32, value int32) {
	bindlib.CCall3(__imp_glfwSetWindowAttrib.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(attrib), bindlib.MarshallSyscall(value))
}

var __imp_glfwSetWindowUserPointer bindlib.PreloadProc

// @brief Sets the user pointer of the specified window.
// This function sets the user-defined pointer of the specified window.  The
// current value is retained until the window is destroyed.  The initial value
// is `NULL`.
//
// @param window The window whose pointer to set.
//
// @param pointer The new value.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Access is not
// synchronized.
//
// @sa
// @ref window_userptr
//
// @sa
// @ref glfwGetWindowUserPointer
//
// @since Added in version 3.0.
func SetWindowUserPointer(window unsafe.Pointer, pointer unsafe.Pointer) {
	bindlib.CCall2(__imp_glfwSetWindowUserPointer.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(pointer))
}

var __imp_glfwGetWindowUserPointer bindlib.PreloadProc

// @brief Returns the user pointer of the specified window.
// This function returns the current value of the user-defined pointer of the
// specified window.  The initial value is `NULL`.
//
// @param window The window whose pointer to return.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Access is not
// synchronized.
//
// @sa
// @ref window_userptr
//
// @sa
// @ref glfwSetWindowUserPointer
//
// @since Added in version 3.0.
func GetWindowUserPointer(window unsafe.Pointer) unsafe.Pointer {
	__res := bindlib.CCall1(__imp_glfwGetWindowUserPointer.Addr(), bindlib.MarshallSyscall(window))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwSetWindowPosCallback bindlib.PreloadProc

// @brief Sets the position callback for the specified window.
// This function sets the position callback of the specified window, which is
// called when the window is moved.  The callback is provided with the
// position, in screen coordinates, of the upper-left corner of the content
// area of the window.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWwindowposfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @remark
// @wayland
// This callback will never be called, as there is no way for
// an application to know its global position.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_pos
//
// @since Added in version 3.0.
func SetWindowPosCallback(window unsafe.Pointer, callback Windowposfun) Windowposfun {
	__res := bindlib.CCall2(__imp_glfwSetWindowPosCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Windowposfun](__res)
}

var __imp_glfwSetWindowSizeCallback bindlib.PreloadProc

// @brief Sets the size callback for the specified window.
// This function sets the size callback of the specified window, which is
// called when the window is resized.  The callback is provided with the size,
// in screen coordinates, of the content area of the window.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWwindowsizefun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_size
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter and return value.
func SetWindowSizeCallback(window unsafe.Pointer, callback Windowsizefun) Windowsizefun {
	__res := bindlib.CCall2(__imp_glfwSetWindowSizeCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Windowsizefun](__res)
}

var __imp_glfwSetWindowCloseCallback bindlib.PreloadProc

// @brief Sets the close callback for the specified window.
// This function sets the close callback of the specified window, which is
// called when the user attempts to close the window, for example by clicking
// the close widget in the title bar.
// The close flag is set before this callback is called, but you can modify it
// at any time with
// @ref glfwSetWindowShouldClose.
// The close callback is not triggered by
// @ref glfwDestroyWindow.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWwindowclosefun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @remark
// @macos
// Selecting Quit from the application menu will trigger the
// close callback for all windows.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_close
//
// @since Added in version 2.5.
//
// @glfw3
// Added window handle parameter and return value.
func SetWindowCloseCallback(window unsafe.Pointer, callback Windowclosefun) Windowclosefun {
	__res := bindlib.CCall2(__imp_glfwSetWindowCloseCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Windowclosefun](__res)
}

var __imp_glfwSetWindowRefreshCallback bindlib.PreloadProc

// @brief Sets the refresh callback for the specified window.
// This function sets the refresh callback of the specified window, which is
// called when the content area of the window needs to be redrawn, for example
// if the window has been exposed after having been covered by another window.
// On compositing window systems such as Aero, Compiz, Aqua or Wayland, where
// the window contents are saved off-screen, this callback may be called only
// very infrequently or never at all.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWwindowrefreshfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_refresh
//
// @since Added in version 2.5.
//
// @glfw3
// Added window handle parameter and return value.
func SetWindowRefreshCallback(window unsafe.Pointer, callback Windowrefreshfun) Windowrefreshfun {
	__res := bindlib.CCall2(__imp_glfwSetWindowRefreshCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Windowrefreshfun](__res)
}

var __imp_glfwSetWindowFocusCallback bindlib.PreloadProc

// @brief Sets the focus callback for the specified window.
// This function sets the focus callback of the specified window, which is
// called when the window gains or loses input focus.
// After the focus callback is called for a window that lost input focus,
// synthetic key and mouse button release events will be generated for all such
// that had been pressed.  For more information, see
// @ref glfwSetKeyCallback
// and
// @ref glfwSetMouseButtonCallback.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWwindowfocusfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_focus
//
// @since Added in version 3.0.
func SetWindowFocusCallback(window unsafe.Pointer, callback Windowfocusfun) Windowfocusfun {
	__res := bindlib.CCall2(__imp_glfwSetWindowFocusCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Windowfocusfun](__res)
}

var __imp_glfwSetWindowIconifyCallback bindlib.PreloadProc

// @brief Sets the iconify callback for the specified window.
// This function sets the iconification callback of the specified window, which
// is called when the window is iconified or restored.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWwindowiconifyfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_iconify
//
// @since Added in version 3.0.
func SetWindowIconifyCallback(window unsafe.Pointer, callback Windowiconifyfun) Windowiconifyfun {
	__res := bindlib.CCall2(__imp_glfwSetWindowIconifyCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Windowiconifyfun](__res)
}

var __imp_glfwSetWindowMaximizeCallback bindlib.PreloadProc

// @brief Sets the maximize callback for the specified window.
// This function sets the maximization callback of the specified window, which
// is called when the window is maximized or restored.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWwindowmaximizefun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_maximize
//
// @since Added in version 3.3.
func SetWindowMaximizeCallback(window unsafe.Pointer, callback Windowmaximizefun) Windowmaximizefun {
	__res := bindlib.CCall2(__imp_glfwSetWindowMaximizeCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Windowmaximizefun](__res)
}

var __imp_glfwSetFramebufferSizeCallback bindlib.PreloadProc

// @brief Sets the framebuffer resize callback for the specified window.
// This function sets the framebuffer resize callback of the specified window,
// which is called when the framebuffer of the specified window is resized.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWframebuffersizefun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_fbsize
//
// @since Added in version 3.0.
func SetFramebufferSizeCallback(window unsafe.Pointer, callback Framebuffersizefun) Framebuffersizefun {
	__res := bindlib.CCall2(__imp_glfwSetFramebufferSizeCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Framebuffersizefun](__res)
}

var __imp_glfwSetWindowContentScaleCallback bindlib.PreloadProc

// @brief Sets the window content scale callback for the specified window.
// This function sets the window content scale callback of the specified window,
// which is called when the content scale of the specified window changes.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWwindowcontentscalefun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_scale
//
// @sa
// @ref glfwGetWindowContentScale
//
// @since Added in version 3.3.
func SetWindowContentScaleCallback(window unsafe.Pointer, callback Windowcontentscalefun) Windowcontentscalefun {
	__res := bindlib.CCall2(__imp_glfwSetWindowContentScaleCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Windowcontentscalefun](__res)
}

var __imp_glfwPollEvents bindlib.PreloadProc

// @brief Processes all pending events.
// This function processes only those events that are already in the event
// queue and then returns immediately.  Processing events will cause the window
// and input callbacks associated with those events to be called.
// On some platforms, a window move, resize or menu operation will cause event
// processing to block.  This is due to how event processing is designed on
// those platforms.  You can use the
// [window refresh callback](
// @ref window_refresh)
// to redraw the contents of
// your window when necessary during such operations.
// Do not assume that callbacks you set will _only_ be called in response to
// event processing functions like this one.  While it is necessary to poll for
// events, window systems that require GLFW to register callbacks of its own
// can pass events to GLFW in response to many window system function calls.
// GLFW will pass those events on to the application callbacks before
// returning.
// Event processing is not required for joystick input to work.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @reentrancy
// This function must not be called from a callback.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref events
//
// @sa
// @ref glfwWaitEvents
//
// @sa
// @ref glfwWaitEventsTimeout
//
// @since Added in version 1.0.
func PollEvents() { bindlib.CCall0(__imp_glfwPollEvents.Addr()) }

var __imp_glfwWaitEvents bindlib.PreloadProc

// @brief Waits until events are queued and processes them.
// This function puts the calling thread to sleep until at least one event is
// available in the event queue.  Once one or more events are available,
// it behaves exactly like
// @ref glfwPollEvents,
// i.e. the events in the queue
// are processed and the function then returns immediately.  Processing events
// will cause the window and input callbacks associated with those events to be
// called.
// Since not all events are associated with callbacks, this function may return
// without a callback having been called even if you are monitoring all
// callbacks.
// On some platforms, a window move, resize or menu operation will cause event
// processing to block.  This is due to how event processing is designed on
// those platforms.  You can use the
// [window refresh callback](
// @ref window_refresh)
// to redraw the contents of
// your window when necessary during such operations.
// Do not assume that callbacks you set will _only_ be called in response to
// event processing functions like this one.  While it is necessary to poll for
// events, window systems that require GLFW to register callbacks of its own
// can pass events to GLFW in response to many window system function calls.
// GLFW will pass those events on to the application callbacks before
// returning.
// Event processing is not required for joystick input to work.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @reentrancy
// This function must not be called from a callback.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref events
//
// @sa
// @ref glfwPollEvents
//
// @sa
// @ref glfwWaitEventsTimeout
//
// @since Added in version 2.5.
func WaitEvents() { bindlib.CCall0(__imp_glfwWaitEvents.Addr()) }

var __imp_glfwWaitEventsTimeout bindlib.PreloadProc

// @brief Waits with timeout until events are queued and processes them.
// This function puts the calling thread to sleep until at least one event is
// available in the event queue, or until the specified timeout is reached.  If
// one or more events are available, it behaves exactly like
// @ref glfwPollEvents,
// i.e. the events in the queue are processed and the function
// then returns immediately.  Processing events will cause the window and input
// callbacks associated with those events to be called.
// The timeout value must be a positive finite number.
// Since not all events are associated with callbacks, this function may return
// without a callback having been called even if you are monitoring all
// callbacks.
// On some platforms, a window move, resize or menu operation will cause event
// processing to block.  This is due to how event processing is designed on
// those platforms.  You can use the
// [window refresh callback](
// @ref window_refresh)
// to redraw the contents of
// your window when necessary during such operations.
// Do not assume that callbacks you set will _only_ be called in response to
// event processing functions like this one.  While it is necessary to poll for
// events, window systems that require GLFW to register callbacks of its own
// can pass events to GLFW in response to many window system function calls.
// GLFW will pass those events on to the application callbacks before
// returning.
// Event processing is not required for joystick input to work.
//
// @param timeout The maximum amount of time, in seconds, to wait.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_VALUE
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @reentrancy
// This function must not be called from a callback.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref events
//
// @sa
// @ref glfwPollEvents
//
// @sa
// @ref glfwWaitEvents
//
// @since Added in version 3.2.
func WaitEventsTimeout(timeout float64) {
	bindlib.CCall1(__imp_glfwWaitEventsTimeout.Addr(), bindlib.MarshallSyscall(timeout))
}

var __imp_glfwPostEmptyEvent bindlib.PreloadProc

// @brief Posts an empty event to the event queue.
// This function posts an empty event from the current thread to the event
// queue, causing
// @ref glfwWaitEvents
// or
// @ref glfwWaitEventsTimeout
// to return.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref events
//
// @sa
// @ref glfwWaitEvents
//
// @sa
// @ref glfwWaitEventsTimeout
//
// @since Added in version 3.1.
func PostEmptyEvent() { bindlib.CCall0(__imp_glfwPostEmptyEvent.Addr()) }

var __imp_glfwGetInputMode bindlib.PreloadProc

// @brief Returns the value of an input option for the specified window.
// This function returns the value of an input option for the specified window.
// The mode must be one of
// @ref GLFW_CURSOR,
//
// @ref GLFW_STICKY_KEYS,
//
// @ref GLFW_STICKY_MOUSE_BUTTONS,
//
// @ref GLFW_LOCK_KEY_MODS
// or
//
// @ref GLFW_RAW_MOUSE_MOTION.
//
// @param window The window to query.
//
// @param mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,
// `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or
// `GLFW_RAW_MOUSE_MOTION`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref glfwSetInputMode
//
// @since Added in version 3.0.
func GetInputMode(window unsafe.Pointer, mode int32) int32 {
	__res := bindlib.CCall2(__imp_glfwGetInputMode.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(mode))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwSetInputMode bindlib.PreloadProc

// @brief Sets an input option for the specified window.
// This function sets an input mode option for the specified window.  The mode
// must be one of
// @ref GLFW_CURSOR,
//
// @ref GLFW_STICKY_KEYS,
//
// @ref GLFW_STICKY_MOUSE_BUTTONS,
//
// @ref GLFW_LOCK_KEY_MODS
//
// @ref GLFW_RAW_MOUSE_MOTION,
// or
// @ref GLFW_UNLIMITED_MOUSE_BUTTONS.
// If the mode is `GLFW_CURSOR`, the value must be one of the following cursor
// modes:
// - `GLFW_CURSOR_NORMAL` makes the cursor visible and behaving normally.
// - `GLFW_CURSOR_HIDDEN` makes the cursor invisible when it is over the
// content area of the window but does not restrict the cursor from leaving.
// - `GLFW_CURSOR_DISABLED` hides and grabs the cursor, providing virtual
// and unlimited cursor movement.  This is useful for implementing for
// example 3D camera controls.
// - `GLFW_CURSOR_CAPTURED` makes the cursor visible and confines it to the
// content area of the window.
// If the mode is `GLFW_STICKY_KEYS`, the value must be either `GLFW_TRUE` to
// enable sticky keys, or `GLFW_FALSE` to disable it.  If sticky keys are
// enabled, a key press will ensure that
// @ref glfwGetKey
// returns `GLFW_PRESS`
// the next time it is called even if the key had been released before the
// call.  This is useful when you are only interested in whether keys have been
// pressed but not when or in which order.
// If the mode is `GLFW_STICKY_MOUSE_BUTTONS`, the value must be either
// `GLFW_TRUE` to enable sticky mouse buttons, or `GLFW_FALSE` to disable it.
// If sticky mouse buttons are enabled, a mouse button press will ensure that
//
// @ref glfwGetMouseButton
// returns `GLFW_PRESS` the next time it is called even
// if the mouse button had been released before the call.  This is useful when
// you are only interested in whether mouse buttons have been pressed but not
// when or in which order.
// If the mode is `GLFW_LOCK_KEY_MODS`, the value must be either `GLFW_TRUE` to
// enable lock key modifier bits, or `GLFW_FALSE` to disable them.  If enabled,
// callbacks that receive modifier bits will also have the
// @ref GLFW_MOD_CAPS_LOCK
// bit set when the event was generated with Caps Lock on,
// and the
// @ref GLFW_MOD_NUM_LOCK
// bit when Num Lock was on.
// If the mode is `GLFW_RAW_MOUSE_MOTION`, the value must be either `GLFW_TRUE`
// to enable raw (unscaled and unaccelerated) mouse motion when the cursor is
// disabled, or `GLFW_FALSE` to disable it.  If raw motion is not supported,
// attempting to set this will emit
// @ref GLFW_FEATURE_UNAVAILABLE.
// Call
// @ref glfwRawMouseMotionSupported
// to check for support.
// If the mode is `GLFW_UNLIMITED_MOUSE_BUTTONS`, the value must be either
// `GLFW_TRUE` to disable the mouse button limit when calling the mouse button
// callback, or `GLFW_FALSE` to limit the mouse buttons sent to the callback
// to the mouse button token values up to `GLFW_MOUSE_BUTTON_LAST`.
//
// @param window The window whose input mode to set.
//
// @param mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,
// `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or
// `GLFW_RAW_MOUSE_MOTION`.
//
// @param value The new value of the specified input mode.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see above).
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref glfwGetInputMode
//
// @since Added in version 3.0.  Replaces `glfwEnable` and `glfwDisable`.
func SetInputMode(window unsafe.Pointer, mode int32, value int32) {
	bindlib.CCall3(__imp_glfwSetInputMode.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(mode), bindlib.MarshallSyscall(value))
}

var __imp_glfwRawMouseMotionSupported bindlib.PreloadProc

// @brief Returns whether raw mouse motion is supported.
// This function returns whether raw mouse motion is supported on the current
// system.  This status does not change after GLFW has been initialized so you
// only need to check this once.  If you attempt to enable raw motion on
// a system that does not support it,
// @ref GLFW_PLATFORM_ERROR
// will be emitted.
// Raw mouse motion is closer to the actual motion of the mouse across
// a surface.  It is not affected by the scaling and acceleration applied to
// the motion of the desktop cursor.  That processing is suitable for a cursor
// while raw motion is better for controlling for example a 3D camera.  Because
// of this, raw mouse motion is only provided when the cursor is disabled.
//
// @return `GLFW_TRUE` if raw mouse motion is supported on the current machine,
// or `GLFW_FALSE` otherwise.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref raw_mouse_motion
//
// @sa
// @ref glfwSetInputMode
//
// @since Added in version 3.3.
func RawMouseMotionSupported() int32 {
	__res := bindlib.CCall0(__imp_glfwRawMouseMotionSupported.Addr())
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetKeyName bindlib.PreloadProc

// @brief Returns the layout-specific name of the specified printable key.
// This function returns the name of the specified printable key, encoded as
// UTF-8.  This is typically the character that key would produce without any
// modifier keys, intended for displaying key bindings to the user.  For dead
// keys, it is typically the diacritic it would add to a character.
// __Do not use this function__ for [text input](
// @ref input_char).
// You will
// break text input for many languages even if it happens to work for yours.
// If the key is `GLFW_KEY_UNKNOWN`, the scancode is used to identify the key,
// otherwise the scancode is ignored.  If you specify a non-printable key, or
// `GLFW_KEY_UNKNOWN` and a scancode that maps to a non-printable key, this
// function returns `NULL` but does not emit an error.
// This behavior allows you to always pass in the arguments in the
// [key callback](
// @ref input_key)
// without modification.
// The printable keys are:
// - `GLFW_KEY_APOSTROPHE`
// - `GLFW_KEY_COMMA`
// - `GLFW_KEY_MINUS`
// - `GLFW_KEY_PERIOD`
// - `GLFW_KEY_SLASH`
// - `GLFW_KEY_SEMICOLON`
// - `GLFW_KEY_EQUAL`
// - `GLFW_KEY_LEFT_BRACKET`
// - `GLFW_KEY_RIGHT_BRACKET`
// - `GLFW_KEY_BACKSLASH`
// - `GLFW_KEY_WORLD_1`
// - `GLFW_KEY_WORLD_2`
// - `GLFW_KEY_0` to `GLFW_KEY_9`
// - `GLFW_KEY_A` to `GLFW_KEY_Z`
// - `GLFW_KEY_KP_0` to `GLFW_KEY_KP_9`
// - `GLFW_KEY_KP_DECIMAL`
// - `GLFW_KEY_KP_DIVIDE`
// - `GLFW_KEY_KP_MULTIPLY`
// - `GLFW_KEY_KP_SUBTRACT`
// - `GLFW_KEY_KP_ADD`
// - `GLFW_KEY_KP_EQUAL`
// Names for printable keys depend on keyboard layout, while names for
// non-printable keys are the same across layouts but depend on the application
// language and should be localized along with other user interface text.
//
// @param key The key to query, or `GLFW_KEY_UNKNOWN`.
//
// @param scancode The scancode of the key to query.
//
// @return The UTF-8 encoded, layout-specific name of the key, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_VALUE,
//
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark The contents of the returned string may change when a keyboard
// layout change event is received.
//
// @pointer
// _lifetime The returned string is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref input_key_name
//
// @since Added in version 3.2.
func GetKeyName(key int32, scancode int32) *byte {
	__res := bindlib.CCall2(__imp_glfwGetKeyName.Addr(), bindlib.MarshallSyscall(key), bindlib.MarshallSyscall(scancode))
	return bindlib.UnmarshallSyscall[*byte](__res)
}

var __imp_glfwGetKeyScancode bindlib.PreloadProc

// @brief Returns the platform-specific scancode of the specified key.
// This function returns the platform-specific scancode of the specified key.
// If the specified [key token](
// @ref keys)
// corresponds to a physical key not
// supported on the current platform then this method will return `-1`.
// Calling this function with anything other than a key token will return `-1`
// and generate a
// @ref GLFW_INVALID_ENUM
// error.
//
// @param key Any [key token](
// @ref keys).
//
// @return The platform-specific scancode for the key, or `-1` if the key is
// not supported on the current platform or an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref input_key
//
// @since Added in version 3.3.
func GetKeyScancode(key int32) int32 {
	__res := bindlib.CCall1(__imp_glfwGetKeyScancode.Addr(), bindlib.MarshallSyscall(key))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetKey bindlib.PreloadProc

// @brief Returns the last reported state of a keyboard key for the specified
// window.
// This function returns the last state reported for the specified key to the
// specified window.  The returned state is one of `GLFW_PRESS` or
// `GLFW_RELEASE`.  The action `GLFW_REPEAT` is only reported to the key callback.
// If the
// @ref GLFW_STICKY_KEYS
// input mode is enabled, this function returns
// `GLFW_PRESS` the first time you call it for a key that was pressed, even if
// that key has already been released.
// The key functions deal with physical keys, with [key tokens](
// @ref keys)
// named after their use on the standard US keyboard layout.  If you want to
// input text, use the Unicode character callback instead.
// The [modifier key bit masks](
// @ref mods)
// are not key tokens and cannot be
// used with this function.
// __Do not use this function__ to implement [text input](
// @ref input_char).
//
// @param window The desired window.
//
// @param key The desired [keyboard key](
// @ref keys).
// `GLFW_KEY_UNKNOWN` is
// not a valid key for this function.
//
// @return One of `GLFW_PRESS` or `GLFW_RELEASE`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref input_key
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter.
func GetKey(window unsafe.Pointer, key int32) int32 {
	__res := bindlib.CCall2(__imp_glfwGetKey.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(key))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetMouseButton bindlib.PreloadProc

// @brief Returns the last reported state of a mouse button for the specified
// window.
// This function returns the last state reported for the specified mouse button
// to the specified window.  The returned state is one of `GLFW_PRESS` or
// `GLFW_RELEASE`.
// If the
// @ref GLFW_STICKY_MOUSE_BUTTONS
// input mode is enabled, this function
// returns `GLFW_PRESS` the first time you call it for a mouse button that was
// pressed, even if that mouse button has already been released.
// The
// @ref GLFW_UNLIMITED_MOUSE_BUTTONS
// input mode does not effect the
// limit on buttons which can be polled with this function.
//
// @param window The desired window.
//
// @param button The desired [mouse button token](
// @ref buttons).
//
// @return One of `GLFW_PRESS` or `GLFW_RELEASE`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref input_mouse_button
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter.
func GetMouseButton(window unsafe.Pointer, button int32) int32 {
	__res := bindlib.CCall2(__imp_glfwGetMouseButton.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(button))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetCursorPos bindlib.PreloadProc

// @brief Retrieves the position of the cursor relative to the content area of
// the window.
// This function returns the position of the cursor, in screen coordinates,
// relative to the upper-left corner of the content area of the specified
// window.
// If the cursor is disabled (with `GLFW_CURSOR_DISABLED`) then the cursor
// position is unbounded and limited only by the minimum and maximum values of
// a `double`.
// The coordinate can be converted to their integer equivalents with the
// `floor` function.  Casting directly to an integer type works for positive
// coordinates, but fails for negative ones.
// Any or all of the position arguments may be `NULL`.  If an error occurs, all
// non-`NULL` position arguments will be set to zero.
//
// @param window The desired window.
//
// @param xpos Where to store the cursor x-coordinate, relative to the
// left edge of the content area, or `NULL`.
//
// @param ypos Where to store the cursor y-coordinate, relative to the to
// top edge of the content area, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref cursor_pos
//
// @sa
// @ref glfwSetCursorPos
//
// @since Added in version 3.0.  Replaces `glfwGetMousePos`.
func GetCursorPos(window unsafe.Pointer, xpos *float64, ypos *float64) {
	bindlib.CCall3(__imp_glfwGetCursorPos.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(xpos), bindlib.MarshallSyscall(ypos))
}

var __imp_glfwSetCursorPos bindlib.PreloadProc

// @brief Sets the position of the cursor, relative to the content area of the
// window.
// This function sets the position, in screen coordinates, of the cursor
// relative to the upper-left corner of the content area of the specified
// window.  The window must have input focus.  If the window does not have
// input focus when this function is called, it fails silently.
// __Do not use this function__ to implement things like camera controls.  GLFW
// already provides the `GLFW_CURSOR_DISABLED` cursor mode that hides the
// cursor, transparently re-centers it and provides unconstrained cursor
// motion.  See
// @ref glfwSetInputMode
// for more information.
// If the cursor mode is `GLFW_CURSOR_DISABLED` then the cursor position is
// unconstrained and limited only by the minimum and maximum values of
// a `double`.
//
// @param window The desired window.
//
// @param xpos The desired x-coordinate, relative to the left edge of the
// content area.
//
// @param ypos The desired y-coordinate, relative to the top edge of the
// content area.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @remark
// @wayland
// This function will only work when the cursor mode is
// `GLFW_CURSOR_DISABLED`, otherwise it will emit
// @ref GLFW_FEATURE_UNAVAILABLE.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref cursor_pos
//
// @sa
// @ref glfwGetCursorPos
//
// @since Added in version 3.0.  Replaces `glfwSetMousePos`.
func SetCursorPos(window unsafe.Pointer, xpos float64, ypos float64) {
	bindlib.CCall3(__imp_glfwSetCursorPos.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(xpos), bindlib.MarshallSyscall(ypos))
}

var __imp_glfwCreateCursor bindlib.PreloadProc

// @brief Creates a custom cursor.
// Creates a new custom cursor image that can be set for a window with
// @ref glfwSetCursor.
// The cursor can be destroyed with
// @ref glfwDestroyCursor.
// Any remaining cursors are destroyed by
// @ref glfwTerminate.
// The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight
// bits per channel with the red channel first.  They are arranged canonically
// as packed sequential rows, starting from the top-left corner.
// The cursor hotspot is specified in pixels, relative to the upper-left corner
// of the cursor image.  Like all other coordinate systems in GLFW, the X-axis
// points to the right and the Y-axis points down.
//
// @param image The desired cursor image.
//
// @param xhot The desired x-coordinate, in pixels, of the cursor hotspot.
//
// @param yhot The desired y-coordinate, in pixels, of the cursor hotspot.
//
// @return The handle of the created cursor, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_VALUE
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @pointer
// _lifetime The specified image data is copied before this function
// returns.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref cursor_object
//
// @sa
// @ref glfwDestroyCursor
//
// @sa
// @ref glfwCreateStandardCursor
//
// @since Added in version 3.1.
func CreateCursor(image unsafe.Pointer, xhot int32, yhot int32) unsafe.Pointer {
	__res := bindlib.CCall3(__imp_glfwCreateCursor.Addr(), bindlib.MarshallSyscall(image), bindlib.MarshallSyscall(xhot), bindlib.MarshallSyscall(yhot))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwCreateStandardCursor bindlib.PreloadProc

// @brief Creates a cursor with a standard shape.
// Returns a cursor with a standard shape, that can be set for a window with
//
// @ref glfwSetCursor.
// The images for these cursors come from the system
// cursor theme and their exact appearance will vary between platforms.
// Most of these shapes are guaranteed to exist on every supported platform but
// a few may not be present.  See the table below for details.
// Cursor shape                   | Windows | macOS | X11    | Wayland
// ------------------------------ | ------- | ----- | ------ | -------
//
// @ref GLFW_ARROW_CURSOR
// | Yes     | Yes   | Yes    | Yes
//
// @ref GLFW_IBEAM_CURSOR
// | Yes     | Yes   | Yes    | Yes
//
// @ref GLFW_CROSSHAIR_CURSOR
// | Yes     | Yes   | Yes    | Yes
//
// @ref GLFW_POINTING_HAND_CURSOR
// | Yes     | Yes   | Yes    | Yes
//
// @ref GLFW_RESIZE_EW_CURSOR
// | Yes     | Yes   | Yes    | Yes
//
// @ref GLFW_RESIZE_NS_CURSOR
// | Yes     | Yes   | Yes    | Yes
//
// @ref GLFW_RESIZE_NWSE_CURSOR
// | Yes     | Yes
// 1
// | Maybe
// 2
// | Maybe
// 2
//
// @ref GLFW_RESIZE_NESW_CURSOR
// | Yes     | Yes
// 1
// | Maybe
// 2
// | Maybe
// 2
//
// @ref GLFW_RESIZE_ALL_CURSOR
// | Yes     | Yes   | Yes    | Yes
//
// @ref GLFW_NOT_ALLOWED_CURSOR
// | Yes     | Yes   | Maybe
// 2
// | Maybe
// 2
// 1) This uses a private system API and may fail in the future.
// 2) This uses a newer standard that not all cursor themes support.
// If the requested shape is not available, this function emits a
// @ref GLFW_CURSOR_UNAVAILABLE
// error and returns `NULL`.
//
// @param shape One of the [standard shapes](
// @ref shapes).
//
// @return A new cursor ready to use or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM,
//
// @ref GLFW_CURSOR_UNAVAILABLE
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref cursor_standard
//
// @sa
// @ref glfwCreateCursor
//
// @since Added in version 3.1.
func CreateStandardCursor(shape int32) unsafe.Pointer {
	__res := bindlib.CCall1(__imp_glfwCreateStandardCursor.Addr(), bindlib.MarshallSyscall(shape))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwDestroyCursor bindlib.PreloadProc

// @brief Destroys a cursor.
// This function destroys a cursor previously created with
// @ref glfwCreateCursor.
// Any remaining cursors will be destroyed by
// @ref glfwTerminate.
// If the specified cursor is current for any window, that window will be
// reverted to the default cursor.  This does not affect the cursor mode.
//
// @param cursor The cursor object to destroy.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @reentrancy
// This function must not be called from a callback.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref cursor_object
//
// @sa
// @ref glfwCreateCursor
//
// @since Added in version 3.1.
func DestroyCursor(cursor unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwDestroyCursor.Addr(), bindlib.MarshallSyscall(cursor))
}

var __imp_glfwSetCursor bindlib.PreloadProc

// @brief Sets the cursor for the window.
// This function sets the cursor image to be used when the cursor is over the
// content area of the specified window.  The set cursor will only be visible
// when the [cursor mode](
// @ref cursor_mode)
// of the window is
// `GLFW_CURSOR_NORMAL`.
// On some platforms, the set cursor may not be visible unless the window also
// has input focus.
//
// @param window The window to set the cursor for.
//
// @param cursor The cursor to set, or `NULL` to switch back to the default
// arrow cursor.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref cursor_object
//
// @since Added in version 3.1.
func SetCursor(window unsafe.Pointer, cursor unsafe.Pointer) {
	bindlib.CCall2(__imp_glfwSetCursor.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(cursor))
}

var __imp_glfwSetKeyCallback bindlib.PreloadProc

// @brief Sets the key callback.
// This function sets the key callback of the specified window, which is called
// when a key is pressed, repeated or released.
// The key functions deal with physical keys, with layout independent
// [key tokens](
// @ref keys)
// named after their values in the standard US keyboard
// layout.  If you want to input text, use the
// [character callback](
// @ref glfwSetCharCallback)
// instead.
// When a window loses input focus, it will generate synthetic key release
// events for all pressed keys with associated key tokens.  You can tell these
// events from user-generated events by the fact that the synthetic ones are
// generated after the focus loss event has been processed, i.e. after the
// [window focus callback](
// @ref glfwSetWindowFocusCallback)
// has been called.
// The scancode of a key is specific to that platform or sometimes even to that
// machine.  Scancodes are intended to allow users to bind keys that don't have
// a GLFW key token.  Such keys have `key` set to `GLFW_KEY_UNKNOWN`, their
// state is not saved and so it cannot be queried with
// @ref glfwGetKey.
// Sometimes GLFW needs to generate synthetic key events, in which case the
// scancode may be zero.
//
// @param window The window whose callback to set.
//
// @param callback The new key callback, or `NULL` to remove the currently
// set callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWkeyfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref input_key
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter and return value.
func SetKeyCallback(window unsafe.Pointer, callback Keyfun) Keyfun {
	__res := bindlib.CCall2(__imp_glfwSetKeyCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Keyfun](__res)
}

var __imp_glfwSetCharCallback bindlib.PreloadProc

// @brief Sets the Unicode character callback.
// This function sets the character callback of the specified window, which is
// called when a Unicode character is input.
// The character callback is intended for Unicode text input.  As it deals with
// characters, it is keyboard layout dependent, whereas the
// [key callback](
// @ref glfwSetKeyCallback)
// is not.  Characters do not map 1:1
// to physical keys, as a key may produce zero, one or more characters.  If you
// want to know whether a specific physical key was pressed or released, see
// the key callback instead.
// The character callback behaves as system text input normally does and will
// not be called if modifier keys are held down that would prevent normal text
// input on that platform, for example a Super (Command) key on macOS or Alt key
// on Windows.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWcharfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref input_char
//
// @since Added in version 2.4.
//
// @glfw3
// Added window handle parameter and return value.
func SetCharCallback(window unsafe.Pointer, callback Charfun) Charfun {
	__res := bindlib.CCall2(__imp_glfwSetCharCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Charfun](__res)
}

var __imp_glfwSetCharModsCallback bindlib.PreloadProc

// @brief Sets the Unicode character with modifiers callback.
// This function sets the character with modifiers callback of the specified
// window, which is called when a Unicode character is input regardless of what
// modifier keys are used.
// The character with modifiers callback is intended for implementing custom
// Unicode character input.  For regular Unicode text input, see the
// [character callback](
// @ref glfwSetCharCallback).
// Like the character
// callback, the character with modifiers callback deals with characters and is
// keyboard layout dependent.  Characters do not map 1:1 to physical keys, as
// a key may produce zero, one or more characters.  If you want to know whether
// a specific physical key was pressed or released, see the
// [key callback](
// @ref glfwSetKeyCallback)
// instead.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or an
// [error](
// @ref error_handling)
// occurred.
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWcharmodsfun).
//
// @deprecated Scheduled for removal in version 4.0.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref input_char
//
// @since Added in version 3.1.
func SetCharModsCallback(window unsafe.Pointer, callback Charmodsfun) Charmodsfun {
	__res := bindlib.CCall2(__imp_glfwSetCharModsCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Charmodsfun](__res)
}

var __imp_glfwSetMouseButtonCallback bindlib.PreloadProc

// @brief Sets the mouse button callback.
// This function sets the mouse button callback of the specified window, which
// is called when a mouse button is pressed or released.
// When a window loses input focus, it will generate synthetic mouse button
// release events for all pressed mouse buttons with associated button tokens.
// You can tell these events from user-generated events by the fact that the
// synthetic ones are generated after the focus loss event has been processed,
// i.e. after the [window focus callback](
// @ref glfwSetWindowFocusCallback)
// has
// been called.
// The reported `button` value can be higher than `GLFW_MOUSE_BUTTON_LAST` if
// the button does not have an associated [button token](
// @ref buttons)
// and the
//
// @ref GLFW_UNLIMITED_MOUSE_BUTTONS
// input mode is set.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWmousebuttonfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref input_mouse_button
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter and return value.
func SetMouseButtonCallback(window unsafe.Pointer, callback Mousebuttonfun) Mousebuttonfun {
	__res := bindlib.CCall2(__imp_glfwSetMouseButtonCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Mousebuttonfun](__res)
}

var __imp_glfwSetCursorPosCallback bindlib.PreloadProc

// @brief Sets the cursor position callback.
// This function sets the cursor position callback of the specified window,
// which is called when the cursor is moved.  The callback is provided with the
// position, in screen coordinates, relative to the upper-left corner of the
// content area of the window.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWcursorposfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref cursor_pos
//
// @since Added in version 3.0.  Replaces `glfwSetMousePosCallback`.
func SetCursorPosCallback(window unsafe.Pointer, callback Cursorposfun) Cursorposfun {
	__res := bindlib.CCall2(__imp_glfwSetCursorPosCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Cursorposfun](__res)
}

var __imp_glfwSetCursorEnterCallback bindlib.PreloadProc

// @brief Sets the cursor enter/leave callback.
// This function sets the cursor boundary crossing callback of the specified
// window, which is called when the cursor enters or leaves the content area of
// the window.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWcursorenterfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref cursor_enter
//
// @since Added in version 3.0.
func SetCursorEnterCallback(window unsafe.Pointer, callback Cursorenterfun) Cursorenterfun {
	__res := bindlib.CCall2(__imp_glfwSetCursorEnterCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Cursorenterfun](__res)
}

var __imp_glfwSetScrollCallback bindlib.PreloadProc

// @brief Sets the scroll callback.
// This function sets the scroll callback of the specified window, which is
// called when a scrolling device is used, such as a mouse wheel or scrolling
// area of a touchpad.
// The scroll callback receives all scrolling input, like that from a mouse
// wheel or a touchpad scrolling area.
//
// @param window The window whose callback to set.
//
// @param callback The new scroll callback, or `NULL` to remove the
// currently set callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWscrollfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref scrolling
//
// @since Added in version 3.0.  Replaces `glfwSetMouseWheelCallback`.
func SetScrollCallback(window unsafe.Pointer, callback Scrollfun) Scrollfun {
	__res := bindlib.CCall2(__imp_glfwSetScrollCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Scrollfun](__res)
}

var __imp_glfwSetDropCallback bindlib.PreloadProc

// @brief Sets the path drop callback.
// This function sets the path drop callback of the specified window, which is
// called when one or more dragged paths are dropped on the window.
// Because the path array and its strings may have been generated specifically
// for that event, they are not guaranteed to be valid after the callback has
// returned.  If you wish to use them after the callback returns, you need to
// make a deep copy.
//
// @param window The window whose callback to set.
//
// @param callback The new file drop callback, or `NULL` to remove the
// currently set callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWdropfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref path_drop
//
// @since Added in version 3.1.
func SetDropCallback(window unsafe.Pointer, callback Dropfun) Dropfun {
	__res := bindlib.CCall2(__imp_glfwSetDropCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Dropfun](__res)
}

var __imp_glfwJoystickPresent bindlib.PreloadProc

// @brief Returns whether the specified joystick is present.
// This function returns whether the specified joystick is present.
// There is no need to call this function before other functions that accept
// a joystick ID, as they all check for presence before performing any other
// work.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @return `GLFW_TRUE` if the joystick is present, or `GLFW_FALSE` otherwise.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref joystick
//
// @since Added in version 3.0.  Replaces `glfwGetJoystickParam`.
func JoystickPresent(jid int32) int32 {
	__res := bindlib.CCall1(__imp_glfwJoystickPresent.Addr(), bindlib.MarshallSyscall(jid))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetJoystickAxes bindlib.PreloadProc

// @brief Returns the values of all axes of the specified joystick.
// This function returns the values of all axes of the specified joystick.
// Each element in the array is a value between -1.0 and 1.0.
// If the specified joystick is not present this function will return `NULL`
// but will not generate an error.  This can be used instead of first calling
//
// @ref glfwJoystickPresent.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @param count Where to store the number of axis values in the returned
// array.  This is set to zero if the joystick is not present or an error
// occurred.
//
// @return An array of axis values, or `NULL` if the joystick is not present or
// an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @pointer
// _lifetime The returned array is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified joystick is
// disconnected or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref joystick_axis
//
// @since Added in version 3.0.  Replaces `glfwGetJoystickPos`.
func GetJoystickAxes(jid int32, count *int32) *float32 {
	__res := bindlib.CCall2(__imp_glfwGetJoystickAxes.Addr(), bindlib.MarshallSyscall(jid), bindlib.MarshallSyscall(count))
	return bindlib.UnmarshallSyscall[*float32](__res)
}

var __imp_glfwGetJoystickButtons bindlib.PreloadProc

// @brief Returns the state of all buttons of the specified joystick.
// This function returns the state of all buttons of the specified joystick.
// Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`.
// For backward compatibility with earlier versions that did not have
// @ref glfwGetJoystickHats,
// the button array also includes all hats, each
// represented as four buttons.  The hats are in the same order as returned by
// __glfwGetJoystickHats__ and are in the order _up_, _right_, _down_ and
// _left_.  To disable these extra buttons, set the
// @ref GLFW_JOYSTICK_HAT_BUTTONS
// init hint before initialization.
// If the specified joystick is not present this function will return `NULL`
// but will not generate an error.  This can be used instead of first calling
//
// @ref glfwJoystickPresent.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @param count Where to store the number of button states in the returned
// array.  This is set to zero if the joystick is not present or an error
// occurred.
//
// @return An array of button states, or `NULL` if the joystick is not present
// or an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @pointer
// _lifetime The returned array is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified joystick is
// disconnected or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref joystick_button
//
// @since Added in version 2.2.
//
// @glfw3
// Changed to return a dynamic array.
func GetJoystickButtons(jid int32, count *int32) *uint8 {
	__res := bindlib.CCall2(__imp_glfwGetJoystickButtons.Addr(), bindlib.MarshallSyscall(jid), bindlib.MarshallSyscall(count))
	return bindlib.UnmarshallSyscall[*uint8](__res)
}

var __imp_glfwGetJoystickHats bindlib.PreloadProc

// @brief Returns the state of all hats of the specified joystick.
// This function returns the state of all hats of the specified joystick.
// Each element in the array is one of the following values:
// Name                  | Value
// ----                  | -----
// `GLFW_HAT_CENTERED`   | 0
// `GLFW_HAT_UP`         | 1
// `GLFW_HAT_RIGHT`      | 2
// `GLFW_HAT_DOWN`       | 4
// `GLFW_HAT_LEFT`       | 8
// `GLFW_HAT_RIGHT_UP`   | `GLFW_HAT_RIGHT`
// \
// | `GLFW_HAT_UP`
// `GLFW_HAT_RIGHT_DOWN` | `GLFW_HAT_RIGHT`
// \
// | `GLFW_HAT_DOWN`
// `GLFW_HAT_LEFT_UP`    | `GLFW_HAT_LEFT`
// \
// | `GLFW_HAT_UP`
// `GLFW_HAT_LEFT_DOWN`  | `GLFW_HAT_LEFT`
// \
// | `GLFW_HAT_DOWN`
// The diagonal directions are bitwise combinations of the primary (up, right,
// down and left) directions and you can test for these individually by ANDing
// it with the corresponding direction.
//
// If the specified joystick is not present this function will return `NULL`
// but will not generate an error.  This can be used instead of first calling
//
// @ref glfwJoystickPresent.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @param count Where to store the number of hat states in the returned
// array.  This is set to zero if the joystick is not present or an error
// occurred.
//
// @return An array of hat states, or `NULL` if the joystick is not present
// or an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @pointer
// _lifetime The returned array is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified joystick is
// disconnected, this function is called again for that joystick or the library
// is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref joystick_hat
//
// @since Added in version 3.3.
func GetJoystickHats(jid int32, count *int32) *uint8 {
	__res := bindlib.CCall2(__imp_glfwGetJoystickHats.Addr(), bindlib.MarshallSyscall(jid), bindlib.MarshallSyscall(count))
	return bindlib.UnmarshallSyscall[*uint8](__res)
}

var __imp_glfwGetJoystickName bindlib.PreloadProc

// @brief Returns the name of the specified joystick.
// This function returns the name, encoded as UTF-8, of the specified joystick.
// The returned string is allocated and freed by GLFW.  You should not free it
// yourself.
// If the specified joystick is not present this function will return `NULL`
// but will not generate an error.  This can be used instead of first calling
//
// @ref glfwJoystickPresent.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @return The UTF-8 encoded name of the joystick, or `NULL` if the joystick
// is not present or an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @pointer
// _lifetime The returned string is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified joystick is
// disconnected or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref joystick_name
//
// @since Added in version 3.0.
func GetJoystickName(jid int32) *byte {
	__res := bindlib.CCall1(__imp_glfwGetJoystickName.Addr(), bindlib.MarshallSyscall(jid))
	return bindlib.UnmarshallSyscall[*byte](__res)
}

var __imp_glfwGetJoystickGUID bindlib.PreloadProc

// @brief Returns the SDL compatible GUID of the specified joystick.
// This function returns the SDL compatible GUID, as a UTF-8 encoded
// hexadecimal string, of the specified joystick.  The returned string is
// allocated and freed by GLFW.  You should not free it yourself.
// The GUID is what connects a joystick to a gamepad mapping.  A connected
// joystick will always have a GUID even if there is no gamepad mapping
// assigned to it.
// If the specified joystick is not present this function will return `NULL`
// but will not generate an error.  This can be used instead of first calling
//
// @ref glfwJoystickPresent.
// The GUID uses the format introduced in SDL 2.0.5.  This GUID tries to
// uniquely identify the make and model of a joystick but does not identify
// a specific unit, e.g. all wired Xbox 360 controllers will have the same
// GUID on that platform.  The GUID for a unit may vary between platforms
// depending on what hardware information the platform specific APIs provide.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @return The UTF-8 encoded GUID of the joystick, or `NULL` if the joystick
// is not present or an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @pointer
// _lifetime The returned string is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified joystick is
// disconnected or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref gamepad
//
// @since Added in version 3.3.
func GetJoystickGUID(jid int32) *byte {
	__res := bindlib.CCall1(__imp_glfwGetJoystickGUID.Addr(), bindlib.MarshallSyscall(jid))
	return bindlib.UnmarshallSyscall[*byte](__res)
}

var __imp_glfwSetJoystickUserPointer bindlib.PreloadProc

// @brief Sets the user pointer of the specified joystick.
// This function sets the user-defined pointer of the specified joystick.  The
// current value is retained until the joystick is disconnected.  The initial
// value is `NULL`.
// This function may be called from the joystick callback, even for a joystick
// that is being disconnected.
//
// @param jid The joystick whose pointer to set.
//
// @param pointer The new value.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Access is not
// synchronized.
//
// @sa
// @ref joystick_userptr
//
// @sa
// @ref glfwGetJoystickUserPointer
//
// @since Added in version 3.3.
func SetJoystickUserPointer(jid int32, pointer unsafe.Pointer) {
	bindlib.CCall2(__imp_glfwSetJoystickUserPointer.Addr(), bindlib.MarshallSyscall(jid), bindlib.MarshallSyscall(pointer))
}

var __imp_glfwGetJoystickUserPointer bindlib.PreloadProc

// @brief Returns the user pointer of the specified joystick.
// This function returns the current value of the user-defined pointer of the
// specified joystick.  The initial value is `NULL`.
// This function may be called from the joystick callback, even for a joystick
// that is being disconnected.
//
// @param jid The joystick whose pointer to return.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Access is not
// synchronized.
//
// @sa
// @ref joystick_userptr
//
// @sa
// @ref glfwSetJoystickUserPointer
//
// @since Added in version 3.3.
func GetJoystickUserPointer(jid int32) unsafe.Pointer {
	__res := bindlib.CCall1(__imp_glfwGetJoystickUserPointer.Addr(), bindlib.MarshallSyscall(jid))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwJoystickIsGamepad bindlib.PreloadProc

// @brief Returns whether the specified joystick has a gamepad mapping.
// This function returns whether the specified joystick is both present and has
// a gamepad mapping.
// If the specified joystick is present but does not have a gamepad mapping
// this function will return `GLFW_FALSE` but will not generate an error.  Call
//
// @ref glfwJoystickPresent
// to check if a joystick is present regardless of
// whether it has a mapping.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @return `GLFW_TRUE` if a joystick is both present and has a gamepad mapping,
// or `GLFW_FALSE` otherwise.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref gamepad
//
// @sa
// @ref glfwGetGamepadState
//
// @since Added in version 3.3.
func JoystickIsGamepad(jid int32) int32 {
	__res := bindlib.CCall1(__imp_glfwJoystickIsGamepad.Addr(), bindlib.MarshallSyscall(jid))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwSetJoystickCallback bindlib.PreloadProc

// @brief Sets the joystick configuration callback.
// This function sets the joystick configuration callback, or removes the
// currently set callback.  This is called when a joystick is connected to or
// disconnected from the system.
// For joystick connection and disconnection events to be delivered on all
// platforms, you need to call one of the [event processing](
// @ref events)
// functions.  Joystick disconnection may also be detected and the callback
// called by joystick functions.  The function will then return whatever it
// returns if the joystick is not present.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWjoystickfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref joystick_event
//
// @since Added in version 3.2.
func SetJoystickCallback(callback Joystickfun) Joystickfun {
	__res := bindlib.CCall1(__imp_glfwSetJoystickCallback.Addr(), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Joystickfun](__res)
}

var __imp_glfwUpdateGamepadMappings bindlib.PreloadProc

// @brief Adds the specified SDL_GameControllerDB gamepad mappings.
// This function parses the specified ASCII encoded string and updates the
// internal list with any gamepad mappings it finds.  This string may
// contain either a single gamepad mapping or many mappings separated by
// newlines.  The parser supports the full format of the `gamecontrollerdb.txt`
// source file including empty lines and comments.
// See
// @ref gamepad_mapping
// for a description of the format.
// If there is already a gamepad mapping for a given GUID in the internal list,
// it will be replaced by the one passed to this function.  If the library is
// terminated and re-initialized the internal list will revert to the built-in
// default.
//
// @param string The string containing the gamepad mappings.
//
// @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_VALUE.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref gamepad
//
// @sa
// @ref glfwJoystickIsGamepad
//
// @sa
// @ref glfwGetGamepadName
//
// @since Added in version 3.3.
func UpdateGamepadMappings(_string *byte) int32 {
	__res := bindlib.CCall1(__imp_glfwUpdateGamepadMappings.Addr(), bindlib.MarshallSyscall(_string))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetGamepadName bindlib.PreloadProc

// @brief Returns the human-readable gamepad name for the specified joystick.
// This function returns the human-readable name of the gamepad from the
// gamepad mapping assigned to the specified joystick.
// If the specified joystick is not present or does not have a gamepad mapping
// this function will return `NULL` but will not generate an error.  Call
//
// @ref glfwJoystickPresent
// to check whether it is present regardless of
// whether it has a mapping.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @return The UTF-8 encoded name of the gamepad, or `NULL` if the
// joystick is not present, does not have a mapping or an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @pointer
// _lifetime The returned string is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified joystick is
// disconnected, the gamepad mappings are updated or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref gamepad
//
// @sa
// @ref glfwJoystickIsGamepad
//
// @since Added in version 3.3.
func GetGamepadName(jid int32) *byte {
	__res := bindlib.CCall1(__imp_glfwGetGamepadName.Addr(), bindlib.MarshallSyscall(jid))
	return bindlib.UnmarshallSyscall[*byte](__res)
}

var __imp_glfwGetGamepadState bindlib.PreloadProc

// @brief Retrieves the state of the specified joystick remapped as a gamepad.
// This function retrieves the state of the specified joystick remapped to
// an Xbox-like gamepad.
// If the specified joystick is not present or does not have a gamepad mapping
// this function will return `GLFW_FALSE` but will not generate an error.  Call
//
// @ref glfwJoystickPresent
// to check whether it is present regardless of
// whether it has a mapping.
// The Guide button may not be available for input as it is often hooked by the
// system or the Steam client.
// Not all devices have all the buttons or axes provided by
// @ref GLFWgamepadstate.
// Unavailable buttons and axes will always report
// `GLFW_RELEASE` and 0.0 respectively.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @param state The gamepad input state of the joystick.
//
// @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if no joystick is
// connected, it has no gamepad mapping or an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref gamepad
//
// @sa
// @ref glfwUpdateGamepadMappings
//
// @sa
// @ref glfwJoystickIsGamepad
//
// @since Added in version 3.3.
func GetGamepadState(jid int32, state unsafe.Pointer) int32 {
	__res := bindlib.CCall2(__imp_glfwGetGamepadState.Addr(), bindlib.MarshallSyscall(jid), bindlib.MarshallSyscall(state))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwSetClipboardString bindlib.PreloadProc

// @brief Sets the clipboard to the specified string.
// This function sets the system clipboard to the specified, UTF-8 encoded
// string.
//
// @param window Deprecated.  Any valid window or `NULL`.
//
// @param string A UTF-8 encoded string.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @win32
// The clipboard on Windows has a single global lock for reading and
// writing.  GLFW tries to acquire it a few times, which is almost always enough.  If it
// cannot acquire the lock then this function emits
// @ref GLFW_PLATFORM_ERROR
// and returns.
// It is safe to try this multiple times.
//
// @pointer
// _lifetime The specified string is copied before this function
// returns.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref clipboard
//
// @sa
// @ref glfwGetClipboardString
//
// @since Added in version 3.0.
func SetClipboardString(window unsafe.Pointer, _string *byte) {
	bindlib.CCall2(__imp_glfwSetClipboardString.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(_string))
}

var __imp_glfwGetClipboardString bindlib.PreloadProc

// @brief Returns the contents of the clipboard as a string.
// This function returns the contents of the system clipboard, if it contains
// or is convertible to a UTF-8 encoded string.  If the clipboard is empty or
// if its contents cannot be converted, `NULL` is returned and a
// @ref GLFW_FORMAT_UNAVAILABLE
// error is generated.
//
// @param window Deprecated.  Any valid window or `NULL`.
//
// @return The contents of the clipboard as a UTF-8 encoded string, or `NULL`
// if an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_FORMAT_UNAVAILABLE
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @win32
// The clipboard on Windows has a single global lock for reading and
// writing.  GLFW tries to acquire it a few times, which is almost always enough.  If it
// cannot acquire the lock then this function emits
// @ref GLFW_PLATFORM_ERROR
// and returns.
// It is safe to try this multiple times.
//
// @pointer
// _lifetime The returned string is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the next call to
// @ref glfwGetClipboardString
// or
// @ref glfwSetClipboardString,
// or until the library
// is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref clipboard
//
// @sa
// @ref glfwSetClipboardString
//
// @since Added in version 3.0.
func GetClipboardString(window unsafe.Pointer) *byte {
	__res := bindlib.CCall1(__imp_glfwGetClipboardString.Addr(), bindlib.MarshallSyscall(window))
	return bindlib.UnmarshallSyscall[*byte](__res)
}

var __imp_glfwGetTime bindlib.PreloadProc

// @brief Returns the GLFW time.
// This function returns the current GLFW time, in seconds.  Unless the time
// has been set using
// @ref glfwSetTime
// it measures time elapsed since GLFW was
// initialized.
// This function and
// @ref glfwSetTime
// are helper functions on top of
// @ref glfwGetTimerFrequency
// and
// @ref glfwGetTimerValue.
// The resolution of the timer is system dependent, but is usually on the order
// of a few micro- or nanoseconds.  It uses the highest-resolution monotonic
// time source on each operating system.
//
// @return The current time, in seconds, or zero if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Reading and
// writing of the internal base time is not atomic, so it needs to be
// externally synchronized with calls to
// @ref glfwSetTime.
//
// @sa
// @ref time
//
// @since Added in version 1.0.
func GetTime() float64 {
	__res := bindlib.CCall0(__imp_glfwGetTime.Addr())
	return bindlib.UnmarshallSyscall[float64](__res)
}

var __imp_glfwSetTime bindlib.PreloadProc

// @brief Sets the GLFW time.
// This function sets the current GLFW time, in seconds.  The value must be
// a positive finite number less than or equal to 18446744073.0, which is
// approximately 584.5 years.
// This function and
// @ref glfwGetTime
// are helper functions on top of
// @ref glfwGetTimerFrequency
// and
// @ref glfwGetTimerValue.
//
// @param time The new value, in seconds.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_VALUE.
//
// @remark The upper limit of GLFW time is calculated as
// floor((2
// 64
// - 1) / 10
// 9
// ) and is due to implementations
// storing nanoseconds in 64 bits.  The limit may be increased in the future.
//
// @thread
// _safety This function may be called from any thread.  Reading and
// writing of the internal base time is not atomic, so it needs to be
// externally synchronized with calls to
// @ref glfwGetTime.
//
// @sa
// @ref time
//
// @since Added in version 2.2.
func SetTime(time float64) { bindlib.CCall1(__imp_glfwSetTime.Addr(), bindlib.MarshallSyscall(time)) }

var __imp_glfwGetTimerValue bindlib.PreloadProc

// @brief Returns the current value of the raw timer.
// This function returns the current value of the raw timer, measured in
// 1
//
// /
//
// frequency seconds.  To get the frequency, call
// @ref glfwGetTimerFrequency.
//
// @return The value of the timer, or zero if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref time
//
// @sa
// @ref glfwGetTimerFrequency
//
// @since Added in version 3.2.
func GetTimerValue() uint64 {
	__res := bindlib.CCall0(__imp_glfwGetTimerValue.Addr())
	return bindlib.UnmarshallSyscall[uint64](__res)
}

var __imp_glfwGetTimerFrequency bindlib.PreloadProc

// @brief Returns the frequency, in Hz, of the raw timer.
// This function returns the frequency, in Hz, of the raw timer.
//
// @return The frequency of the timer, in Hz, or zero if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref time
//
// @sa
// @ref glfwGetTimerValue
//
// @since Added in version 3.2.
func GetTimerFrequency() uint64 {
	__res := bindlib.CCall0(__imp_glfwGetTimerFrequency.Addr())
	return bindlib.UnmarshallSyscall[uint64](__res)
}

var __imp_glfwMakeContextCurrent bindlib.PreloadProc

// @brief Makes the context of the specified window current for the calling
// thread.
// This function makes the OpenGL or OpenGL ES context of the specified window
// current on the calling thread.  It can also detach the current context from
// the calling thread without making a new one current by passing in `NULL`.
// A context must only be made current on a single thread at a time and each
// thread can have only a single current context at a time.  Making a context
// current detaches any previously current context on the calling thread.
// When moving a context between threads, you must detach it (make it
// non-current) on the old thread before making it current on the new one.
// By default, making a context non-current implicitly forces a pipeline flush.
// On machines that support `GL_KHR_context_flush_control`, you can control
// whether a context performs this flush by setting the
// [GLFW_CONTEXT_RELEASE_BEHAVIOR](
// @ref GLFW_CONTEXT_RELEASE_BEHAVIOR_hint)
// hint.
// The specified window must have an OpenGL or OpenGL ES context.  Specifying
// a window without a context will generate a
// @ref GLFW_NO_WINDOW_CONTEXT
// error.
//
// @param window The window whose context to make current, or `NULL` to
// detach the current context.
//
// @remarks If the previously current context was created via a different
// context creation API than the one passed to this function, GLFW will still
// detach the previous one from its API before making the new one current.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_NO_WINDOW_CONTEXT
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref context_current
//
// @sa
// @ref glfwGetCurrentContext
//
// @since Added in version 3.0.
func MakeContextCurrent(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwMakeContextCurrent.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwGetCurrentContext bindlib.PreloadProc

// @brief Returns the window whose context is current on the calling thread.
// This function returns the window whose OpenGL or OpenGL ES context is
// current on the calling thread.
//
// @return The window whose context is current, or `NULL` if no window's
// context is current.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref context_current
//
// @sa
// @ref glfwMakeContextCurrent
//
// @since Added in version 3.0.
func GetCurrentContext() unsafe.Pointer {
	__res := bindlib.CCall0(__imp_glfwGetCurrentContext.Addr())
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwSwapBuffers bindlib.PreloadProc

// @brief Swaps the front and back buffers of the specified window.
// This function swaps the front and back buffers of the specified window when
// rendering with OpenGL or OpenGL ES.  If the swap interval is greater than
// zero, the GPU driver waits the specified number of screen updates before
// swapping the buffers.
// The specified window must have an OpenGL or OpenGL ES context.  Specifying
// a window without a context will generate a
// @ref GLFW_NO_WINDOW_CONTEXT
// error.
// This function does not apply to Vulkan.  If you are rendering with Vulkan,
// see `vkQueuePresentKHR` instead.
//
// @param window The window whose buffers to swap.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_NO_WINDOW_CONTEXT
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark __EGL:__ The context of the specified window must be current on the
// calling thread.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref buffer_swap
//
// @sa
// @ref glfwSwapInterval
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter.
func SwapBuffers(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwSwapBuffers.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwSwapInterval bindlib.PreloadProc

// @brief Sets the swap interval for the current context.
// This function sets the swap interval for the current OpenGL or OpenGL ES
// context, i.e. the number of screen updates to wait from the time
// @ref glfwSwapBuffers
// was called before swapping the buffers and returning.  This
// is sometimes called _vertical synchronization_, _vertical retrace
// synchronization_ or just _vsync_.
// A context that supports either of the `WGL_EXT_swap_control_tear` and
// `GLX_EXT_swap_control_tear` extensions also accepts _negative_ swap
// intervals, which allows the driver to swap immediately even if a frame
// arrives a little bit late.  You can check for these extensions with
// @ref glfwExtensionSupported.
// A context must be current on the calling thread.  Calling this function
// without a current context will cause a
// @ref GLFW_NO_CURRENT_CONTEXT
// error.
// This function does not apply to Vulkan.  If you are rendering with Vulkan,
// see the present mode of your swapchain instead.
//
// @param interval The minimum number of screen updates to wait for
// until the buffers are swapped by
// @ref glfwSwapBuffers.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_NO_CURRENT_CONTEXT
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark This function is not called during context creation, leaving the
// swap interval set to whatever is the default for that API.  This is done
// because some swap interval extensions used by GLFW do not allow the swap
// interval to be reset to zero once it has been set to a non-zero value.
//
// @remark Some GPU drivers do not honor the requested swap interval, either
// because of a user setting that overrides the application's request or due to
// bugs in the driver.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref buffer_swap
//
// @sa
// @ref glfwSwapBuffers
//
// @since Added in version 1.0.
func SwapInterval(interval int32) {
	bindlib.CCall1(__imp_glfwSwapInterval.Addr(), bindlib.MarshallSyscall(interval))
}

var __imp_glfwExtensionSupported bindlib.PreloadProc

// @brief Returns whether the specified extension is available.
// This function returns whether the specified
// [API extension](
// @ref context_glext)
// is supported by the current OpenGL or
// OpenGL ES context.  It searches both for client API extension and context
// creation API extensions.
// A context must be current on the calling thread.  Calling this function
// without a current context will cause a
// @ref GLFW_NO_CURRENT_CONTEXT
// error.
// As this functions retrieves and searches one or more extension strings each
// call, it is recommended that you cache its results if it is going to be used
// frequently.  The extension strings will not change during the lifetime of
// a context, so there is no danger in doing this.
// This function does not apply to Vulkan.  If you are using Vulkan, see
// @ref glfwGetRequiredInstanceExtensions,
// `vkEnumerateInstanceExtensionProperties`
// and `vkEnumerateDeviceExtensionProperties` instead.
//
// @param extension The ASCII encoded name of the extension.
//
// @return `GLFW_TRUE` if the extension is available, or `GLFW_FALSE`
// otherwise.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_NO_CURRENT_CONTEXT,
//
// @ref GLFW_INVALID_VALUE
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref context_glext
//
// @sa
// @ref glfwGetProcAddress
//
// @since Added in version 1.0.
func ExtensionSupported(extension *byte) int32 {
	__res := bindlib.CCall1(__imp_glfwExtensionSupported.Addr(), bindlib.MarshallSyscall(extension))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetProcAddress bindlib.PreloadProc

// @brief Returns the address of the specified function for the current
// context.
// This function returns the address of the specified OpenGL or OpenGL ES
// [core or extension function](
// @ref context_glext),
// if it is supported
// by the current context.
// A context must be current on the calling thread.  Calling this function
// without a current context will cause a
// @ref GLFW_NO_CURRENT_CONTEXT
// error.
// This function does not apply to Vulkan.  If you are rendering with Vulkan,
// see
// @ref glfwGetInstanceProcAddress,
// `vkGetInstanceProcAddr` and
// `vkGetDeviceProcAddr` instead.
//
// @param procname The ASCII encoded name of the function.
//
// @return The address of the function, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_NO_CURRENT_CONTEXT
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark The address of a given function is not guaranteed to be the same
// between contexts.
//
// @remark This function may return a non-`NULL` address despite the
// associated version or extension not being available.  Always check the
// context version or extension string first.
//
// @pointer
// _lifetime The returned function pointer is valid until the context
// is destroyed or the library is terminated.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref context_glext
//
// @sa
// @ref glfwExtensionSupported
//
// @since Added in version 1.0.
func GetProcAddress(procname *byte) Glproc {
	__res := bindlib.CCall1(__imp_glfwGetProcAddress.Addr(), bindlib.MarshallSyscall(procname))
	return bindlib.UnmarshallSyscall[Glproc](__res)
}

var __imp_glfwVulkanSupported bindlib.PreloadProc

// @brief Returns whether the Vulkan loader and an ICD have been found.
// This function returns whether the Vulkan loader and any minimally functional
// ICD have been found.
// The availability of a Vulkan loader and even an ICD does not by itself guarantee that
// surface creation or even instance creation is possible.  Call
// @ref glfwGetRequiredInstanceExtensions
// to check whether the extensions necessary for Vulkan
// surface creation are available and
// @ref glfwGetPhysicalDevicePresentationSupport
// to
// check whether a queue family of a physical device supports image presentation.
//
// @return `GLFW_TRUE` if Vulkan is minimally available, or `GLFW_FALSE`
// otherwise.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref vulkan_support
//
// @since Added in version 3.2.
func VulkanSupported() int32 {
	__res := bindlib.CCall0(__imp_glfwVulkanSupported.Addr())
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetRequiredInstanceExtensions bindlib.PreloadProc

// @brief Returns the Vulkan instance extensions required by GLFW.
// This function returns an array of names of Vulkan instance extensions required
// by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the
// list will always contain `VK_KHR_surface`, so if you don't require any
// additional extensions you can pass this list directly to the
// `VkInstanceCreateInfo` struct.
// If Vulkan is not available on the machine, this function returns `NULL` and
// generates a
// @ref GLFW_API_UNAVAILABLE
// error.  Call
// @ref glfwVulkanSupported
// to check whether Vulkan is at least minimally available.
// If Vulkan is available but no set of extensions allowing window surface
// creation was found, this function returns `NULL`.  You may still use Vulkan
// for off-screen rendering and compute work.
//
// @param count Where to store the number of extensions in the returned
// array.  This is set to zero if an error occurred.
//
// @return An array of ASCII encoded extension names, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_API_UNAVAILABLE.
//
// @remark Additional extensions may be required by future versions of GLFW.
// You should check if any extensions you wish to enable are already in the
// returned array, as it is an error to specify an extension more than once in
// the `VkInstanceCreateInfo` struct.
//
// @pointer
// _lifetime The returned array is allocated and freed by GLFW.  You
// should not free it yourself.  It is guaranteed to be valid only until the
// library is terminated.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref vulkan_ext
//
// @sa
// @ref glfwCreateWindowSurface
//
// @since Added in version 3.2.
func GetRequiredInstanceExtensions(count *uint32) **byte {
	__res := bindlib.CCall1(__imp_glfwGetRequiredInstanceExtensions.Addr(), bindlib.MarshallSyscall(count))
	return bindlib.UnmarshallSyscall[**byte](__res)
}
