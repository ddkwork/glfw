// Code generated by bindgen. DO NOT EDIT.
package glfw

import (
	"unsafe"

	"github.com/ddkwork/app/bindgen/bindlib"
)

const GengoLibraryName = "glfw"

var GengoLibrary = bindlib.NewLibrary(GengoLibraryName)

type Vidmode struct {
	// The width, in screen coordinates, of the video mode.
	Width int32
	// The height, in screen coordinates, of the video mode.
	Height int32
	// The bit depth of the red channel of the video mode.
	redBits int32
	// The bit depth of the green channel of the video mode.
	greenBits int32
	// The bit depth of the blue channel of the video mode.
	blueBits int32
	// The refresh rate, in Hz, of the video mode.
	refreshRate int32
}
type Gammaramp struct {
	// An array of value describing the response of the red channel.
	Red *uint16
	// An array of value describing the response of the green channel.
	Green *uint16
	// An array of value describing the response of the blue channel.
	Blue *uint16
	// The number of elements in each array.
	Size uint32
}
type Image struct {
	// The width, in pixels, of this image.
	Width int32
	// The height, in pixels, of this image.
	Height int32
	// The pixel data of this image, arranged left-to-right, top-to-bottom.
	Pixels *uint8
}
type Gamepadstate struct {
	// The states of each [gamepad button](
	// @ref gamepad_buttons),
	// `GLFW_PRESS`
	// or `GLFW_RELEASE`.
	Buttons [15]uint8
	// The states of each [gamepad axis](
	// @ref gamepad_axes),
	// in the range -1.0
	// to 1.0 inclusive.
	Axes [6]float32
}
type Allocator struct {
	// The memory allocation function.  See
	// @ref GLFWallocatefun
	// for details about
	// allocation function.
	Allocate Allocatefun
	// The memory reallocation function.  See
	// @ref GLFWreallocatefun
	// for details about
	// reallocation function.
	Reallocate Reallocatefun
	// The memory deallocation function.  See
	// @ref GLFWdeallocatefun
	// for details about
	// deallocation function.
	Deallocate Deallocatefun
	// The user pointer for this custom allocator.  This value will be passed to the
	// allocator functions.
	User unsafe.Pointer
}
type (
	_Int128T           = any
	_Uint128T          = any
	__NSConstantString = any
	SizeT              = uint64
	_BuiltinMsVaList   = *byte
	_BuiltinVaList     = *byte
	Uint8T             = uint8
	Uint16T            = uint16
	Uint32T            = uint32
	Uint64T            = uint64
	Int8T              = int8
	Int16T             = int16
	Int32T             = int32
	Int64T             = int64
	Bool               = uint8
	IntptrT            = *int32
	// @brief Client API function pointer type.
	// Generic function pointer used for returning client API function pointers
	// without forcing a cast from a regular pointer.
	//
	// @sa
	// @ref context_glext
	//
	// @sa
	// @ref glfwGetProcAddress
	//
	// @since Added in version 3.0.
	Glproc = unsafe.Pointer
	// @brief Vulkan API function pointer type.
	// Generic function pointer used for returning Vulkan API function pointers
	// without forcing a cast from a regular pointer.
	//
	// @sa
	// @ref vulkan_proc
	//
	// @sa
	// @ref glfwGetInstanceProcAddress
	//
	// @since Added in version 3.2.
	Vkproc = unsafe.Pointer
	// @brief The function pointer type for memory allocation callbacks.
	// This is the function pointer type for memory allocation callbacks.  A memory
	// allocation callback function has the following signature:
	//
	// This function must return either a memory block at least `size` bytes long,
	// or `NULL` if allocation failed.  Note that not all parts of GLFW handle allocation
	// failures gracefully yet.
	// This function must support being called during
	// @ref glfwInit
	// but before the library is
	// flagged as initialized, as well as during
	// @ref glfwTerminate
	// after the library is no
	// longer flagged as initialized.
	// Any memory allocated via this function will be deallocated via the same allocator
	// during library termination or earlier.
	// Any memory allocated via this function must be suitably aligned for any object type.
	// If you are using C99 or earlier, this alignment is platform-dependent but will be the
	// same as what `malloc` provides.  If you are using C11 or later, this is the value of
	// `alignof(max_align_t)`.
	// The size will always be greater than zero.  Allocations of size zero are filtered out
	// before reaching the custom allocator.
	// If this function returns `NULL`, GLFW will emit
	// @ref GLFW_OUT_OF_MEMORY.
	// This function must not call any GLFW function.
	//
	// @param size The minimum size, in bytes, of the memory block.
	//
	// @param user The user-defined pointer from the allocator.
	//
	// @return The address of the newly allocated memory block, or `NULL` if an
	// error occurred.
	//
	// @pointer
	// _lifetime The returned memory block must be valid at least until it
	// is deallocated.
	//
	// @reentrancy
	// This function should not call any GLFW function.
	//
	// @thread
	// _safety This function must support being called from any thread that calls GLFW
	// functions.
	//
	// @sa
	// @ref init_allocator
	//
	// @sa
	// @ref GLFWallocator
	//
	// @since Added in version 3.4.
	Allocatefun = unsafe.Pointer
	// @brief The function pointer type for memory reallocation callbacks.
	// This is the function pointer type for memory reallocation callbacks.
	// A memory reallocation callback function has the following signature:
	//
	// This function must return a memory block at least `size` bytes long, or
	// `NULL` if allocation failed.  Note that not all parts of GLFW handle allocation
	// failures gracefully yet.
	// This function must support being called during
	// @ref glfwInit
	// but before the library is
	// flagged as initialized, as well as during
	// @ref glfwTerminate
	// after the library is no
	// longer flagged as initialized.
	// Any memory allocated via this function will be deallocated via the same allocator
	// during library termination or earlier.
	// Any memory allocated via this function must be suitably aligned for any object type.
	// If you are using C99 or earlier, this alignment is platform-dependent but will be the
	// same as what `realloc` provides.  If you are using C11 or later, this is the value of
	// `alignof(max_align_t)`.
	// The block address will never be `NULL` and the size will always be greater than zero.
	// Reallocations of a block to size zero are converted into deallocations before reaching
	// the custom allocator.  Reallocations of `NULL` to a non-zero size are converted into
	// regular allocations before reaching the custom allocator.
	// If this function returns `NULL`, GLFW will emit
	// @ref GLFW_OUT_OF_MEMORY.
	// This function must not call any GLFW function.
	//
	// @param block The address of the memory block to reallocate.
	//
	// @param size The new minimum size, in bytes, of the memory block.
	//
	// @param user The user-defined pointer from the allocator.
	//
	// @return The address of the newly allocated or resized memory block, or
	// `NULL` if an error occurred.
	//
	// @pointer
	// _lifetime The returned memory block must be valid at least until it
	// is deallocated.
	//
	// @reentrancy
	// This function should not call any GLFW function.
	//
	// @thread
	// _safety This function must support being called from any thread that calls GLFW
	// functions.
	//
	// @sa
	// @ref init_allocator
	//
	// @sa
	// @ref GLFWallocator
	//
	// @since Added in version 3.4.
	Reallocatefun = unsafe.Pointer
	// @brief The function pointer type for memory deallocation callbacks.
	// This is the function pointer type for memory deallocation callbacks.
	// A memory deallocation callback function has the following signature:
	//
	// This function may deallocate the specified memory block.  This memory block
	// will have been allocated with the same allocator.
	// This function must support being called during
	// @ref glfwInit
	// but before the library is
	// flagged as initialized, as well as during
	// @ref glfwTerminate
	// after the library is no
	// longer flagged as initialized.
	// The block address will never be `NULL`.  Deallocations of `NULL` are filtered out
	// before reaching the custom allocator.
	// If this function returns `NULL`, GLFW will emit
	// @ref GLFW_OUT_OF_MEMORY.
	// This function must not call any GLFW function.
	//
	// @param block The address of the memory block to deallocate.
	//
	// @param user The user-defined pointer from the allocator.
	//
	// @pointer
	// _lifetime The specified memory block will not be accessed by GLFW
	// after this function is called.
	//
	// @reentrancy
	// This function should not call any GLFW function.
	//
	// @thread
	// _safety This function must support being called from any thread that calls GLFW
	// functions.
	//
	// @sa
	// @ref init_allocator
	//
	// @sa
	// @ref GLFWallocator
	//
	// @since Added in version 3.4.
	Deallocatefun = unsafe.Pointer
	// @brief The function pointer type for error callbacks.
	// This is the function pointer type for error callbacks.  An error callback
	// function has the following signature:
	//
	//
	// @param error_code An [error code](
	// @ref errors).
	// Future releases may add
	// more error codes.
	//
	// @param description A UTF-8 encoded string describing the error.
	//
	// @pointer
	// _lifetime The error description string is valid until the callback
	// function returns.
	//
	// @sa
	// @ref error_handling
	//
	// @sa
	// @ref glfwSetErrorCallback
	//
	// @since Added in version 3.0.
	Errorfun = unsafe.Pointer
	// @brief The function pointer type for window position callbacks.
	// This is the function pointer type for window position callbacks.  A window
	// position callback function has the following signature:
	//
	//
	// @param window The window that was moved.
	//
	// @param xpos The new x-coordinate, in screen coordinates, of the
	// upper-left corner of the content area of the window.
	//
	// @param ypos The new y-coordinate, in screen coordinates, of the
	// upper-left corner of the content area of the window.
	//
	// @sa
	// @ref window_pos
	//
	// @sa
	// @ref glfwSetWindowPosCallback
	//
	// @since Added in version 3.0.
	Windowposfun = unsafe.Pointer
	// @brief The function pointer type for window size callbacks.
	// This is the function pointer type for window size callbacks.  A window size
	// callback function has the following signature:
	//
	//
	// @param window The window that was resized.
	//
	// @param width The new width, in screen coordinates, of the window.
	//
	// @param height The new height, in screen coordinates, of the window.
	//
	// @sa
	// @ref window_size
	//
	// @sa
	// @ref glfwSetWindowSizeCallback
	//
	// @since Added in version 1.0.
	//
	// @glfw3
	// Added window handle parameter.
	Windowsizefun = unsafe.Pointer
	// @brief The function pointer type for window close callbacks.
	// This is the function pointer type for window close callbacks.  A window
	// close callback function has the following signature:
	//
	//
	// @param window The window that the user attempted to close.
	//
	// @sa
	// @ref window_close
	//
	// @sa
	// @ref glfwSetWindowCloseCallback
	//
	// @since Added in version 2.5.
	//
	// @glfw3
	// Added window handle parameter.
	Windowclosefun = unsafe.Pointer
	// @brief The function pointer type for window content refresh callbacks.
	// This is the function pointer type for window content refresh callbacks.
	// A window content refresh callback function has the following signature:
	//
	//
	// @param window The window whose content needs to be refreshed.
	//
	// @sa
	// @ref window_refresh
	//
	// @sa
	// @ref glfwSetWindowRefreshCallback
	//
	// @since Added in version 2.5.
	//
	// @glfw3
	// Added window handle parameter.
	Windowrefreshfun = unsafe.Pointer
	// @brief The function pointer type for window focus callbacks.
	// This is the function pointer type for window focus callbacks.  A window
	// focus callback function has the following signature:
	//
	//
	// @param window The window that gained or lost input focus.
	//
	// @param focused `GLFW_TRUE` if the window was given input focus, or
	// `GLFW_FALSE` if it lost it.
	//
	// @sa
	// @ref window_focus
	//
	// @sa
	// @ref glfwSetWindowFocusCallback
	//
	// @since Added in version 3.0.
	Windowfocusfun = unsafe.Pointer
	// @brief The function pointer type for window iconify callbacks.
	// This is the function pointer type for window iconify callbacks.  A window
	// iconify callback function has the following signature:
	//
	//
	// @param window The window that was iconified or restored.
	//
	// @param iconified `GLFW_TRUE` if the window was iconified, or
	// `GLFW_FALSE` if it was restored.
	//
	// @sa
	// @ref window_iconify
	//
	// @sa
	// @ref glfwSetWindowIconifyCallback
	//
	// @since Added in version 3.0.
	Windowiconifyfun = unsafe.Pointer
	// @brief The function pointer type for window maximize callbacks.
	// This is the function pointer type for window maximize callbacks.  A window
	// maximize callback function has the following signature:
	//
	//
	// @param window The window that was maximized or restored.
	//
	// @param maximized `GLFW_TRUE` if the window was maximized, or
	// `GLFW_FALSE` if it was restored.
	//
	// @sa
	// @ref window_maximize
	//
	// @sa glfwSetWindowMaximizeCallback
	//
	// @since Added in version 3.3.
	Windowmaximizefun = unsafe.Pointer
	// @brief The function pointer type for framebuffer size callbacks.
	// This is the function pointer type for framebuffer size callbacks.
	// A framebuffer size callback function has the following signature:
	//
	//
	// @param window The window whose framebuffer was resized.
	//
	// @param width The new width, in pixels, of the framebuffer.
	//
	// @param height The new height, in pixels, of the framebuffer.
	//
	// @sa
	// @ref window_fbsize
	//
	// @sa
	// @ref glfwSetFramebufferSizeCallback
	//
	// @since Added in version 3.0.
	Framebuffersizefun = unsafe.Pointer
	// @brief The function pointer type for window content scale callbacks.
	// This is the function pointer type for window content scale callbacks.
	// A window content scale callback function has the following signature:
	//
	//
	// @param window The window whose content scale changed.
	//
	// @param xscale The new x-axis content scale of the window.
	//
	// @param yscale The new y-axis content scale of the window.
	//
	// @sa
	// @ref window_scale
	//
	// @sa
	// @ref glfwSetWindowContentScaleCallback
	//
	// @since Added in version 3.3.
	Windowcontentscalefun = unsafe.Pointer
	// @brief The function pointer type for mouse button callbacks.
	// This is the function pointer type for mouse button callback functions.
	// A mouse button callback function has the following signature:
	//
	//
	// @param window The window that received the event.
	//
	// @param button The [mouse button](
	// @ref buttons)
	// that was pressed or
	// released.
	//
	// @param action One of `GLFW_PRESS` or `GLFW_RELEASE`.  Future releases
	// may add more actions.
	//
	// @param mods Bit field describing which [modifier keys](
	// @ref mods)
	// were
	// held down.
	//
	// @sa
	// @ref input_mouse_button
	//
	// @sa
	// @ref glfwSetMouseButtonCallback
	//
	// @since Added in version 1.0.
	//
	// @glfw3
	// Added window handle and modifier mask parameters.
	Mousebuttonfun = unsafe.Pointer
	// @brief The function pointer type for cursor position callbacks.
	// This is the function pointer type for cursor position callbacks.  A cursor
	// position callback function has the following signature:
	//
	//
	// @param window The window that received the event.
	//
	// @param xpos The new cursor x-coordinate, relative to the left edge of
	// the content area.
	//
	// @param ypos The new cursor y-coordinate, relative to the top edge of the
	// content area.
	//
	// @sa
	// @ref cursor_pos
	//
	// @sa
	// @ref glfwSetCursorPosCallback
	//
	// @since Added in version 3.0.  Replaces `GLFWmouseposfun`.
	Cursorposfun = unsafe.Pointer
	// @brief The function pointer type for cursor enter/leave callbacks.
	// This is the function pointer type for cursor enter/leave callbacks.
	// A cursor enter/leave callback function has the following signature:
	//
	//
	// @param window The window that received the event.
	//
	// @param entered `GLFW_TRUE` if the cursor entered the window's content
	// area, or `GLFW_FALSE` if it left it.
	//
	// @sa
	// @ref cursor_enter
	//
	// @sa
	// @ref glfwSetCursorEnterCallback
	//
	// @since Added in version 3.0.
	Cursorenterfun = unsafe.Pointer
	// @brief The function pointer type for scroll callbacks.
	// This is the function pointer type for scroll callbacks.  A scroll callback
	// function has the following signature:
	//
	//
	// @param window The window that received the event.
	//
	// @param xoffset The scroll offset along the x-axis.
	//
	// @param yoffset The scroll offset along the y-axis.
	//
	// @sa
	// @ref scrolling
	//
	// @sa
	// @ref glfwSetScrollCallback
	//
	// @since Added in version 3.0.  Replaces `GLFWmousewheelfun`.
	Scrollfun = unsafe.Pointer
	// @brief The function pointer type for keyboard key callbacks.
	// This is the function pointer type for keyboard key callbacks.  A keyboard
	// key callback function has the following signature:
	//
	//
	// @param window The window that received the event.
	//
	// @param key The [keyboard key](
	// @ref keys)
	// that was pressed or released.
	//
	// @param scancode The platform-specific scancode of the key.
	//
	// @param action `GLFW_PRESS`, `GLFW_RELEASE` or `GLFW_REPEAT`.  Future
	// releases may add more actions.
	//
	// @param mods Bit field describing which [modifier keys](
	// @ref mods)
	// were
	// held down.
	//
	// @sa
	// @ref input_key
	//
	// @sa
	// @ref glfwSetKeyCallback
	//
	// @since Added in version 1.0.
	//
	// @glfw3
	// Added window handle, scancode and modifier mask parameters.
	Keyfun = unsafe.Pointer
	// @brief The function pointer type for Unicode character callbacks.
	// This is the function pointer type for Unicode character callbacks.
	// A Unicode character callback function has the following signature:
	//
	//
	// @param window The window that received the event.
	//
	// @param codepoint The Unicode code point of the character.
	//
	// @sa
	// @ref input_char
	//
	// @sa
	// @ref glfwSetCharCallback
	//
	// @since Added in version 2.4.
	//
	// @glfw3
	// Added window handle parameter.
	Charfun = unsafe.Pointer
	// @brief The function pointer type for Unicode character with modifiers
	// callbacks.
	// This is the function pointer type for Unicode character with modifiers
	// callbacks.  It is called for each input character, regardless of what
	// modifier keys are held down.  A Unicode character with modifiers callback
	// function has the following signature:
	//
	//
	// @param window The window that received the event.
	//
	// @param codepoint The Unicode code point of the character.
	//
	// @param mods Bit field describing which [modifier keys](
	// @ref mods)
	// were
	// held down.
	//
	// @sa
	// @ref input_char
	//
	// @sa
	// @ref glfwSetCharModsCallback
	//
	// @deprecated Scheduled for removal in version 4.0.
	//
	// @since Added in version 3.1.
	Charmodsfun = unsafe.Pointer
	// @brief The function pointer type for path drop callbacks.
	// This is the function pointer type for path drop callbacks.  A path drop
	// callback function has the following signature:
	//
	//
	// @param window The window that received the event.
	//
	// @param path_count The number of dropped paths.
	//
	// @param paths The UTF-8 encoded file and/or directory path names.
	//
	// @pointer
	// _lifetime The path array and its strings are valid until the
	// callback function returns.
	//
	// @sa
	// @ref path_drop
	//
	// @sa
	// @ref glfwSetDropCallback
	//
	// @since Added in version 3.1.
	Dropfun = unsafe.Pointer
	// @brief The function pointer type for monitor configuration callbacks.
	// This is the function pointer type for monitor configuration callbacks.
	// A monitor callback function has the following signature:
	//
	//
	// @param monitor The monitor that was connected or disconnected.
	//
	// @param event One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.  Future
	// releases may add more events.
	//
	// @sa
	// @ref monitor_event
	//
	// @sa
	// @ref glfwSetMonitorCallback
	//
	// @since Added in version 3.0.
	Monitorfun = unsafe.Pointer
	// @brief The function pointer type for joystick configuration callbacks.
	// This is the function pointer type for joystick configuration callbacks.
	// A joystick configuration callback function has the following signature:
	//
	//
	// @param jid The joystick that was connected or disconnected.
	//
	// @param event One of `GLFW_CONNECTED` or `GLFW_DISCONNECTED`.  Future
	// releases may add more events.
	//
	// @sa
	// @ref joystick_event
	//
	// @sa
	// @ref glfwSetJoystickCallback
	//
	// @since Added in version 3.2.
	Joystickfun = unsafe.Pointer
)

var __imp_glfwInit bindlib.PreloadProc

// Gengo init function.
func init() {
	__imp_glfwInit = GengoLibrary.ImportNow("glfwInit")
	__imp_glfwTerminate = GengoLibrary.ImportNow("glfwTerminate")
	__imp_glfwInitHint = GengoLibrary.ImportNow("glfwInitHint")
	__imp_glfwInitAllocator = GengoLibrary.ImportNow("glfwInitAllocator")
	__imp_glfwGetVersion = GengoLibrary.ImportNow("glfwGetVersion")
	__imp_glfwGetVersionString = GengoLibrary.ImportNow("glfwGetVersionString")
	__imp_glfwGetError = GengoLibrary.ImportNow("glfwGetError")
	__imp_glfwSetErrorCallback = GengoLibrary.ImportNow("glfwSetErrorCallback")
	__imp_glfwGetPlatform = GengoLibrary.ImportNow("glfwGetPlatform")
	__imp_glfwPlatformSupported = GengoLibrary.ImportNow("glfwPlatformSupported")
	__imp_glfwGetMonitors = GengoLibrary.ImportNow("glfwGetMonitors")
	__imp_glfwGetPrimaryMonitor = GengoLibrary.ImportNow("glfwGetPrimaryMonitor")
	__imp_glfwGetMonitorPos = GengoLibrary.ImportNow("glfwGetMonitorPos")
	__imp_glfwGetMonitorWorkarea = GengoLibrary.ImportNow("glfwGetMonitorWorkarea")
	__imp_glfwGetMonitorPhysicalSize = GengoLibrary.ImportNow("glfwGetMonitorPhysicalSize")
	__imp_glfwGetMonitorContentScale = GengoLibrary.ImportNow("glfwGetMonitorContentScale")
	__imp_glfwGetMonitorName = GengoLibrary.ImportNow("glfwGetMonitorName")
	__imp_glfwSetMonitorUserPointer = GengoLibrary.ImportNow("glfwSetMonitorUserPointer")
	__imp_glfwGetMonitorUserPointer = GengoLibrary.ImportNow("glfwGetMonitorUserPointer")
	__imp_glfwSetMonitorCallback = GengoLibrary.ImportNow("glfwSetMonitorCallback")
	__imp_glfwGetVideoModes = GengoLibrary.ImportNow("glfwGetVideoModes")
	__imp_glfwGetVideoMode = GengoLibrary.ImportNow("glfwGetVideoMode")
	__imp_glfwSetGamma = GengoLibrary.ImportNow("glfwSetGamma")
	__imp_glfwGetGammaRamp = GengoLibrary.ImportNow("glfwGetGammaRamp")
	__imp_glfwSetGammaRamp = GengoLibrary.ImportNow("glfwSetGammaRamp")
	__imp_glfwDefaultWindowHints = GengoLibrary.ImportNow("glfwDefaultWindowHints")
	__imp_glfwWindowHint = GengoLibrary.ImportNow("glfwWindowHint")
	__imp_glfwWindowHintString = GengoLibrary.ImportNow("glfwWindowHintString")
	__imp_glfwCreateWindow = GengoLibrary.ImportNow("glfwCreateWindow")
	__imp_glfwDestroyWindow = GengoLibrary.ImportNow("glfwDestroyWindow")
	__imp_glfwWindowShouldClose = GengoLibrary.ImportNow("glfwWindowShouldClose")
	__imp_glfwSetWindowShouldClose = GengoLibrary.ImportNow("glfwSetWindowShouldClose")
	__imp_glfwGetWindowTitle = GengoLibrary.ImportNow("glfwGetWindowTitle")
	__imp_glfwSetWindowTitle = GengoLibrary.ImportNow("glfwSetWindowTitle")
	__imp_glfwSetWindowIcon = GengoLibrary.ImportNow("glfwSetWindowIcon")
	__imp_glfwGetWindowPos = GengoLibrary.ImportNow("glfwGetWindowPos")
	__imp_glfwSetWindowPos = GengoLibrary.ImportNow("glfwSetWindowPos")
	__imp_glfwGetWindowSize = GengoLibrary.ImportNow("glfwGetWindowSize")
	__imp_glfwSetWindowSizeLimits = GengoLibrary.ImportNow("glfwSetWindowSizeLimits")
	__imp_glfwSetWindowAspectRatio = GengoLibrary.ImportNow("glfwSetWindowAspectRatio")
	__imp_glfwSetWindowSize = GengoLibrary.ImportNow("glfwSetWindowSize")
	__imp_glfwGetFramebufferSize = GengoLibrary.ImportNow("glfwGetFramebufferSize")
	__imp_glfwGetWindowFrameSize = GengoLibrary.ImportNow("glfwGetWindowFrameSize")
	__imp_glfwGetWindowContentScale = GengoLibrary.ImportNow("glfwGetWindowContentScale")
	__imp_glfwGetWindowOpacity = GengoLibrary.ImportNow("glfwGetWindowOpacity")
	__imp_glfwSetWindowOpacity = GengoLibrary.ImportNow("glfwSetWindowOpacity")
	__imp_glfwIconifyWindow = GengoLibrary.ImportNow("glfwIconifyWindow")
	__imp_glfwRestoreWindow = GengoLibrary.ImportNow("glfwRestoreWindow")
	__imp_glfwMaximizeWindow = GengoLibrary.ImportNow("glfwMaximizeWindow")
	__imp_glfwShowWindow = GengoLibrary.ImportNow("glfwShowWindow")
	__imp_glfwHideWindow = GengoLibrary.ImportNow("glfwHideWindow")
	__imp_glfwFocusWindow = GengoLibrary.ImportNow("glfwFocusWindow")
	__imp_glfwRequestWindowAttention = GengoLibrary.ImportNow("glfwRequestWindowAttention")
	__imp_glfwGetWindowMonitor = GengoLibrary.ImportNow("glfwGetWindowMonitor")
	__imp_glfwSetWindowMonitor = GengoLibrary.ImportNow("glfwSetWindowMonitor")
	__imp_glfwGetWindowAttrib = GengoLibrary.ImportNow("glfwGetWindowAttrib")
	__imp_glfwSetWindowAttrib = GengoLibrary.ImportNow("glfwSetWindowAttrib")
	__imp_glfwSetWindowUserPointer = GengoLibrary.ImportNow("glfwSetWindowUserPointer")
	__imp_glfwGetWindowUserPointer = GengoLibrary.ImportNow("glfwGetWindowUserPointer")
	__imp_glfwSetWindowPosCallback = GengoLibrary.ImportNow("glfwSetWindowPosCallback")
	__imp_glfwSetWindowSizeCallback = GengoLibrary.ImportNow("glfwSetWindowSizeCallback")
	__imp_glfwSetWindowCloseCallback = GengoLibrary.ImportNow("glfwSetWindowCloseCallback")
	__imp_glfwSetWindowRefreshCallback = GengoLibrary.ImportNow("glfwSetWindowRefreshCallback")
	__imp_glfwSetWindowFocusCallback = GengoLibrary.ImportNow("glfwSetWindowFocusCallback")
	__imp_glfwSetWindowIconifyCallback = GengoLibrary.ImportNow("glfwSetWindowIconifyCallback")
	__imp_glfwSetWindowMaximizeCallback = GengoLibrary.ImportNow("glfwSetWindowMaximizeCallback")
	__imp_glfwSetFramebufferSizeCallback = GengoLibrary.ImportNow("glfwSetFramebufferSizeCallback")
	__imp_glfwSetWindowContentScaleCallback = GengoLibrary.ImportNow("glfwSetWindowContentScaleCallback")
	__imp_glfwPollEvents = GengoLibrary.ImportNow("glfwPollEvents")
	__imp_glfwWaitEvents = GengoLibrary.ImportNow("glfwWaitEvents")
	__imp_glfwWaitEventsTimeout = GengoLibrary.ImportNow("glfwWaitEventsTimeout")
	__imp_glfwPostEmptyEvent = GengoLibrary.ImportNow("glfwPostEmptyEvent")
	__imp_glfwGetInputMode = GengoLibrary.ImportNow("glfwGetInputMode")
	__imp_glfwSetInputMode = GengoLibrary.ImportNow("glfwSetInputMode")
	__imp_glfwRawMouseMotionSupported = GengoLibrary.ImportNow("glfwRawMouseMotionSupported")
	__imp_glfwGetKeyName = GengoLibrary.ImportNow("glfwGetKeyName")
	__imp_glfwGetKeyScancode = GengoLibrary.ImportNow("glfwGetKeyScancode")
	__imp_glfwGetKey = GengoLibrary.ImportNow("glfwGetKey")
	__imp_glfwGetMouseButton = GengoLibrary.ImportNow("glfwGetMouseButton")
	__imp_glfwGetCursorPos = GengoLibrary.ImportNow("glfwGetCursorPos")
	__imp_glfwSetCursorPos = GengoLibrary.ImportNow("glfwSetCursorPos")
	__imp_glfwCreateCursor = GengoLibrary.ImportNow("glfwCreateCursor")
	__imp_glfwCreateStandardCursor = GengoLibrary.ImportNow("glfwCreateStandardCursor")
	__imp_glfwDestroyCursor = GengoLibrary.ImportNow("glfwDestroyCursor")
	__imp_glfwSetCursor = GengoLibrary.ImportNow("glfwSetCursor")
	__imp_glfwSetKeyCallback = GengoLibrary.ImportNow("glfwSetKeyCallback")
	__imp_glfwSetCharCallback = GengoLibrary.ImportNow("glfwSetCharCallback")
	__imp_glfwSetCharModsCallback = GengoLibrary.ImportNow("glfwSetCharModsCallback")
	__imp_glfwSetMouseButtonCallback = GengoLibrary.ImportNow("glfwSetMouseButtonCallback")
	__imp_glfwSetCursorPosCallback = GengoLibrary.ImportNow("glfwSetCursorPosCallback")
	__imp_glfwSetCursorEnterCallback = GengoLibrary.ImportNow("glfwSetCursorEnterCallback")
	__imp_glfwSetScrollCallback = GengoLibrary.ImportNow("glfwSetScrollCallback")
	__imp_glfwSetDropCallback = GengoLibrary.ImportNow("glfwSetDropCallback")
	__imp_glfwJoystickPresent = GengoLibrary.ImportNow("glfwJoystickPresent")
	__imp_glfwGetJoystickAxes = GengoLibrary.ImportNow("glfwGetJoystickAxes")
	__imp_glfwGetJoystickButtons = GengoLibrary.ImportNow("glfwGetJoystickButtons")
	__imp_glfwGetJoystickHats = GengoLibrary.ImportNow("glfwGetJoystickHats")
	__imp_glfwGetJoystickName = GengoLibrary.ImportNow("glfwGetJoystickName")
	__imp_glfwGetJoystickGUID = GengoLibrary.ImportNow("glfwGetJoystickGUID")
	__imp_glfwSetJoystickUserPointer = GengoLibrary.ImportNow("glfwSetJoystickUserPointer")
	__imp_glfwGetJoystickUserPointer = GengoLibrary.ImportNow("glfwGetJoystickUserPointer")
	__imp_glfwJoystickIsGamepad = GengoLibrary.ImportNow("glfwJoystickIsGamepad")
	__imp_glfwSetJoystickCallback = GengoLibrary.ImportNow("glfwSetJoystickCallback")
	__imp_glfwUpdateGamepadMappings = GengoLibrary.ImportNow("glfwUpdateGamepadMappings")
	__imp_glfwGetGamepadName = GengoLibrary.ImportNow("glfwGetGamepadName")
	__imp_glfwGetGamepadState = GengoLibrary.ImportNow("glfwGetGamepadState")
	__imp_glfwSetClipboardString = GengoLibrary.ImportNow("glfwSetClipboardString")
	__imp_glfwGetClipboardString = GengoLibrary.ImportNow("glfwGetClipboardString")
	__imp_glfwGetTime = GengoLibrary.ImportNow("glfwGetTime")
	__imp_glfwSetTime = GengoLibrary.ImportNow("glfwSetTime")
	__imp_glfwGetTimerValue = GengoLibrary.ImportNow("glfwGetTimerValue")
	__imp_glfwGetTimerFrequency = GengoLibrary.ImportNow("glfwGetTimerFrequency")
	__imp_glfwMakeContextCurrent = GengoLibrary.ImportNow("glfwMakeContextCurrent")
	__imp_glfwGetCurrentContext = GengoLibrary.ImportNow("glfwGetCurrentContext")
	__imp_glfwSwapBuffers = GengoLibrary.ImportNow("glfwSwapBuffers")
	__imp_glfwSwapInterval = GengoLibrary.ImportNow("glfwSwapInterval")
	__imp_glfwExtensionSupported = GengoLibrary.ImportNow("glfwExtensionSupported")
	__imp_glfwGetProcAddress = GengoLibrary.ImportNow("glfwGetProcAddress")
	__imp_glfwVulkanSupported = GengoLibrary.ImportNow("glfwVulkanSupported")
	__imp_glfwGetRequiredInstanceExtensions = GengoLibrary.ImportNow("glfwGetRequiredInstanceExtensions")
	bindlib.Validate((*Vidmode)(nil), 24, 4, "Width", 0, "Height", 4, "redBits", 8, "greenBits", 12, "blueBits", 16, "refreshRate", 20)
	bindlib.Validate((*Gammaramp)(nil), 32, 8, "Red", 0, "Green", 8, "Blue", 16, "Size", 24)
	bindlib.Validate((*Image)(nil), 16, 8, "Width", 0, "Height", 4, "Pixels", 8)
	bindlib.Validate((*Gamepadstate)(nil), 40, 4, "Buttons", 0, "Axes", 16)
	bindlib.Validate((*Allocator)(nil), 32, 8, "Allocate", 0, "Reallocate", 8, "Deallocate", 16, "User", 24)
}

// @brief Initializes the GLFW library.
// This function initializes the GLFW library.  Before most GLFW functions can
// be used, GLFW must be initialized, and before an application terminates GLFW
// should be terminated in order to free any resources allocated during or
// after initialization.
// If this function fails, it calls
// @ref glfwTerminate
// before returning.  If it
// succeeds, you should call
// @ref glfwTerminate
// before the application exits.
// Additional calls to this function after successful initialization but before
// termination will return `GLFW_TRUE` immediately.
// The
// @ref GLFW_PLATFORM
// init hint controls which platforms are considered during
// initialization.  This also depends on which platforms the library was compiled to
// support.
//
// @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_PLATFORM_UNAVAILABLE
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @macos
// This function will change the current directory of the
// application to the `Contents/Resources` subdirectory of the application's
// bundle, if present.  This can be disabled with the
// @ref GLFW_COCOA_CHDIR_RESOURCES
// init hint.
//
// @remark
// @macos
// This function will create the main menu and dock icon for the
// application.  If GLFW finds a `MainMenu.nib` it is loaded and assumed to
// contain a menu bar.  Otherwise a minimal menu bar is created manually with
// common commands like Hide, Quit and About.  The About entry opens a minimal
// about dialog with information from the application's bundle.  The menu bar
// and dock icon can be disabled entirely with the
// @ref GLFW_COCOA_MENUBAR
// init
// hint.
//
// @remark __Wayland, X11:__ If the library was compiled with support for both
// Wayland and X11, and the
// @ref GLFW_PLATFORM
// init hint is set to
// `GLFW_ANY_PLATFORM`, the `XDG_SESSION_TYPE` environment variable affects
// which platform is picked.  If the environment variable is not set, or is set
// to something other than `wayland` or `x11`, the regular detection mechanism
// will be used instead.
//
// @remark
// @x11
// This function will set the `LC_CTYPE` category of the
// application locale according to the current environment if that category is
// still "C".  This is because the "C" locale breaks Unicode text input.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref intro_init
//
// @sa
// @ref glfwInitHint
//
// @sa
// @ref glfwInitAllocator
//
// @sa
// @ref glfwTerminate
//
// @since Added in version 1.0.
func Init() int32 {
	__res := bindlib.CCall0(__imp_glfwInit.Addr())
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwTerminate bindlib.PreloadProc

// @brief Terminates the GLFW library.
// This function destroys all remaining windows and cursors, restores any
// modified gamma ramps and frees any other allocated resources.  Once this
// function is called, you must again call
// @ref glfwInit
// successfully before
// you will be able to use most GLFW functions.
// If GLFW has been successfully initialized, this function should be called
// before the application exits.  If initialization fails, there is no need to
// call this function, as it is called by
// @ref glfwInit
// before it returns
// failure.
// This function has no effect if GLFW is not initialized.
//
// @errors
// Possible errors include
// @ref GLFW_PLATFORM_ERROR.
//
// @remark This function may be called before
// @ref glfwInit.
//
// @warning The contexts of any remaining windows must not be current on any
// other thread when this function is called.
//
// @reentrancy
// This function must not be called from a callback.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref intro_init
//
// @sa
// @ref glfwInit
//
// @since Added in version 1.0.
func Terminate() { bindlib.CCall0(__imp_glfwTerminate.Addr()) }

var __imp_glfwInitHint bindlib.PreloadProc

// @brief Sets the specified init hint to the desired value.
// This function sets hints for the next initialization of GLFW.
// The values you set hints to are never reset by GLFW, but they only take
// effect during initialization.  Once GLFW has been initialized, any values
// you set will be ignored until the library is terminated and initialized
// again.
// Some hints are platform specific.  These may be set on any platform but they
// will only affect their specific platform.  Other platforms will ignore them.
// Setting these hints requires no platform specific headers or functions.
//
// @param hint The [init hint](
// @ref init_hints)
// to set.
//
// @param value The new value of the init hint.
//
// @errors
// Possible errors include
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_INVALID_VALUE.
//
// @remarks This function may be called before
// @ref glfwInit.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa init_hints
//
// @sa glfwInit
//
// @since Added in version 3.3.
func InitHint(hint int32, value int32) {
	bindlib.CCall2(__imp_glfwInitHint.Addr(), bindlib.MarshallSyscall(hint), bindlib.MarshallSyscall(value))
}

var __imp_glfwInitAllocator bindlib.PreloadProc

// @brief Sets the init allocator to the desired value.
// To use the default allocator, call this function with a `NULL` argument.
// If you specify an allocator struct, every member must be a valid function
// pointer.  If any member is `NULL`, this function will emit
// @ref GLFW_INVALID_VALUE
// and the init allocator will be unchanged.
// The functions in the allocator must fulfil a number of requirements.  See the
// documentation for
// @ref GLFWallocatefun,
//
// @ref GLFWreallocatefun
// and
// @ref GLFWdeallocatefun
// for details.
//
// @param allocator The allocator to use at the next initialization, or
// `NULL` to use the default one.
//
// @errors
// Possible errors include
// @ref GLFW_INVALID_VALUE.
//
// @pointer
// _lifetime The specified allocator is copied before this function
// returns.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref init_allocator
//
// @sa
// @ref glfwInit
//
// @since Added in version 3.4.
func InitAllocator(allocator *Allocator) {
	bindlib.CCall1(__imp_glfwInitAllocator.Addr(), bindlib.MarshallSyscall(allocator))
}

var __imp_glfwGetVersion bindlib.PreloadProc

// @brief Retrieves the version of the GLFW library.
// This function retrieves the major, minor and revision numbers of the GLFW
// library.  It is intended for when you are using GLFW as a shared library and
// want to ensure that you are using the minimum required version.
// Any or all of the version arguments may be `NULL`.
//
// @param major Where to store the major version number, or `NULL`.
//
// @param minor Where to store the minor version number, or `NULL`.
//
// @param rev Where to store the revision number, or `NULL`.
//
// @errors
// None.
//
// @remark This function may be called before
// @ref glfwInit.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref intro_version
//
// @sa
// @ref glfwGetVersionString
//
// @since Added in version 1.0.
func GetVersion(major *int32, minor *int32, rev *int32) {
	bindlib.CCall3(__imp_glfwGetVersion.Addr(), bindlib.MarshallSyscall(major), bindlib.MarshallSyscall(minor), bindlib.MarshallSyscall(rev))
}

var __imp_glfwGetVersionString bindlib.PreloadProc

// @brief Returns a string describing the compile-time configuration.
// This function returns the compile-time generated
// [version string](
// @ref intro_version_string)
// of the GLFW library binary.  It describes
// the version, platforms, compiler and any platform or operating system specific
// compile-time options.  It should not be confused with the OpenGL or OpenGL ES version
// string, queried with `glGetString`.
// __Do not use the version string__ to parse the GLFW library version.  The
//
// @ref glfwGetVersion
// function provides the version of the running library
// binary in numerical format.
// __Do not use the version string__ to parse what platforms are supported.  The
// @ref glfwPlatformSupported
// function lets you query platform support.
//
// @return The ASCII encoded GLFW version string.
//
// @errors
// None.
//
// @remark This function may be called before
// @ref glfwInit.
//
// @pointer
// _lifetime The returned string is static and compile-time generated.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref intro_version
//
// @sa
// @ref glfwGetVersion
//
// @since Added in version 3.0.
func GetVersionString() *byte {
	__res := bindlib.CCall0(__imp_glfwGetVersionString.Addr())
	return bindlib.UnmarshallSyscall[*byte](__res)
}

var __imp_glfwGetError bindlib.PreloadProc

// @brief Returns and clears the last error for the calling thread.
// This function returns and clears the [error code](
// @ref errors)
// of the last
// error that occurred on the calling thread, and optionally a UTF-8 encoded
// human-readable description of it.  If no error has occurred since the last
// call, it returns
// @ref GLFW_NO_ERROR
// (zero) and the description pointer is
// set to `NULL`.
//
// @param description Where to store the error description pointer, or `NULL`.
//
// @return The last error code for the calling thread, or
// @ref GLFW_NO_ERROR
// (zero).
//
// @errors
// None.
//
// @pointer
// _lifetime The returned string is allocated and freed by GLFW.  You
// should not free it yourself.  It is guaranteed to be valid only until the
// next error occurs or the library is terminated.
//
// @remark This function may be called before
// @ref glfwInit.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref error_handling
//
// @sa
// @ref glfwSetErrorCallback
//
// @since Added in version 3.3.
func GetError(description **byte) int32 {
	__res := bindlib.CCall1(__imp_glfwGetError.Addr(), bindlib.MarshallSyscall(description))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwSetErrorCallback bindlib.PreloadProc

// @brief Sets the error callback.
// This function sets the error callback, which is called with an error code
// and a human-readable description each time a GLFW error occurs.
// The error code is set before the callback is called.  Calling
// @ref glfwGetError
// from the error callback will return the same value as the error
// code argument.
// The error callback is called on the thread where the error occurred.  If you
// are using GLFW from multiple threads, your error callback needs to be
// written accordingly.
// Because the description string may have been generated specifically for that
// error, it is not guaranteed to be valid after the callback has returned.  If
// you wish to use it after the callback returns, you need to make a copy.
// Once set, the error callback remains set even after the library has been
// terminated.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set.
//
// For more information about the callback parameters, see the
// [callback pointer type](
// @ref GLFWerrorfun).
//
// @errors
// None.
//
// @remark This function may be called before
// @ref glfwInit.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref error_handling
//
// @sa
// @ref glfwGetError
//
// @since Added in version 3.0.
func SetErrorCallback(callback Errorfun) Errorfun {
	__res := bindlib.CCall1(__imp_glfwSetErrorCallback.Addr(), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Errorfun](__res)
}

var __imp_glfwGetPlatform bindlib.PreloadProc

// @brief Returns the currently selected platform.
// This function returns the platform that was selected during initialization.  The
// returned value will be one of `GLFW_PLATFORM_WIN32`, `GLFW_PLATFORM_COCOA`,
// `GLFW_PLATFORM_WAYLAND`, `GLFW_PLATFORM_X11` or `GLFW_PLATFORM_NULL`.
//
// @return The currently selected platform, or zero if an error occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref platform
//
// @sa
// @ref glfwPlatformSupported
//
// @since Added in version 3.4.
func GetPlatform() int32 {
	__res := bindlib.CCall0(__imp_glfwGetPlatform.Addr())
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwPlatformSupported bindlib.PreloadProc

// @brief Returns whether the library includes support for the specified platform.
// This function returns whether the library was compiled with support for the specified
// platform.  The platform must be one of `GLFW_PLATFORM_WIN32`, `GLFW_PLATFORM_COCOA`,
// `GLFW_PLATFORM_WAYLAND`, `GLFW_PLATFORM_X11` or `GLFW_PLATFORM_NULL`.
//
// @param platform The platform to query.
//
// @return `GLFW_TRUE` if the platform is supported, or `GLFW_FALSE` otherwise.
//
// @errors
// Possible errors include
// @ref GLFW_INVALID_ENUM.
//
// @remark This function may be called before
// @ref glfwInit.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref platform
//
// @sa
// @ref glfwGetPlatform
//
// @since Added in version 3.4.
func PlatformSupported(platform int32) int32 {
	__res := bindlib.CCall1(__imp_glfwPlatformSupported.Addr(), bindlib.MarshallSyscall(platform))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetMonitors bindlib.PreloadProc

// @brief Returns the currently connected monitors.
// This function returns an array of handles for all currently connected
// monitors.  The primary monitor is always first in the returned array.  If no
// monitors were found, this function returns `NULL`.
//
// @param count Where to store the number of monitors in the returned
// array.  This is set to zero if an error occurred.
//
// @return An array of monitor handles, or `NULL` if no monitors were found or
// if an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @pointer
// _lifetime The returned array is allocated and freed by GLFW.  You
// should not free it yourself.  It is guaranteed to be valid only until the
// monitor configuration changes or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_monitors
//
// @sa
// @ref monitor_event
//
// @sa
// @ref glfwGetPrimaryMonitor
//
// @since Added in version 3.0.
func GetMonitors(count *int32) *unsafe.Pointer {
	__res := bindlib.CCall1(__imp_glfwGetMonitors.Addr(), bindlib.MarshallSyscall(count))
	return bindlib.UnmarshallSyscall[*unsafe.Pointer](__res)
}

var __imp_glfwGetPrimaryMonitor bindlib.PreloadProc

// @brief Returns the primary monitor.
// This function returns the primary monitor.  This is usually the monitor
// where elements like the task bar or global menu bar are located.
//
// @return The primary monitor, or `NULL` if no monitors were found or if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @remark The primary monitor is always first in the array returned by
// @ref glfwGetMonitors.
//
// @sa
// @ref monitor_monitors
//
// @sa
// @ref glfwGetMonitors
//
// @since Added in version 3.0.
func GetPrimaryMonitor() unsafe.Pointer {
	__res := bindlib.CCall0(__imp_glfwGetPrimaryMonitor.Addr())
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwGetMonitorPos bindlib.PreloadProc

// @brief Returns the position of the monitor's viewport on the virtual screen.
// This function returns the position, in screen coordinates, of the upper-left
// corner of the specified monitor.
// Any or all of the position arguments may be `NULL`.  If an error occurs, all
// non-`NULL` position arguments will be set to zero.
//
// @param monitor The monitor to query.
//
// @param xpos Where to store the monitor x-coordinate, or `NULL`.
//
// @param ypos Where to store the monitor y-coordinate, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_properties
//
// @since Added in version 3.0.
func GetMonitorPos(monitor unsafe.Pointer, xpos *int32, ypos *int32) {
	bindlib.CCall3(__imp_glfwGetMonitorPos.Addr(), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(xpos), bindlib.MarshallSyscall(ypos))
}

var __imp_glfwGetMonitorWorkarea bindlib.PreloadProc

// @brief Retrieves the work area of the monitor.
// This function returns the position, in screen coordinates, of the upper-left
// corner of the work area of the specified monitor along with the work area
// size in screen coordinates. The work area is defined as the area of the
// monitor not occluded by the window system task bar where present. If no
// task bar exists then the work area is the monitor resolution in screen
// coordinates.
// Any or all of the position and size arguments may be `NULL`.  If an error
// occurs, all non-`NULL` position and size arguments will be set to zero.
//
// @param monitor The monitor to query.
//
// @param xpos Where to store the monitor x-coordinate, or `NULL`.
//
// @param ypos Where to store the monitor y-coordinate, or `NULL`.
//
// @param width Where to store the monitor width, or `NULL`.
//
// @param height Where to store the monitor height, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_workarea
//
// @since Added in version 3.3.
func GetMonitorWorkarea(monitor unsafe.Pointer, xpos *int32, ypos *int32, width *int32, height *int32) {
	bindlib.CCall5(__imp_glfwGetMonitorWorkarea.Addr(), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(xpos), bindlib.MarshallSyscall(ypos), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height))
}

var __imp_glfwGetMonitorPhysicalSize bindlib.PreloadProc

// @brief Returns the physical size of the monitor.
// This function returns the size, in millimetres, of the display area of the
// specified monitor.
// Some platforms do not provide accurate monitor size information, either
// because the monitor [EDID][] data is incorrect or because the driver does
// not report it accurately.
// [EDID]: https://en.wikipedia.org/wiki/Extended_display_identification_data
// Any or all of the size arguments may be `NULL`.  If an error occurs, all
// non-`NULL` size arguments will be set to zero.
//
// @param monitor The monitor to query.
//
// @param widthMM Where to store the width, in millimetres, of the
// monitor's display area, or `NULL`.
//
// @param heightMM Where to store the height, in millimetres, of the
// monitor's display area, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @remark
// @win32
// On Windows 8 and earlier the physical size is calculated from
// the current resolution and system DPI instead of querying the monitor EDID data.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_properties
//
// @since Added in version 3.0.
func GetMonitorPhysicalSize(monitor unsafe.Pointer, widthMM *int32, heightMM *int32) {
	bindlib.CCall3(__imp_glfwGetMonitorPhysicalSize.Addr(), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(widthMM), bindlib.MarshallSyscall(heightMM))
}

var __imp_glfwGetMonitorContentScale bindlib.PreloadProc

// @brief Retrieves the content scale for the specified monitor.
// This function retrieves the content scale for the specified monitor.  The
// content scale is the ratio between the current DPI and the platform's
// default DPI.  This is especially important for text and any UI elements.  If
// the pixel dimensions of your UI scaled by this look appropriate on your
// machine then it should appear at a reasonable size on other machines
// regardless of their DPI and scaling settings.  This relies on the system DPI
// and scaling settings being somewhat correct.
// The content scale may depend on both the monitor resolution and pixel
// density and on user settings.  It may be very different from the raw DPI
// calculated from the physical size and current resolution.
//
// @param monitor The monitor to query.
//
// @param xscale Where to store the x-axis content scale, or `NULL`.
//
// @param yscale Where to store the y-axis content scale, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @wayland
// Fractional scaling information is not yet available for
// monitors, so this function only returns integer content scales.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_scale
//
// @sa
// @ref glfwGetWindowContentScale
//
// @since Added in version 3.3.
func GetMonitorContentScale(monitor unsafe.Pointer, xscale *float32, yscale *float32) {
	bindlib.CCall3(__imp_glfwGetMonitorContentScale.Addr(), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(xscale), bindlib.MarshallSyscall(yscale))
}

var __imp_glfwGetMonitorName bindlib.PreloadProc

// @brief Returns the name of the specified monitor.
// This function returns a human-readable name, encoded as UTF-8, of the
// specified monitor.  The name typically reflects the make and model of the
// monitor and is not guaranteed to be unique among the connected monitors.
//
// @param monitor The monitor to query.
//
// @return The UTF-8 encoded name of the monitor, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @pointer
// _lifetime The returned string is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified monitor is
// disconnected or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_properties
//
// @since Added in version 3.0.
func GetMonitorName(monitor unsafe.Pointer) *byte {
	__res := bindlib.CCall1(__imp_glfwGetMonitorName.Addr(), bindlib.MarshallSyscall(monitor))
	return bindlib.UnmarshallSyscall[*byte](__res)
}

var __imp_glfwSetMonitorUserPointer bindlib.PreloadProc

// @brief Sets the user pointer of the specified monitor.
// This function sets the user-defined pointer of the specified monitor.  The
// current value is retained until the monitor is disconnected.  The initial
// value is `NULL`.
// This function may be called from the monitor callback, even for a monitor
// that is being disconnected.
//
// @param monitor The monitor whose pointer to set.
//
// @param pointer The new value.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Access is not
// synchronized.
//
// @sa
// @ref monitor_userptr
//
// @sa
// @ref glfwGetMonitorUserPointer
//
// @since Added in version 3.3.
func SetMonitorUserPointer(monitor unsafe.Pointer, pointer unsafe.Pointer) {
	bindlib.CCall2(__imp_glfwSetMonitorUserPointer.Addr(), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(pointer))
}

var __imp_glfwGetMonitorUserPointer bindlib.PreloadProc

// @brief Returns the user pointer of the specified monitor.
// This function returns the current value of the user-defined pointer of the
// specified monitor.  The initial value is `NULL`.
// This function may be called from the monitor callback, even for a monitor
// that is being disconnected.
//
// @param monitor The monitor whose pointer to return.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Access is not
// synchronized.
//
// @sa
// @ref monitor_userptr
//
// @sa
// @ref glfwSetMonitorUserPointer
//
// @since Added in version 3.3.
func GetMonitorUserPointer(monitor unsafe.Pointer) unsafe.Pointer {
	__res := bindlib.CCall1(__imp_glfwGetMonitorUserPointer.Addr(), bindlib.MarshallSyscall(monitor))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwSetMonitorCallback bindlib.PreloadProc

// @brief Sets the monitor configuration callback.
// This function sets the monitor configuration callback, or removes the
// currently set callback.  This is called when a monitor is connected to or
// disconnected from the system.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWmonitorfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_event
//
// @since Added in version 3.0.
func SetMonitorCallback(callback Monitorfun) Monitorfun {
	__res := bindlib.CCall1(__imp_glfwSetMonitorCallback.Addr(), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Monitorfun](__res)
}

var __imp_glfwGetVideoModes bindlib.PreloadProc

// @brief Returns the available video modes for the specified monitor.
// This function returns an array of all video modes supported by the specified
// monitor.  The returned array is sorted in ascending order, first by color
// bit depth (the sum of all channel depths), then by resolution area (the
// product of width and height), then resolution width and finally by refresh
// rate.
//
// @param monitor The monitor to query.
//
// @param count Where to store the number of video modes in the returned
// array.  This is set to zero if an error occurred.
//
// @return An array of video modes, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @pointer
// _lifetime The returned array is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified monitor is
// disconnected, this function is called again for that monitor or the library
// is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_modes
//
// @sa
// @ref glfwGetVideoMode
//
// @since Added in version 1.0.
//
// @glfw3
// Changed to return an array of modes for a specific monitor.
func GetVideoModes(monitor unsafe.Pointer, count *int32) *Vidmode {
	__res := bindlib.CCall2(__imp_glfwGetVideoModes.Addr(), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(count))
	return bindlib.UnmarshallSyscall[*Vidmode](__res)
}

var __imp_glfwGetVideoMode bindlib.PreloadProc

// @brief Returns the current mode of the specified monitor.
// This function returns the current video mode of the specified monitor.  If
// you have created a full screen window for that monitor, the return value
// will depend on whether that window is iconified.
//
// @param monitor The monitor to query.
//
// @return The current mode of the monitor, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @pointer
// _lifetime The returned array is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified monitor is
// disconnected or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_modes
//
// @sa
// @ref glfwGetVideoModes
//
// @since Added in version 3.0.  Replaces `glfwGetDesktopMode`.
func GetVideoMode(monitor unsafe.Pointer) *Vidmode {
	__res := bindlib.CCall1(__imp_glfwGetVideoMode.Addr(), bindlib.MarshallSyscall(monitor))
	return bindlib.UnmarshallSyscall[*Vidmode](__res)
}

var __imp_glfwSetGamma bindlib.PreloadProc

// @brief Generates a gamma ramp and sets it for the specified monitor.
// This function generates an appropriately sized gamma ramp from the specified
// exponent and then calls
// @ref glfwSetGammaRamp
// with it.  The value must be
// a finite number greater than zero.
// The software controlled gamma ramp is applied _in addition_ to the hardware
// gamma correction, which today is usually an approximation of sRGB gamma.
// This means that setting a perfectly linear ramp, or gamma 1.0, will produce
// the default (usually sRGB-like) behavior.
// For gamma correct rendering with OpenGL or OpenGL ES, see the
// @ref GLFW_SRGB_CAPABLE
// hint.
//
// @param monitor The monitor whose gamma ramp to set.
//
// @param gamma The desired exponent.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_VALUE,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @remark
// @wayland
// Gamma handling is a privileged protocol, this function
// will thus never be implemented and emits
// @ref GLFW_FEATURE_UNAVAILABLE.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_gamma
//
// @since Added in version 3.0.
func SetGamma(monitor unsafe.Pointer, gamma float32) {
	bindlib.CCall2(__imp_glfwSetGamma.Addr(), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(gamma))
}

var __imp_glfwGetGammaRamp bindlib.PreloadProc

// @brief Returns the current gamma ramp for the specified monitor.
// This function returns the current gamma ramp of the specified monitor.
//
// @param monitor The monitor to query.
//
// @return The current gamma ramp, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @remark
// @wayland
// Gamma handling is a privileged protocol, this function
// will thus never be implemented and emits
// @ref GLFW_FEATURE_UNAVAILABLE
// while
// returning `NULL`.
//
// @pointer
// _lifetime The returned structure and its arrays are allocated and
// freed by GLFW.  You should not free them yourself.  They are valid until the
// specified monitor is disconnected, this function is called again for that
// monitor or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_gamma
//
// @since Added in version 3.0.
func GetGammaRamp(monitor unsafe.Pointer) *Gammaramp {
	__res := bindlib.CCall1(__imp_glfwGetGammaRamp.Addr(), bindlib.MarshallSyscall(monitor))
	return bindlib.UnmarshallSyscall[*Gammaramp](__res)
}

var __imp_glfwSetGammaRamp bindlib.PreloadProc

// @brief Sets the current gamma ramp for the specified monitor.
// This function sets the current gamma ramp for the specified monitor.  The
// original gamma ramp for that monitor is saved by GLFW the first time this
// function is called and is restored by
// @ref glfwTerminate.
// The software controlled gamma ramp is applied _in addition_ to the hardware
// gamma correction, which today is usually an approximation of sRGB gamma.
// This means that setting a perfectly linear ramp, or gamma 1.0, will produce
// the default (usually sRGB-like) behavior.
// For gamma correct rendering with OpenGL or OpenGL ES, see the
// @ref GLFW_SRGB_CAPABLE
// hint.
//
// @param monitor The monitor whose gamma ramp to set.
//
// @param ramp The gamma ramp to use.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @remark The size of the specified gamma ramp should match the size of the
// current ramp for that monitor.
//
// @remark
// @win32
// The gamma ramp size must be 256.
//
// @remark
// @wayland
// Gamma handling is a privileged protocol, this function
// will thus never be implemented and emits
// @ref GLFW_FEATURE_UNAVAILABLE.
//
// @pointer
// _lifetime The specified gamma ramp is copied before this function
// returns.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref monitor_gamma
//
// @since Added in version 3.0.
func SetGammaRamp(monitor unsafe.Pointer, ramp *Gammaramp) {
	bindlib.CCall2(__imp_glfwSetGammaRamp.Addr(), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(ramp))
}

var __imp_glfwDefaultWindowHints bindlib.PreloadProc

// @brief Resets all window hints to their default values.
// This function resets all window hints to their
// [default values](
// @ref window_hints_values).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_hints
//
// @sa
// @ref glfwWindowHint
//
// @sa
// @ref glfwWindowHintString
//
// @since Added in version 3.0.
func DefaultWindowHints() { bindlib.CCall0(__imp_glfwDefaultWindowHints.Addr()) }

var __imp_glfwWindowHint bindlib.PreloadProc

// @brief Sets the specified window hint to the desired value.
// This function sets hints for the next call to
// @ref glfwCreateWindow.
// The
// hints, once set, retain their values until changed by a call to this
// function or
// @ref glfwDefaultWindowHints,
// or until the library is terminated.
// Only integer value hints can be set with this function.  String value hints
// are set with
// @ref glfwWindowHintString.
// This function does not check whether the specified hint values are valid.
// If you set hints to invalid values this will instead be reported by the next
// call to
// @ref glfwCreateWindow.
// Some hints are platform specific.  These may be set on any platform but they
// will only affect their specific platform.  Other platforms will ignore them.
// Setting these hints requires no platform specific headers or functions.
//
// @param hint The [window hint](
// @ref window_hints)
// to set.
//
// @param value The new value of the window hint.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_hints
//
// @sa
// @ref glfwWindowHintString
//
// @sa
// @ref glfwDefaultWindowHints
//
// @since Added in version 3.0.  Replaces `glfwOpenWindowHint`.
func WindowHint(hint int32, value int32) {
	bindlib.CCall2(__imp_glfwWindowHint.Addr(), bindlib.MarshallSyscall(hint), bindlib.MarshallSyscall(value))
}

var __imp_glfwWindowHintString bindlib.PreloadProc

// @brief Sets the specified window hint to the desired value.
// This function sets hints for the next call to
// @ref glfwCreateWindow.
// The
// hints, once set, retain their values until changed by a call to this
// function or
// @ref glfwDefaultWindowHints,
// or until the library is terminated.
// Only string type hints can be set with this function.  Integer value hints
// are set with
// @ref glfwWindowHint.
// This function does not check whether the specified hint values are valid.
// If you set hints to invalid values this will instead be reported by the next
// call to
// @ref glfwCreateWindow.
// Some hints are platform specific.  These may be set on any platform but they
// will only affect their specific platform.  Other platforms will ignore them.
// Setting these hints requires no platform specific headers or functions.
//
// @param hint The [window hint](
// @ref window_hints)
// to set.
//
// @param value The new value of the window hint.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @pointer
// _lifetime The specified string is copied before this function
// returns.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_hints
//
// @sa
// @ref glfwWindowHint
//
// @sa
// @ref glfwDefaultWindowHints
//
// @since Added in version 3.3.
func WindowHintString(hint int32, value *byte) {
	bindlib.CCall2(__imp_glfwWindowHintString.Addr(), bindlib.MarshallSyscall(hint), bindlib.MarshallSyscall(value))
}

var __imp_glfwCreateWindow bindlib.PreloadProc

// @brief Creates a window and its associated context.
// This function creates a window and its associated OpenGL or OpenGL ES
// context.  Most of the options controlling how the window and its context
// should be created are specified with [window hints](
// @ref window_hints).
// Successful creation does not change which context is current.  Before you
// can use the newly created context, you need to
// [make it current](
// @ref context_current).
// For information about the `share`
// parameter, see
// @ref context_sharing.
// The created window, framebuffer and context may differ from what you
// requested, as not all parameters and hints are
// [hard constraints](
// @ref window_hints_hard).
// This includes the size of the
// window, especially for full screen windows.  To query the actual attributes
// of the created window, framebuffer and context, see
// @ref glfwGetWindowAttrib,
//
// @ref glfwGetWindowSize
// and
// @ref glfwGetFramebufferSize.
// To create a full screen window, you need to specify the monitor the window
// will cover.  If no monitor is specified, the window will be windowed mode.
// Unless you have a way for the user to choose a specific monitor, it is
// recommended that you pick the primary monitor.  For more information on how
// to query connected monitors, see
// @ref monitor_monitors.
// For full screen windows, the specified size becomes the resolution of the
// window's _desired video mode_.  As long as a full screen window is not
// iconified, the supported video mode most closely matching the desired video
// mode is set for the specified monitor.  For more information about full
// screen windows, including the creation of so called _windowed full screen_
// or _borderless full screen_ windows, see
// @ref window_windowed_full_screen.
// Once you have created the window, you can switch it between windowed and
// full screen mode with
// @ref glfwSetWindowMonitor.
// This will not affect its
// OpenGL or OpenGL ES context.
// By default, newly created windows use the placement recommended by the
// window system.  To create the window at a specific position, set the
// @ref GLFW_POSITION_X
// and
// @ref GLFW_POSITION_Y
// window hints before creation.  To
// restore the default behavior, set either or both hints back to
// `GLFW_ANY_POSITION`.
// As long as at least one full screen window is not iconified, the screensaver
// is prohibited from starting.
// Window systems put limits on window sizes.  Very large or very small window
// dimensions may be overridden by the window system on creation.  Check the
// actual [size](
// @ref window_size)
// after creation.
// The [swap interval](
// @ref buffer_swap)
// is not set during window creation and
// the initial value may vary depending on driver settings and defaults.
//
// @param width The desired width, in screen coordinates, of the window.
// This must be greater than zero.
//
// @param height The desired height, in screen coordinates, of the window.
// This must be greater than zero.
//
// @param title The initial, UTF-8 encoded window title.
//
// @param monitor The monitor to use for full screen mode, or `NULL` for
// windowed mode.
//
// @param share The window whose context to share resources with, or `NULL`
// to not share resources.
//
// @return The handle of the created window, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM,
//
// @ref GLFW_INVALID_VALUE,
//
// @ref GLFW_API_UNAVAILABLE,
//
// @ref GLFW_VERSION_UNAVAILABLE,
//
// @ref GLFW_FORMAT_UNAVAILABLE,
//
// @ref GLFW_NO_WINDOW_CONTEXT
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @win32
// Window creation will fail if the Microsoft GDI software
// OpenGL implementation is the only one available.
//
// @remark
// @win32
// If the executable has an icon resource named `GLFW_ICON,` it
// will be set as the initial icon for the window.  If no such icon is present,
// the `IDI_APPLICATION` icon will be used instead.  To set a different icon,
// see
// @ref glfwSetWindowIcon.
//
// @remark
// @win32
// The context to share resources with must not be current on
// any other thread.
//
// @remark
// @macos
// The OS only supports core profile contexts for OpenGL
// versions 3.2 and later.  Before creating an OpenGL context of version 3.2 or
// later you must set the [GLFW_OPENGL_PROFILE](
// @ref GLFW_OPENGL_PROFILE_hint)
// hint accordingly.  OpenGL 3.0 and 3.1 contexts are not supported at all
// on macOS.
//
// @remark
// @macos
// The GLFW window has no icon, as it is not a document
// window, but the dock icon will be the same as the application bundle's icon.
// For more information on bundles, see the
// [Bundle Programming Guide][bundle-guide] in the Mac Developer Library.
// [bundle-guide]: https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/
//
// @remark
// @macos
// The window frame will not be rendered at full resolution on
// Retina displays unless the
// [GLFW_SCALE_FRAMEBUFFER](
// @ref GLFW_SCALE_FRAMEBUFFER_hint)
// hint is `GLFW_TRUE` and the `NSHighResolutionCapable` key is enabled in the
// application bundle's `Info.plist`.  For more information, see
// [High Resolution Guidelines for OS X][hidpi-guide] in the Mac Developer
// Library.  The GLFW test and example programs use a custom `Info.plist`
// template for this, which can be found as `CMake/Info.plist.in` in the source
// tree.
// [hidpi-guide]: https://developer.apple.com/library/mac/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Explained/Explained.html
//
// @remark
// @macos
// When activating frame autosaving with
// [GLFW_COCOA_FRAME_NAME](
// @ref GLFW_COCOA_FRAME_NAME_hint),
// the specified
// window size and position may be overridden by previously saved values.
//
// @remark
// @wayland
// GLFW uses [libdecor][] where available to create its window
// decorations.  This in turn uses server-side XDG decorations where available
// and provides high quality client-side decorations on compositors like GNOME.
// If both XDG decorations and libdecor are unavailable, GLFW falls back to
// a very simple set of window decorations that only support moving, resizing
// and the window manager's right-click menu.
// [libdecor]: https://gitlab.freedesktop.org/libdecor/libdecor
//
// @remark
// @x11
// Some window managers will not respect the placement of
// initially hidden windows.
//
// @remark
// @x11
// Due to the asynchronous nature of X11, it may take a moment for
// a window to reach its requested state.  This means you may not be able to
// query the final size, position or other attributes directly after window
// creation.
//
// @remark
// @x11
// The class part of the `WM_CLASS` window property will by
// default be set to the window title passed to this function.  The instance
// part will use the contents of the `RESOURCE_NAME` environment variable, if
// present and not empty, or fall back to the window title.  Set the
// [GLFW_X11_CLASS_NAME](
// @ref GLFW_X11_CLASS_NAME_hint)
// and
// [GLFW_X11_INSTANCE_NAME](
// @ref GLFW_X11_INSTANCE_NAME_hint)
// window hints to
// override this.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_creation
//
// @sa
// @ref glfwDestroyWindow
//
// @since Added in version 3.0.  Replaces `glfwOpenWindow`.
func CreateWindow(width int32, height int32, title *byte, monitor unsafe.Pointer, share unsafe.Pointer) unsafe.Pointer {
	__res := bindlib.CCall5(__imp_glfwCreateWindow.Addr(), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height), bindlib.MarshallSyscall(title), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(share))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwDestroyWindow bindlib.PreloadProc

// @brief Destroys the specified window and its context.
// This function destroys the specified window and its context.  On calling
// this function, no further callbacks will be called for that window.
// If the context of the specified window is current on the main thread, it is
// detached before being destroyed.
//
// @param window The window to destroy.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @note The context of the specified window must not be current on any other
// thread when this function is called.
//
// @reentrancy
// This function must not be called from a callback.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_creation
//
// @sa
// @ref glfwCreateWindow
//
// @since Added in version 3.0.  Replaces `glfwCloseWindow`.
func DestroyWindow(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwDestroyWindow.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwWindowShouldClose bindlib.PreloadProc

// @brief Checks the close flag of the specified window.
// This function returns the value of the close flag of the specified window.
//
// @param window The window to query.
//
// @return The value of the close flag.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Access is not
// synchronized.
//
// @sa
// @ref window_close
//
// @since Added in version 3.0.
func WindowShouldClose(window unsafe.Pointer) int32 {
	__res := bindlib.CCall1(__imp_glfwWindowShouldClose.Addr(), bindlib.MarshallSyscall(window))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwSetWindowShouldClose bindlib.PreloadProc

// @brief Sets the close flag of the specified window.
// This function sets the value of the close flag of the specified window.
// This can be used to override the user's attempt to close the window, or
// to signal that it should be closed.
//
// @param window The window whose flag to change.
//
// @param value The new value.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Access is not
// synchronized.
//
// @sa
// @ref window_close
//
// @since Added in version 3.0.
func SetWindowShouldClose(window unsafe.Pointer, value int32) {
	bindlib.CCall2(__imp_glfwSetWindowShouldClose.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(value))
}

var __imp_glfwGetWindowTitle bindlib.PreloadProc

// @brief Returns the title of the specified window.
// This function returns the window title, encoded as UTF-8, of the specified
// window.  This is the title set previously by
// @ref glfwCreateWindow
// or
// @ref glfwSetWindowTitle.
//
// @param window The window to query.
//
// @return The UTF-8 encoded window title, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @remark The returned title is currently a copy of the title last set by
// @ref glfwCreateWindow
// or
// @ref glfwSetWindowTitle.
// It does not include any
// additional text which may be appended by the platform or another program.
//
// @pointer
// _lifetime The returned string is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the next call to
// @ref glfwGetWindowTitle
// or
// @ref glfwSetWindowTitle,
// or until the library is
// terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_title
//
// @sa
// @ref glfwSetWindowTitle
//
// @since Added in version 3.4.
func GetWindowTitle(window unsafe.Pointer) *byte {
	__res := bindlib.CCall1(__imp_glfwGetWindowTitle.Addr(), bindlib.MarshallSyscall(window))
	return bindlib.UnmarshallSyscall[*byte](__res)
}

var __imp_glfwSetWindowTitle bindlib.PreloadProc

// @brief Sets the title of the specified window.
// This function sets the window title, encoded as UTF-8, of the specified
// window.
//
// @param window The window whose title to change.
//
// @param title The UTF-8 encoded window title.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @macos
// The window title will not be updated until the next time you
// process events.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_title
//
// @sa
// @ref glfwGetWindowTitle
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter.
func SetWindowTitle(window unsafe.Pointer, title *byte) {
	bindlib.CCall2(__imp_glfwSetWindowTitle.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(title))
}

var __imp_glfwSetWindowIcon bindlib.PreloadProc

// @brief Sets the icon for the specified window.
// This function sets the icon of the specified window.  If passed an array of
// candidate images, those of or closest to the sizes desired by the system are
// selected.  If no images are specified, the window reverts to its default
// icon.
// The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight
// bits per channel with the red channel first.  They are arranged canonically
// as packed sequential rows, starting from the top-left corner.
// The desired image sizes varies depending on platform and system settings.
// The selected images will be rescaled as needed.  Good sizes include 16x16,
// 32x32 and 48x48.
//
// @param window The window whose icon to set.
//
// @param count The number of images in the specified array, or zero to
// revert to the default window icon.
//
// @param images The images to create the icon from.  This is ignored if
// count is zero.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_VALUE,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @pointer
// _lifetime The specified image data is copied before this function
// returns.
//
// @remark
// @macos
// Regular windows do not have icons on macOS.  This function
// will emit
// @ref GLFW_FEATURE_UNAVAILABLE.
// The dock icon will be the same as
// the application bundle's icon.  For more information on bundles, see the
// [Bundle Programming Guide][bundle-guide] in the Mac Developer Library.
// [bundle-guide]: https://developer.apple.com/library/mac/documentation/CoreFoundation/Conceptual/CFBundles/
//
// @remark
// @wayland
// There is no existing protocol to change an icon, the
// window will thus inherit the one defined in the application's desktop file.
// This function will emit
// @ref GLFW_FEATURE_UNAVAILABLE.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_icon
//
// @since Added in version 3.2.
func SetWindowIcon(window unsafe.Pointer, count int32, images *Image) {
	bindlib.CCall3(__imp_glfwSetWindowIcon.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(count), bindlib.MarshallSyscall(images))
}

var __imp_glfwGetWindowPos bindlib.PreloadProc

// @brief Retrieves the position of the content area of the specified window.
// This function retrieves the position, in screen coordinates, of the
// upper-left corner of the content area of the specified window.
// Any or all of the position arguments may be `NULL`.  If an error occurs, all
// non-`NULL` position arguments will be set to zero.
//
// @param window The window to query.
//
// @param xpos Where to store the x-coordinate of the upper-left corner of
// the content area, or `NULL`.
//
// @param ypos Where to store the y-coordinate of the upper-left corner of
// the content area, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @remark
// @wayland
// There is no way for an application to retrieve the global
// position of its windows.  This function will emit
// @ref GLFW_FEATURE_UNAVAILABLE.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_pos
//
// @sa
// @ref glfwSetWindowPos
//
// @since Added in version 3.0.
func GetWindowPos(window unsafe.Pointer, xpos *int32, ypos *int32) {
	bindlib.CCall3(__imp_glfwGetWindowPos.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(xpos), bindlib.MarshallSyscall(ypos))
}

var __imp_glfwSetWindowPos bindlib.PreloadProc

// @brief Sets the position of the content area of the specified window.
// This function sets the position, in screen coordinates, of the upper-left
// corner of the content area of the specified windowed mode window.  If the
// window is a full screen window, this function does nothing.
// __Do not use this function__ to move an already visible window unless you
// have very good reasons for doing so, as it will confuse and annoy the user.
// The window manager may put limits on what positions are allowed.  GLFW
// cannot and should not override these limits.
//
// @param window The window to query.
//
// @param xpos The x-coordinate of the upper-left corner of the content area.
//
// @param ypos The y-coordinate of the upper-left corner of the content area.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @remark
// @wayland
// There is no way for an application to set the global
// position of its windows.  This function will emit
// @ref GLFW_FEATURE_UNAVAILABLE.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_pos
//
// @sa
// @ref glfwGetWindowPos
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter.
func SetWindowPos(window unsafe.Pointer, xpos int32, ypos int32) {
	bindlib.CCall3(__imp_glfwSetWindowPos.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(xpos), bindlib.MarshallSyscall(ypos))
}

var __imp_glfwGetWindowSize bindlib.PreloadProc

// @brief Retrieves the size of the content area of the specified window.
// This function retrieves the size, in screen coordinates, of the content area
// of the specified window.  If you wish to retrieve the size of the
// framebuffer of the window in pixels, see
// @ref glfwGetFramebufferSize.
// Any or all of the size arguments may be `NULL`.  If an error occurs, all
// non-`NULL` size arguments will be set to zero.
//
// @param window The window whose size to retrieve.
//
// @param width Where to store the width, in screen coordinates, of the
// content area, or `NULL`.
//
// @param height Where to store the height, in screen coordinates, of the
// content area, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_size
//
// @sa
// @ref glfwSetWindowSize
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter.
func GetWindowSize(window unsafe.Pointer, width *int32, height *int32) {
	bindlib.CCall3(__imp_glfwGetWindowSize.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height))
}

var __imp_glfwSetWindowSizeLimits bindlib.PreloadProc

// @brief Sets the size limits of the specified window.
// This function sets the size limits of the content area of the specified
// window.  If the window is full screen, the size limits only take effect
// once it is made windowed.  If the window is not resizable, this function
// does nothing.
// The size limits are applied immediately to a windowed mode window and may
// cause it to be resized.
// The maximum dimensions must be greater than or equal to the minimum
// dimensions and all must be greater than or equal to zero.
//
// @param window The window to set limits for.
//
// @param minwidth The minimum width, in screen coordinates, of the content
// area, or `GLFW_DONT_CARE`.
//
// @param minheight The minimum height, in screen coordinates, of the
// content area, or `GLFW_DONT_CARE`.
//
// @param maxwidth The maximum width, in screen coordinates, of the content
// area, or `GLFW_DONT_CARE`.
//
// @param maxheight The maximum height, in screen coordinates, of the
// content area, or `GLFW_DONT_CARE`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_VALUE
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark If you set size limits and an aspect ratio that conflict, the
// results are undefined.
//
// @remark
// @wayland
// The size limits will not be applied until the window is
// actually resized, either by the user or by the compositor.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_sizelimits
//
// @sa
// @ref glfwSetWindowAspectRatio
//
// @since Added in version 3.2.
func SetWindowSizeLimits(window unsafe.Pointer, minwidth int32, minheight int32, maxwidth int32, maxheight int32) {
	bindlib.CCall5(__imp_glfwSetWindowSizeLimits.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(minwidth), bindlib.MarshallSyscall(minheight), bindlib.MarshallSyscall(maxwidth), bindlib.MarshallSyscall(maxheight))
}

var __imp_glfwSetWindowAspectRatio bindlib.PreloadProc

// @brief Sets the aspect ratio of the specified window.
// This function sets the required aspect ratio of the content area of the
// specified window.  If the window is full screen, the aspect ratio only takes
// effect once it is made windowed.  If the window is not resizable, this
// function does nothing.
// The aspect ratio is specified as a numerator and a denominator and both
// values must be greater than zero.  For example, the common 16:9 aspect ratio
// is specified as 16 and 9, respectively.
// If the numerator and denominator is set to `GLFW_DONT_CARE` then the aspect
// ratio limit is disabled.
// The aspect ratio is applied immediately to a windowed mode window and may
// cause it to be resized.
//
// @param window The window to set limits for.
//
// @param numer The numerator of the desired aspect ratio, or
// `GLFW_DONT_CARE`.
//
// @param denom The denominator of the desired aspect ratio, or
// `GLFW_DONT_CARE`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_VALUE
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark If you set size limits and an aspect ratio that conflict, the
// results are undefined.
//
// @remark
// @wayland
// The aspect ratio will not be applied until the window is
// actually resized, either by the user or by the compositor.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_sizelimits
//
// @sa
// @ref glfwSetWindowSizeLimits
//
// @since Added in version 3.2.
func SetWindowAspectRatio(window unsafe.Pointer, numer int32, denom int32) {
	bindlib.CCall3(__imp_glfwSetWindowAspectRatio.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(numer), bindlib.MarshallSyscall(denom))
}

var __imp_glfwSetWindowSize bindlib.PreloadProc

// @brief Sets the size of the content area of the specified window.
// This function sets the size, in screen coordinates, of the content area of
// the specified window.
// For full screen windows, this function updates the resolution of its desired
// video mode and switches to the video mode closest to it, without affecting
// the window's context.  As the context is unaffected, the bit depths of the
// framebuffer remain unchanged.
// If you wish to update the refresh rate of the desired video mode in addition
// to its resolution, see
// @ref glfwSetWindowMonitor.
// The window manager may put limits on what sizes are allowed.  GLFW cannot
// and should not override these limits.
//
// @param window The window to resize.
//
// @param width The desired width, in screen coordinates, of the window
// content area.
//
// @param height The desired height, in screen coordinates, of the window
// content area.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_size
//
// @sa
// @ref glfwGetWindowSize
//
// @sa
// @ref glfwSetWindowMonitor
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter.
func SetWindowSize(window unsafe.Pointer, width int32, height int32) {
	bindlib.CCall3(__imp_glfwSetWindowSize.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height))
}

var __imp_glfwGetFramebufferSize bindlib.PreloadProc

// @brief Retrieves the size of the framebuffer of the specified window.
// This function retrieves the size, in pixels, of the framebuffer of the
// specified window.  If you wish to retrieve the size of the window in screen
// coordinates, see
// @ref glfwGetWindowSize.
// Any or all of the size arguments may be `NULL`.  If an error occurs, all
// non-`NULL` size arguments will be set to zero.
//
// @param window The window whose framebuffer to query.
//
// @param width Where to store the width, in pixels, of the framebuffer,
// or `NULL`.
//
// @param height Where to store the height, in pixels, of the framebuffer,
// or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_fbsize
//
// @sa
// @ref glfwSetFramebufferSizeCallback
//
// @since Added in version 3.0.
func GetFramebufferSize(window unsafe.Pointer, width *int32, height *int32) {
	bindlib.CCall3(__imp_glfwGetFramebufferSize.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height))
}

var __imp_glfwGetWindowFrameSize bindlib.PreloadProc

// @brief Retrieves the size of the frame of the window.
// This function retrieves the size, in screen coordinates, of each edge of the
// frame of the specified window.  This size includes the title bar, if the
// window has one.  The size of the frame may vary depending on the
// [window-related hints](
// @ref window_hints_wnd)
// used to create it.
// Because this function retrieves the size of each window frame edge and not
// the offset along a particular coordinate axis, the retrieved values will
// always be zero or positive.
// Any or all of the size arguments may be `NULL`.  If an error occurs, all
// non-`NULL` size arguments will be set to zero.
//
// @param window The window whose frame size to query.
//
// @param left Where to store the size, in screen coordinates, of the left
// edge of the window frame, or `NULL`.
//
// @param top Where to store the size, in screen coordinates, of the top
// edge of the window frame, or `NULL`.
//
// @param right Where to store the size, in screen coordinates, of the
// right edge of the window frame, or `NULL`.
//
// @param bottom Where to store the size, in screen coordinates, of the
// bottom edge of the window frame, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_size
//
// @since Added in version 3.1.
func GetWindowFrameSize(window unsafe.Pointer, left *int32, top *int32, right *int32, bottom *int32) {
	bindlib.CCall5(__imp_glfwGetWindowFrameSize.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(left), bindlib.MarshallSyscall(top), bindlib.MarshallSyscall(right), bindlib.MarshallSyscall(bottom))
}

var __imp_glfwGetWindowContentScale bindlib.PreloadProc

// @brief Retrieves the content scale for the specified window.
// This function retrieves the content scale for the specified window.  The
// content scale is the ratio between the current DPI and the platform's
// default DPI.  This is especially important for text and any UI elements.  If
// the pixel dimensions of your UI scaled by this look appropriate on your
// machine then it should appear at a reasonable size on other machines
// regardless of their DPI and scaling settings.  This relies on the system DPI
// and scaling settings being somewhat correct.
// On platforms where each monitors can have its own content scale, the window
// content scale will depend on which monitor the system considers the window
// to be on.
//
// @param window The window to query.
//
// @param xscale Where to store the x-axis content scale, or `NULL`.
//
// @param yscale Where to store the y-axis content scale, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_scale
//
// @sa
// @ref glfwSetWindowContentScaleCallback
//
// @sa
// @ref glfwGetMonitorContentScale
//
// @since Added in version 3.3.
func GetWindowContentScale(window unsafe.Pointer, xscale *float32, yscale *float32) {
	bindlib.CCall3(__imp_glfwGetWindowContentScale.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(xscale), bindlib.MarshallSyscall(yscale))
}

var __imp_glfwGetWindowOpacity bindlib.PreloadProc

// @brief Returns the opacity of the whole window.
// This function returns the opacity of the window, including any decorations.
// The opacity (or alpha) value is a positive finite number between zero and
// one, where zero is fully transparent and one is fully opaque.  If the system
// does not support whole window transparency, this function always returns one.
// The initial opacity value for newly created windows is one.
//
// @param window The window to query.
//
// @return The opacity value of the specified window.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_transparency
//
// @sa
// @ref glfwSetWindowOpacity
//
// @since Added in version 3.3.
func GetWindowOpacity(window unsafe.Pointer) float32 {
	__res := bindlib.CCall1(__imp_glfwGetWindowOpacity.Addr(), bindlib.MarshallSyscall(window))
	return bindlib.UnmarshallSyscall[float32](__res)
}

var __imp_glfwSetWindowOpacity bindlib.PreloadProc

// @brief Sets the opacity of the whole window.
// This function sets the opacity of the window, including any decorations.
// The opacity (or alpha) value is a positive finite number between zero and
// one, where zero is fully transparent and one is fully opaque.
// The initial opacity value for newly created windows is one.
// A window created with framebuffer transparency may not use whole window
// transparency.  The results of doing this are undefined.
//
// @param window The window to set the opacity for.
//
// @param opacity The desired opacity of the specified window.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @remark
// @wayland
// There is no way to set an opacity factor for a window.
// This function will emit
// @ref GLFW_FEATURE_UNAVAILABLE.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_transparency
//
// @sa
// @ref glfwGetWindowOpacity
//
// @since Added in version 3.3.
func SetWindowOpacity(window unsafe.Pointer, opacity float32) {
	bindlib.CCall2(__imp_glfwSetWindowOpacity.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(opacity))
}

var __imp_glfwIconifyWindow bindlib.PreloadProc

// @brief Iconifies the specified window.
// This function iconifies (minimizes) the specified window if it was
// previously restored.  If the window is already iconified, this function does
// nothing.
// If the specified window is a full screen window, GLFW restores the original
// video mode of the monitor.  The window's desired video mode is set again
// when the window is restored.
//
// @param window The window to iconify.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @wayland
// Once a window is iconified,
// @ref glfwRestoreWindow
// won’t
// be able to restore it.  This is a design decision of the xdg-shell
// protocol.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_iconify
//
// @sa
// @ref glfwRestoreWindow
//
// @sa
// @ref glfwMaximizeWindow
//
// @since Added in version 2.1.
//
// @glfw3
// Added window handle parameter.
func IconifyWindow(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwIconifyWindow.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwRestoreWindow bindlib.PreloadProc

// @brief Restores the specified window.
// This function restores the specified window if it was previously iconified
// (minimized) or maximized.  If the window is already restored, this function
// does nothing.
// If the specified window is an iconified full screen window, its desired
// video mode is set again for its monitor when the window is restored.
//
// @param window The window to restore.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_iconify
//
// @sa
// @ref glfwIconifyWindow
//
// @sa
// @ref glfwMaximizeWindow
//
// @since Added in version 2.1.
//
// @glfw3
// Added window handle parameter.
func RestoreWindow(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwRestoreWindow.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwMaximizeWindow bindlib.PreloadProc

// @brief Maximizes the specified window.
// This function maximizes the specified window if it was previously not
// maximized.  If the window is already maximized, this function does nothing.
// If the specified window is a full screen window, this function does nothing.
//
// @param window The window to maximize.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @par Thread Safety
// This function may only be called from the main thread.
//
// @sa
// @ref window_iconify
//
// @sa
// @ref glfwIconifyWindow
//
// @sa
// @ref glfwRestoreWindow
//
// @since Added in GLFW 3.2.
func MaximizeWindow(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwMaximizeWindow.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwShowWindow bindlib.PreloadProc

// @brief Makes the specified window visible.
// This function makes the specified window visible if it was previously
// hidden.  If the window is already visible or is in full screen mode, this
// function does nothing.
// By default, windowed mode windows are focused when shown
// Set the [GLFW_FOCUS_ON_SHOW](
// @ref GLFW_FOCUS_ON_SHOW_hint)
// window hint
// to change this behavior for all newly created windows, or change the
// behavior for an existing window with
// @ref glfwSetWindowAttrib.
//
// @param window The window to make visible.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @wayland
// Because Wayland wants every frame of the desktop to be
// complete, this function does not immediately make the window visible.
// Instead it will become visible the next time the window framebuffer is
// updated after this call.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_hide
//
// @sa
// @ref glfwHideWindow
//
// @since Added in version 3.0.
func ShowWindow(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwShowWindow.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwHideWindow bindlib.PreloadProc

// @brief Hides the specified window.
// This function hides the specified window if it was previously visible.  If
// the window is already hidden or is in full screen mode, this function does
// nothing.
//
// @param window The window to hide.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_hide
//
// @sa
// @ref glfwShowWindow
//
// @since Added in version 3.0.
func HideWindow(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwHideWindow.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwFocusWindow bindlib.PreloadProc

// @brief Brings the specified window to front and sets input focus.
// This function brings the specified window to front and sets input focus.
// The window should already be visible and not iconified.
// By default, both windowed and full screen mode windows are focused when
// initially created.  Set the [GLFW_FOCUSED](
// @ref GLFW_FOCUSED_hint)
// to
// disable this behavior.
// Also by default, windowed mode windows are focused when shown
// with
// @ref glfwShowWindow.
// Set the
// [GLFW_FOCUS_ON_SHOW](
// @ref GLFW_FOCUS_ON_SHOW_hint)
// to disable this behavior.
// __Do not use this function__ to steal focus from other applications unless
// you are certain that is what the user wants.  Focus stealing can be
// extremely disruptive.
// For a less disruptive way of getting the user's attention, see
// [attention requests](
// @ref window_attention).
//
// @param window The window to give input focus.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @wayland
// The compositor will likely ignore focus requests unless
// another window created by the same application already has input focus.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_focus
//
// @sa
// @ref window_attention
//
// @since Added in version 3.2.
func FocusWindow(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwFocusWindow.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwRequestWindowAttention bindlib.PreloadProc

// @brief Requests user attention to the specified window.
// This function requests user attention to the specified window.  On
// platforms where this is not supported, attention is requested to the
// application as a whole.
// Once the user has given attention, usually by focusing the window or
// application, the system will end the request automatically.
//
// @param window The window to request attention to.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @macos
// Attention is requested to the application as a whole, not the
// specific window.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_attention
//
// @since Added in version 3.3.
func RequestWindowAttention(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwRequestWindowAttention.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwGetWindowMonitor bindlib.PreloadProc

// @brief Returns the monitor that the window uses for full screen mode.
// This function returns the handle of the monitor that the specified window is
// in full screen on.
//
// @param window The window to query.
//
// @return The monitor, or `NULL` if the window is in windowed mode or an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_monitor
//
// @sa
// @ref glfwSetWindowMonitor
//
// @since Added in version 3.0.
func GetWindowMonitor(window unsafe.Pointer) unsafe.Pointer {
	__res := bindlib.CCall1(__imp_glfwGetWindowMonitor.Addr(), bindlib.MarshallSyscall(window))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwSetWindowMonitor bindlib.PreloadProc

// @brief Sets the mode, monitor, video mode and placement of a window.
// This function sets the monitor that the window uses for full screen mode or,
// if the monitor is `NULL`, makes it windowed mode.
// When setting a monitor, this function updates the width, height and refresh
// rate of the desired video mode and switches to the video mode closest to it.
// The window position is ignored when setting a monitor.
// When the monitor is `NULL`, the position, width and height are used to
// place the window content area.  The refresh rate is ignored when no monitor
// is specified.
// If you only wish to update the resolution of a full screen window or the
// size of a windowed mode window, see
// @ref glfwSetWindowSize.
// When a window transitions from full screen to windowed mode, this function
// restores any previous window settings such as whether it is decorated,
// floating, resizable, has size or aspect ratio limits, etc.
//
// @param window The window whose monitor, size or video mode to set.
//
// @param monitor The desired monitor, or `NULL` to set windowed mode.
//
// @param xpos The desired x-coordinate of the upper-left corner of the
// content area.
//
// @param ypos The desired y-coordinate of the upper-left corner of the
// content area.
//
// @param width The desired with, in screen coordinates, of the content
// area or video mode.
//
// @param height The desired height, in screen coordinates, of the content
// area or video mode.
//
// @param refreshRate The desired refresh rate, in Hz, of the video mode,
// or `GLFW_DONT_CARE`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark The OpenGL or OpenGL ES context will not be destroyed or otherwise
// affected by any resizing or mode switching, although you may need to update
// your viewport if the framebuffer size has changed.
//
// @remark
// @wayland
// The desired window position is ignored, as there is no way
// for an application to set this property.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_monitor
//
// @sa
// @ref window_full_screen
//
// @sa
// @ref glfwGetWindowMonitor
//
// @sa
// @ref glfwSetWindowSize
//
// @since Added in version 3.2.
func SetWindowMonitor(window unsafe.Pointer, monitor unsafe.Pointer, xpos int32, ypos int32, width int32, height int32, refreshRate int32) {
	bindlib.CCall7(__imp_glfwSetWindowMonitor.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(monitor), bindlib.MarshallSyscall(xpos), bindlib.MarshallSyscall(ypos), bindlib.MarshallSyscall(width), bindlib.MarshallSyscall(height), bindlib.MarshallSyscall(refreshRate))
}

var __imp_glfwGetWindowAttrib bindlib.PreloadProc

// @brief Returns an attribute of the specified window.
// This function returns the value of an attribute of the specified window or
// its OpenGL or OpenGL ES context.
//
// @param window The window to query.
//
// @param attrib The [window attribute](
// @ref window_attribs)
// whose value to
// return.
//
// @return The value of the attribute, or zero if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark Framebuffer related hints are not window attributes.  See
// @ref window_attribs_fb
// for more information.
//
// @remark Zero is a valid value for many window and context related
// attributes so you cannot use a return value of zero as an indication of
// errors.  However, this function should not fail as long as it is passed
// valid arguments and the library has been [initialized](
// @ref intro_init).
//
// @remark
// @wayland
// The Wayland protocol provides no way to check whether a
// window is iconfied, so
// @ref GLFW_ICONIFIED
// always returns `GLFW_FALSE`.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_attribs
//
// @sa
// @ref glfwSetWindowAttrib
//
// @since Added in version 3.0.  Replaces `glfwGetWindowParam` and
// `glfwGetGLVersion`.
func GetWindowAttrib(window unsafe.Pointer, attrib int32) int32 {
	__res := bindlib.CCall2(__imp_glfwGetWindowAttrib.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(attrib))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwSetWindowAttrib bindlib.PreloadProc

// @brief Sets an attribute of the specified window.
// This function sets the value of an attribute of the specified window.
// The supported attributes are [GLFW_DECORATED](
// @ref GLFW_DECORATED_attrib),
// [GLFW_RESIZABLE](
// @ref GLFW_RESIZABLE_attrib),
// [GLFW_FLOATING](
// @ref GLFW_FLOATING_attrib),
// [GLFW_AUTO_ICONIFY](
// @ref GLFW_AUTO_ICONIFY_attrib)
// and
// [GLFW_FOCUS_ON_SHOW](
// @ref GLFW_FOCUS_ON_SHOW_attrib).
// [GLFW_MOUSE_PASSTHROUGH](
// @ref GLFW_MOUSE_PASSTHROUGH_attrib)
// Some of these attributes are ignored for full screen windows.  The new
// value will take effect if the window is later made windowed.
// Some of these attributes are ignored for windowed mode windows.  The new
// value will take effect if the window is later made full screen.
//
// @param window The window to set the attribute for.
//
// @param attrib A supported window attribute.
//
// @param value `GLFW_TRUE` or `GLFW_FALSE`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM,
//
// @ref GLFW_INVALID_VALUE,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @remark Calling
// @ref glfwGetWindowAttrib
// will always return the latest
// value, even if that value is ignored by the current mode of the window.
//
// @remark
// @wayland
// The [GLFW_FLOATING](
// @ref GLFW_FLOATING_attrib)
// window attribute is
// not supported.  Setting this will emit
// @ref GLFW_FEATURE_UNAVAILABLE.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_attribs
//
// @sa
// @ref glfwGetWindowAttrib
//
// @since Added in version 3.3.
func SetWindowAttrib(window unsafe.Pointer, attrib int32, value int32) {
	bindlib.CCall3(__imp_glfwSetWindowAttrib.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(attrib), bindlib.MarshallSyscall(value))
}

var __imp_glfwSetWindowUserPointer bindlib.PreloadProc

// @brief Sets the user pointer of the specified window.
// This function sets the user-defined pointer of the specified window.  The
// current value is retained until the window is destroyed.  The initial value
// is `NULL`.
//
// @param window The window whose pointer to set.
//
// @param pointer The new value.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Access is not
// synchronized.
//
// @sa
// @ref window_userptr
//
// @sa
// @ref glfwGetWindowUserPointer
//
// @since Added in version 3.0.
func SetWindowUserPointer(window unsafe.Pointer, pointer unsafe.Pointer) {
	bindlib.CCall2(__imp_glfwSetWindowUserPointer.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(pointer))
}

var __imp_glfwGetWindowUserPointer bindlib.PreloadProc

// @brief Returns the user pointer of the specified window.
// This function returns the current value of the user-defined pointer of the
// specified window.  The initial value is `NULL`.
//
// @param window The window whose pointer to return.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Access is not
// synchronized.
//
// @sa
// @ref window_userptr
//
// @sa
// @ref glfwSetWindowUserPointer
//
// @since Added in version 3.0.
func GetWindowUserPointer(window unsafe.Pointer) unsafe.Pointer {
	__res := bindlib.CCall1(__imp_glfwGetWindowUserPointer.Addr(), bindlib.MarshallSyscall(window))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwSetWindowPosCallback bindlib.PreloadProc

// @brief Sets the position callback for the specified window.
// This function sets the position callback of the specified window, which is
// called when the window is moved.  The callback is provided with the
// position, in screen coordinates, of the upper-left corner of the content
// area of the window.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWwindowposfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @remark
// @wayland
// This callback will never be called, as there is no way for
// an application to know its global position.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_pos
//
// @since Added in version 3.0.
func SetWindowPosCallback(window unsafe.Pointer, callback Windowposfun) Windowposfun {
	__res := bindlib.CCall2(__imp_glfwSetWindowPosCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Windowposfun](__res)
}

var __imp_glfwSetWindowSizeCallback bindlib.PreloadProc

// @brief Sets the size callback for the specified window.
// This function sets the size callback of the specified window, which is
// called when the window is resized.  The callback is provided with the size,
// in screen coordinates, of the content area of the window.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWwindowsizefun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_size
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter and return value.
func SetWindowSizeCallback(window unsafe.Pointer, callback Windowsizefun) Windowsizefun {
	__res := bindlib.CCall2(__imp_glfwSetWindowSizeCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Windowsizefun](__res)
}

var __imp_glfwSetWindowCloseCallback bindlib.PreloadProc

// @brief Sets the close callback for the specified window.
// This function sets the close callback of the specified window, which is
// called when the user attempts to close the window, for example by clicking
// the close widget in the title bar.
// The close flag is set before this callback is called, but you can modify it
// at any time with
// @ref glfwSetWindowShouldClose.
// The close callback is not triggered by
// @ref glfwDestroyWindow.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWwindowclosefun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @remark
// @macos
// Selecting Quit from the application menu will trigger the
// close callback for all windows.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_close
//
// @since Added in version 2.5.
//
// @glfw3
// Added window handle parameter and return value.
func SetWindowCloseCallback(window unsafe.Pointer, callback Windowclosefun) Windowclosefun {
	__res := bindlib.CCall2(__imp_glfwSetWindowCloseCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Windowclosefun](__res)
}

var __imp_glfwSetWindowRefreshCallback bindlib.PreloadProc

// @brief Sets the refresh callback for the specified window.
// This function sets the refresh callback of the specified window, which is
// called when the content area of the window needs to be redrawn, for example
// if the window has been exposed after having been covered by another window.
// On compositing window systems such as Aero, Compiz, Aqua or Wayland, where
// the window contents are saved off-screen, this callback may be called only
// very infrequently or never at all.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWwindowrefreshfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_refresh
//
// @since Added in version 2.5.
//
// @glfw3
// Added window handle parameter and return value.
func SetWindowRefreshCallback(window unsafe.Pointer, callback Windowrefreshfun) Windowrefreshfun {
	__res := bindlib.CCall2(__imp_glfwSetWindowRefreshCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Windowrefreshfun](__res)
}

var __imp_glfwSetWindowFocusCallback bindlib.PreloadProc

// @brief Sets the focus callback for the specified window.
// This function sets the focus callback of the specified window, which is
// called when the window gains or loses input focus.
// After the focus callback is called for a window that lost input focus,
// synthetic key and mouse button release events will be generated for all such
// that had been pressed.  For more information, see
// @ref glfwSetKeyCallback
// and
// @ref glfwSetMouseButtonCallback.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWwindowfocusfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_focus
//
// @since Added in version 3.0.
func SetWindowFocusCallback(window unsafe.Pointer, callback Windowfocusfun) Windowfocusfun {
	__res := bindlib.CCall2(__imp_glfwSetWindowFocusCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Windowfocusfun](__res)
}

var __imp_glfwSetWindowIconifyCallback bindlib.PreloadProc

// @brief Sets the iconify callback for the specified window.
// This function sets the iconification callback of the specified window, which
// is called when the window is iconified or restored.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWwindowiconifyfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_iconify
//
// @since Added in version 3.0.
func SetWindowIconifyCallback(window unsafe.Pointer, callback Windowiconifyfun) Windowiconifyfun {
	__res := bindlib.CCall2(__imp_glfwSetWindowIconifyCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Windowiconifyfun](__res)
}

var __imp_glfwSetWindowMaximizeCallback bindlib.PreloadProc

// @brief Sets the maximize callback for the specified window.
// This function sets the maximization callback of the specified window, which
// is called when the window is maximized or restored.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWwindowmaximizefun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_maximize
//
// @since Added in version 3.3.
func SetWindowMaximizeCallback(window unsafe.Pointer, callback Windowmaximizefun) Windowmaximizefun {
	__res := bindlib.CCall2(__imp_glfwSetWindowMaximizeCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Windowmaximizefun](__res)
}

var __imp_glfwSetFramebufferSizeCallback bindlib.PreloadProc

// @brief Sets the framebuffer resize callback for the specified window.
// This function sets the framebuffer resize callback of the specified window,
// which is called when the framebuffer of the specified window is resized.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWframebuffersizefun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_fbsize
//
// @since Added in version 3.0.
func SetFramebufferSizeCallback(window unsafe.Pointer, callback Framebuffersizefun) Framebuffersizefun {
	__res := bindlib.CCall2(__imp_glfwSetFramebufferSizeCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Framebuffersizefun](__res)
}

var __imp_glfwSetWindowContentScaleCallback bindlib.PreloadProc

// @brief Sets the window content scale callback for the specified window.
// This function sets the window content scale callback of the specified window,
// which is called when the content scale of the specified window changes.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWwindowcontentscalefun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref window_scale
//
// @sa
// @ref glfwGetWindowContentScale
//
// @since Added in version 3.3.
func SetWindowContentScaleCallback(window unsafe.Pointer, callback Windowcontentscalefun) Windowcontentscalefun {
	__res := bindlib.CCall2(__imp_glfwSetWindowContentScaleCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Windowcontentscalefun](__res)
}

var __imp_glfwPollEvents bindlib.PreloadProc

// @brief Processes all pending events.
// This function processes only those events that are already in the event
// queue and then returns immediately.  Processing events will cause the window
// and input callbacks associated with those events to be called.
// On some platforms, a window move, resize or menu operation will cause event
// processing to block.  This is due to how event processing is designed on
// those platforms.  You can use the
// [window refresh callback](
// @ref window_refresh)
// to redraw the contents of
// your window when necessary during such operations.
// Do not assume that callbacks you set will _only_ be called in response to
// event processing functions like this one.  While it is necessary to poll for
// events, window systems that require GLFW to register callbacks of its own
// can pass events to GLFW in response to many window system function calls.
// GLFW will pass those events on to the application callbacks before
// returning.
// Event processing is not required for joystick input to work.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @reentrancy
// This function must not be called from a callback.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref events
//
// @sa
// @ref glfwWaitEvents
//
// @sa
// @ref glfwWaitEventsTimeout
//
// @since Added in version 1.0.
func PollEvents() { bindlib.CCall0(__imp_glfwPollEvents.Addr()) }

var __imp_glfwWaitEvents bindlib.PreloadProc

// @brief Waits until events are queued and processes them.
// This function puts the calling thread to sleep until at least one event is
// available in the event queue.  Once one or more events are available,
// it behaves exactly like
// @ref glfwPollEvents,
// i.e. the events in the queue
// are processed and the function then returns immediately.  Processing events
// will cause the window and input callbacks associated with those events to be
// called.
// Since not all events are associated with callbacks, this function may return
// without a callback having been called even if you are monitoring all
// callbacks.
// On some platforms, a window move, resize or menu operation will cause event
// processing to block.  This is due to how event processing is designed on
// those platforms.  You can use the
// [window refresh callback](
// @ref window_refresh)
// to redraw the contents of
// your window when necessary during such operations.
// Do not assume that callbacks you set will _only_ be called in response to
// event processing functions like this one.  While it is necessary to poll for
// events, window systems that require GLFW to register callbacks of its own
// can pass events to GLFW in response to many window system function calls.
// GLFW will pass those events on to the application callbacks before
// returning.
// Event processing is not required for joystick input to work.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @reentrancy
// This function must not be called from a callback.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref events
//
// @sa
// @ref glfwPollEvents
//
// @sa
// @ref glfwWaitEventsTimeout
//
// @since Added in version 2.5.
func WaitEvents() { bindlib.CCall0(__imp_glfwWaitEvents.Addr()) }

var __imp_glfwWaitEventsTimeout bindlib.PreloadProc

// @brief Waits with timeout until events are queued and processes them.
// This function puts the calling thread to sleep until at least one event is
// available in the event queue, or until the specified timeout is reached.  If
// one or more events are available, it behaves exactly like
// @ref glfwPollEvents,
// i.e. the events in the queue are processed and the function
// then returns immediately.  Processing events will cause the window and input
// callbacks associated with those events to be called.
// The timeout value must be a positive finite number.
// Since not all events are associated with callbacks, this function may return
// without a callback having been called even if you are monitoring all
// callbacks.
// On some platforms, a window move, resize or menu operation will cause event
// processing to block.  This is due to how event processing is designed on
// those platforms.  You can use the
// [window refresh callback](
// @ref window_refresh)
// to redraw the contents of
// your window when necessary during such operations.
// Do not assume that callbacks you set will _only_ be called in response to
// event processing functions like this one.  While it is necessary to poll for
// events, window systems that require GLFW to register callbacks of its own
// can pass events to GLFW in response to many window system function calls.
// GLFW will pass those events on to the application callbacks before
// returning.
// Event processing is not required for joystick input to work.
//
// @param timeout The maximum amount of time, in seconds, to wait.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_VALUE
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @reentrancy
// This function must not be called from a callback.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref events
//
// @sa
// @ref glfwPollEvents
//
// @sa
// @ref glfwWaitEvents
//
// @since Added in version 3.2.
func WaitEventsTimeout(timeout float64) {
	bindlib.CCall1(__imp_glfwWaitEventsTimeout.Addr(), bindlib.MarshallSyscall(timeout))
}

var __imp_glfwPostEmptyEvent bindlib.PreloadProc

// @brief Posts an empty event to the event queue.
// This function posts an empty event from the current thread to the event
// queue, causing
// @ref glfwWaitEvents
// or
// @ref glfwWaitEventsTimeout
// to return.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref events
//
// @sa
// @ref glfwWaitEvents
//
// @sa
// @ref glfwWaitEventsTimeout
//
// @since Added in version 3.1.
func PostEmptyEvent() { bindlib.CCall0(__imp_glfwPostEmptyEvent.Addr()) }

var __imp_glfwGetInputMode bindlib.PreloadProc

// @brief Returns the value of an input option for the specified window.
// This function returns the value of an input option for the specified window.
// The mode must be one of
// @ref GLFW_CURSOR,
//
// @ref GLFW_STICKY_KEYS,
//
// @ref GLFW_STICKY_MOUSE_BUTTONS,
//
// @ref GLFW_LOCK_KEY_MODS
// or
//
// @ref GLFW_RAW_MOUSE_MOTION.
//
// @param window The window to query.
//
// @param mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,
// `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or
// `GLFW_RAW_MOUSE_MOTION`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref glfwSetInputMode
//
// @since Added in version 3.0.
func GetInputMode(window unsafe.Pointer, mode int32) int32 {
	__res := bindlib.CCall2(__imp_glfwGetInputMode.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(mode))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwSetInputMode bindlib.PreloadProc

// @brief Sets an input option for the specified window.
// This function sets an input mode option for the specified window.  The mode
// must be one of
// @ref GLFW_CURSOR,
//
// @ref GLFW_STICKY_KEYS,
//
// @ref GLFW_STICKY_MOUSE_BUTTONS,
//
// @ref GLFW_LOCK_KEY_MODS
//
// @ref GLFW_RAW_MOUSE_MOTION,
// or
// @ref GLFW_UNLIMITED_MOUSE_BUTTONS.
// If the mode is `GLFW_CURSOR`, the value must be one of the following cursor
// modes:
// - `GLFW_CURSOR_NORMAL` makes the cursor visible and behaving normally.
// - `GLFW_CURSOR_HIDDEN` makes the cursor invisible when it is over the
// content area of the window but does not restrict the cursor from leaving.
// - `GLFW_CURSOR_DISABLED` hides and grabs the cursor, providing virtual
// and unlimited cursor movement.  This is useful for implementing for
// example 3D camera controls.
// - `GLFW_CURSOR_CAPTURED` makes the cursor visible and confines it to the
// content area of the window.
// If the mode is `GLFW_STICKY_KEYS`, the value must be either `GLFW_TRUE` to
// enable sticky keys, or `GLFW_FALSE` to disable it.  If sticky keys are
// enabled, a key press will ensure that
// @ref glfwGetKey
// returns `GLFW_PRESS`
// the next time it is called even if the key had been released before the
// call.  This is useful when you are only interested in whether keys have been
// pressed but not when or in which order.
// If the mode is `GLFW_STICKY_MOUSE_BUTTONS`, the value must be either
// `GLFW_TRUE` to enable sticky mouse buttons, or `GLFW_FALSE` to disable it.
// If sticky mouse buttons are enabled, a mouse button press will ensure that
//
// @ref glfwGetMouseButton
// returns `GLFW_PRESS` the next time it is called even
// if the mouse button had been released before the call.  This is useful when
// you are only interested in whether mouse buttons have been pressed but not
// when or in which order.
// If the mode is `GLFW_LOCK_KEY_MODS`, the value must be either `GLFW_TRUE` to
// enable lock key modifier bits, or `GLFW_FALSE` to disable them.  If enabled,
// callbacks that receive modifier bits will also have the
// @ref GLFW_MOD_CAPS_LOCK
// bit set when the event was generated with Caps Lock on,
// and the
// @ref GLFW_MOD_NUM_LOCK
// bit when Num Lock was on.
// If the mode is `GLFW_RAW_MOUSE_MOTION`, the value must be either `GLFW_TRUE`
// to enable raw (unscaled and unaccelerated) mouse motion when the cursor is
// disabled, or `GLFW_FALSE` to disable it.  If raw motion is not supported,
// attempting to set this will emit
// @ref GLFW_FEATURE_UNAVAILABLE.
// Call
// @ref glfwRawMouseMotionSupported
// to check for support.
// If the mode is `GLFW_UNLIMITED_MOUSE_BUTTONS`, the value must be either
// `GLFW_TRUE` to disable the mouse button limit when calling the mouse button
// callback, or `GLFW_FALSE` to limit the mouse buttons sent to the callback
// to the mouse button token values up to `GLFW_MOUSE_BUTTON_LAST`.
//
// @param window The window whose input mode to set.
//
// @param mode One of `GLFW_CURSOR`, `GLFW_STICKY_KEYS`,
// `GLFW_STICKY_MOUSE_BUTTONS`, `GLFW_LOCK_KEY_MODS` or
// `GLFW_RAW_MOUSE_MOTION`.
//
// @param value The new value of the specified input mode.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see above).
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref glfwGetInputMode
//
// @since Added in version 3.0.  Replaces `glfwEnable` and `glfwDisable`.
func SetInputMode(window unsafe.Pointer, mode int32, value int32) {
	bindlib.CCall3(__imp_glfwSetInputMode.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(mode), bindlib.MarshallSyscall(value))
}

var __imp_glfwRawMouseMotionSupported bindlib.PreloadProc

// @brief Returns whether raw mouse motion is supported.
// This function returns whether raw mouse motion is supported on the current
// system.  This status does not change after GLFW has been initialized so you
// only need to check this once.  If you attempt to enable raw motion on
// a system that does not support it,
// @ref GLFW_PLATFORM_ERROR
// will be emitted.
// Raw mouse motion is closer to the actual motion of the mouse across
// a surface.  It is not affected by the scaling and acceleration applied to
// the motion of the desktop cursor.  That processing is suitable for a cursor
// while raw motion is better for controlling for example a 3D camera.  Because
// of this, raw mouse motion is only provided when the cursor is disabled.
//
// @return `GLFW_TRUE` if raw mouse motion is supported on the current machine,
// or `GLFW_FALSE` otherwise.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref raw_mouse_motion
//
// @sa
// @ref glfwSetInputMode
//
// @since Added in version 3.3.
func RawMouseMotionSupported() int32 {
	__res := bindlib.CCall0(__imp_glfwRawMouseMotionSupported.Addr())
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetKeyName bindlib.PreloadProc

// @brief Returns the layout-specific name of the specified printable key.
// This function returns the name of the specified printable key, encoded as
// UTF-8.  This is typically the character that key would produce without any
// modifier keys, intended for displaying key bindings to the user.  For dead
// keys, it is typically the diacritic it would add to a character.
// __Do not use this function__ for [text input](
// @ref input_char).
// You will
// break text input for many languages even if it happens to work for yours.
// If the key is `GLFW_KEY_UNKNOWN`, the scancode is used to identify the key,
// otherwise the scancode is ignored.  If you specify a non-printable key, or
// `GLFW_KEY_UNKNOWN` and a scancode that maps to a non-printable key, this
// function returns `NULL` but does not emit an error.
// This behavior allows you to always pass in the arguments in the
// [key callback](
// @ref input_key)
// without modification.
// The printable keys are:
// - `GLFW_KEY_APOSTROPHE`
// - `GLFW_KEY_COMMA`
// - `GLFW_KEY_MINUS`
// - `GLFW_KEY_PERIOD`
// - `GLFW_KEY_SLASH`
// - `GLFW_KEY_SEMICOLON`
// - `GLFW_KEY_EQUAL`
// - `GLFW_KEY_LEFT_BRACKET`
// - `GLFW_KEY_RIGHT_BRACKET`
// - `GLFW_KEY_BACKSLASH`
// - `GLFW_KEY_WORLD_1`
// - `GLFW_KEY_WORLD_2`
// - `GLFW_KEY_0` to `GLFW_KEY_9`
// - `GLFW_KEY_A` to `GLFW_KEY_Z`
// - `GLFW_KEY_KP_0` to `GLFW_KEY_KP_9`
// - `GLFW_KEY_KP_DECIMAL`
// - `GLFW_KEY_KP_DIVIDE`
// - `GLFW_KEY_KP_MULTIPLY`
// - `GLFW_KEY_KP_SUBTRACT`
// - `GLFW_KEY_KP_ADD`
// - `GLFW_KEY_KP_EQUAL`
// Names for printable keys depend on keyboard layout, while names for
// non-printable keys are the same across layouts but depend on the application
// language and should be localized along with other user interface text.
//
// @param key The key to query, or `GLFW_KEY_UNKNOWN`.
//
// @param scancode The scancode of the key to query.
//
// @return The UTF-8 encoded, layout-specific name of the key, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_VALUE,
//
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark The contents of the returned string may change when a keyboard
// layout change event is received.
//
// @pointer
// _lifetime The returned string is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref input_key_name
//
// @since Added in version 3.2.
func GetKeyName(key int32, scancode int32) *byte {
	__res := bindlib.CCall2(__imp_glfwGetKeyName.Addr(), bindlib.MarshallSyscall(key), bindlib.MarshallSyscall(scancode))
	return bindlib.UnmarshallSyscall[*byte](__res)
}

var __imp_glfwGetKeyScancode bindlib.PreloadProc

// @brief Returns the platform-specific scancode of the specified key.
// This function returns the platform-specific scancode of the specified key.
// If the specified [key token](
// @ref keys)
// corresponds to a physical key not
// supported on the current platform then this method will return `-1`.
// Calling this function with anything other than a key token will return `-1`
// and generate a
// @ref GLFW_INVALID_ENUM
// error.
//
// @param key Any [key token](
// @ref keys).
//
// @return The platform-specific scancode for the key, or `-1` if the key is
// not supported on the current platform or an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref input_key
//
// @since Added in version 3.3.
func GetKeyScancode(key int32) int32 {
	__res := bindlib.CCall1(__imp_glfwGetKeyScancode.Addr(), bindlib.MarshallSyscall(key))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetKey bindlib.PreloadProc

// @brief Returns the last reported state of a keyboard key for the specified
// window.
// This function returns the last state reported for the specified key to the
// specified window.  The returned state is one of `GLFW_PRESS` or
// `GLFW_RELEASE`.  The action `GLFW_REPEAT` is only reported to the key callback.
// If the
// @ref GLFW_STICKY_KEYS
// input mode is enabled, this function returns
// `GLFW_PRESS` the first time you call it for a key that was pressed, even if
// that key has already been released.
// The key functions deal with physical keys, with [key tokens](
// @ref keys)
// named after their use on the standard US keyboard layout.  If you want to
// input text, use the Unicode character callback instead.
// The [modifier key bit masks](
// @ref mods)
// are not key tokens and cannot be
// used with this function.
// __Do not use this function__ to implement [text input](
// @ref input_char).
//
// @param window The desired window.
//
// @param key The desired [keyboard key](
// @ref keys).
// `GLFW_KEY_UNKNOWN` is
// not a valid key for this function.
//
// @return One of `GLFW_PRESS` or `GLFW_RELEASE`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref input_key
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter.
func GetKey(window unsafe.Pointer, key int32) int32 {
	__res := bindlib.CCall2(__imp_glfwGetKey.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(key))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetMouseButton bindlib.PreloadProc

// @brief Returns the last reported state of a mouse button for the specified
// window.
// This function returns the last state reported for the specified mouse button
// to the specified window.  The returned state is one of `GLFW_PRESS` or
// `GLFW_RELEASE`.
// If the
// @ref GLFW_STICKY_MOUSE_BUTTONS
// input mode is enabled, this function
// returns `GLFW_PRESS` the first time you call it for a mouse button that was
// pressed, even if that mouse button has already been released.
// The
// @ref GLFW_UNLIMITED_MOUSE_BUTTONS
// input mode does not effect the
// limit on buttons which can be polled with this function.
//
// @param window The desired window.
//
// @param button The desired [mouse button token](
// @ref buttons).
//
// @return One of `GLFW_PRESS` or `GLFW_RELEASE`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref input_mouse_button
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter.
func GetMouseButton(window unsafe.Pointer, button int32) int32 {
	__res := bindlib.CCall2(__imp_glfwGetMouseButton.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(button))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetCursorPos bindlib.PreloadProc

// @brief Retrieves the position of the cursor relative to the content area of
// the window.
// This function returns the position of the cursor, in screen coordinates,
// relative to the upper-left corner of the content area of the specified
// window.
// If the cursor is disabled (with `GLFW_CURSOR_DISABLED`) then the cursor
// position is unbounded and limited only by the minimum and maximum values of
// a `double`.
// The coordinate can be converted to their integer equivalents with the
// `floor` function.  Casting directly to an integer type works for positive
// coordinates, but fails for negative ones.
// Any or all of the position arguments may be `NULL`.  If an error occurs, all
// non-`NULL` position arguments will be set to zero.
//
// @param window The desired window.
//
// @param xpos Where to store the cursor x-coordinate, relative to the
// left edge of the content area, or `NULL`.
//
// @param ypos Where to store the cursor y-coordinate, relative to the to
// top edge of the content area, or `NULL`.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref cursor_pos
//
// @sa
// @ref glfwSetCursorPos
//
// @since Added in version 3.0.  Replaces `glfwGetMousePos`.
func GetCursorPos(window unsafe.Pointer, xpos *float64, ypos *float64) {
	bindlib.CCall3(__imp_glfwGetCursorPos.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(xpos), bindlib.MarshallSyscall(ypos))
}

var __imp_glfwSetCursorPos bindlib.PreloadProc

// @brief Sets the position of the cursor, relative to the content area of the
// window.
// This function sets the position, in screen coordinates, of the cursor
// relative to the upper-left corner of the content area of the specified
// window.  The window must have input focus.  If the window does not have
// input focus when this function is called, it fails silently.
// __Do not use this function__ to implement things like camera controls.  GLFW
// already provides the `GLFW_CURSOR_DISABLED` cursor mode that hides the
// cursor, transparently re-centers it and provides unconstrained cursor
// motion.  See
// @ref glfwSetInputMode
// for more information.
// If the cursor mode is `GLFW_CURSOR_DISABLED` then the cursor position is
// unconstrained and limited only by the minimum and maximum values of
// a `double`.
//
// @param window The desired window.
//
// @param xpos The desired x-coordinate, relative to the left edge of the
// content area.
//
// @param ypos The desired y-coordinate, relative to the top edge of the
// content area.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_PLATFORM_ERROR
// and
// @ref GLFW_FEATURE_UNAVAILABLE
// (see remarks).
//
// @remark
// @wayland
// This function will only work when the cursor mode is
// `GLFW_CURSOR_DISABLED`, otherwise it will emit
// @ref GLFW_FEATURE_UNAVAILABLE.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref cursor_pos
//
// @sa
// @ref glfwGetCursorPos
//
// @since Added in version 3.0.  Replaces `glfwSetMousePos`.
func SetCursorPos(window unsafe.Pointer, xpos float64, ypos float64) {
	bindlib.CCall3(__imp_glfwSetCursorPos.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(xpos), bindlib.MarshallSyscall(ypos))
}

var __imp_glfwCreateCursor bindlib.PreloadProc

// @brief Creates a custom cursor.
// Creates a new custom cursor image that can be set for a window with
// @ref glfwSetCursor.
// The cursor can be destroyed with
// @ref glfwDestroyCursor.
// Any remaining cursors are destroyed by
// @ref glfwTerminate.
// The pixels are 32-bit, little-endian, non-premultiplied RGBA, i.e. eight
// bits per channel with the red channel first.  They are arranged canonically
// as packed sequential rows, starting from the top-left corner.
// The cursor hotspot is specified in pixels, relative to the upper-left corner
// of the cursor image.  Like all other coordinate systems in GLFW, the X-axis
// points to the right and the Y-axis points down.
//
// @param image The desired cursor image.
//
// @param xhot The desired x-coordinate, in pixels, of the cursor hotspot.
//
// @param yhot The desired y-coordinate, in pixels, of the cursor hotspot.
//
// @return The handle of the created cursor, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_VALUE
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @pointer
// _lifetime The specified image data is copied before this function
// returns.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref cursor_object
//
// @sa
// @ref glfwDestroyCursor
//
// @sa
// @ref glfwCreateStandardCursor
//
// @since Added in version 3.1.
func CreateCursor(image *Image, xhot int32, yhot int32) unsafe.Pointer {
	__res := bindlib.CCall3(__imp_glfwCreateCursor.Addr(), bindlib.MarshallSyscall(image), bindlib.MarshallSyscall(xhot), bindlib.MarshallSyscall(yhot))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwCreateStandardCursor bindlib.PreloadProc

// @brief Creates a cursor with a standard shape.
// Returns a cursor with a standard shape, that can be set for a window with
//
// @ref glfwSetCursor.
// The images for these cursors come from the system
// cursor theme and their exact appearance will vary between platforms.
// Most of these shapes are guaranteed to exist on every supported platform but
// a few may not be present.  See the table below for details.
// Cursor shape                   | Windows | macOS | X11    | Wayland
// ------------------------------ | ------- | ----- | ------ | -------
//
// @ref GLFW_ARROW_CURSOR
// | Yes     | Yes   | Yes    | Yes
//
// @ref GLFW_IBEAM_CURSOR
// | Yes     | Yes   | Yes    | Yes
//
// @ref GLFW_CROSSHAIR_CURSOR
// | Yes     | Yes   | Yes    | Yes
//
// @ref GLFW_POINTING_HAND_CURSOR
// | Yes     | Yes   | Yes    | Yes
//
// @ref GLFW_RESIZE_EW_CURSOR
// | Yes     | Yes   | Yes    | Yes
//
// @ref GLFW_RESIZE_NS_CURSOR
// | Yes     | Yes   | Yes    | Yes
//
// @ref GLFW_RESIZE_NWSE_CURSOR
// | Yes     | Yes
// 1
// | Maybe
// 2
// | Maybe
// 2
//
// @ref GLFW_RESIZE_NESW_CURSOR
// | Yes     | Yes
// 1
// | Maybe
// 2
// | Maybe
// 2
//
// @ref GLFW_RESIZE_ALL_CURSOR
// | Yes     | Yes   | Yes    | Yes
//
// @ref GLFW_NOT_ALLOWED_CURSOR
// | Yes     | Yes   | Maybe
// 2
// | Maybe
// 2
// 1) This uses a private system API and may fail in the future.
// 2) This uses a newer standard that not all cursor themes support.
// If the requested shape is not available, this function emits a
// @ref GLFW_CURSOR_UNAVAILABLE
// error and returns `NULL`.
//
// @param shape One of the [standard shapes](
// @ref shapes).
//
// @return A new cursor ready to use or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM,
//
// @ref GLFW_CURSOR_UNAVAILABLE
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref cursor_standard
//
// @sa
// @ref glfwCreateCursor
//
// @since Added in version 3.1.
func CreateStandardCursor(shape int32) unsafe.Pointer {
	__res := bindlib.CCall1(__imp_glfwCreateStandardCursor.Addr(), bindlib.MarshallSyscall(shape))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwDestroyCursor bindlib.PreloadProc

// @brief Destroys a cursor.
// This function destroys a cursor previously created with
// @ref glfwCreateCursor.
// Any remaining cursors will be destroyed by
// @ref glfwTerminate.
// If the specified cursor is current for any window, that window will be
// reverted to the default cursor.  This does not affect the cursor mode.
//
// @param cursor The cursor object to destroy.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @reentrancy
// This function must not be called from a callback.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref cursor_object
//
// @sa
// @ref glfwCreateCursor
//
// @since Added in version 3.1.
func DestroyCursor(cursor unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwDestroyCursor.Addr(), bindlib.MarshallSyscall(cursor))
}

var __imp_glfwSetCursor bindlib.PreloadProc

// @brief Sets the cursor for the window.
// This function sets the cursor image to be used when the cursor is over the
// content area of the specified window.  The set cursor will only be visible
// when the [cursor mode](
// @ref cursor_mode)
// of the window is
// `GLFW_CURSOR_NORMAL`.
// On some platforms, the set cursor may not be visible unless the window also
// has input focus.
//
// @param window The window to set the cursor for.
//
// @param cursor The cursor to set, or `NULL` to switch back to the default
// arrow cursor.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref cursor_object
//
// @since Added in version 3.1.
func SetCursor(window unsafe.Pointer, cursor unsafe.Pointer) {
	bindlib.CCall2(__imp_glfwSetCursor.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(cursor))
}

var __imp_glfwSetKeyCallback bindlib.PreloadProc

// @brief Sets the key callback.
// This function sets the key callback of the specified window, which is called
// when a key is pressed, repeated or released.
// The key functions deal with physical keys, with layout independent
// [key tokens](
// @ref keys)
// named after their values in the standard US keyboard
// layout.  If you want to input text, use the
// [character callback](
// @ref glfwSetCharCallback)
// instead.
// When a window loses input focus, it will generate synthetic key release
// events for all pressed keys with associated key tokens.  You can tell these
// events from user-generated events by the fact that the synthetic ones are
// generated after the focus loss event has been processed, i.e. after the
// [window focus callback](
// @ref glfwSetWindowFocusCallback)
// has been called.
// The scancode of a key is specific to that platform or sometimes even to that
// machine.  Scancodes are intended to allow users to bind keys that don't have
// a GLFW key token.  Such keys have `key` set to `GLFW_KEY_UNKNOWN`, their
// state is not saved and so it cannot be queried with
// @ref glfwGetKey.
// Sometimes GLFW needs to generate synthetic key events, in which case the
// scancode may be zero.
//
// @param window The window whose callback to set.
//
// @param callback The new key callback, or `NULL` to remove the currently
// set callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWkeyfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref input_key
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter and return value.
func SetKeyCallback(window unsafe.Pointer, callback Keyfun) Keyfun {
	__res := bindlib.CCall2(__imp_glfwSetKeyCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Keyfun](__res)
}

var __imp_glfwSetCharCallback bindlib.PreloadProc

// @brief Sets the Unicode character callback.
// This function sets the character callback of the specified window, which is
// called when a Unicode character is input.
// The character callback is intended for Unicode text input.  As it deals with
// characters, it is keyboard layout dependent, whereas the
// [key callback](
// @ref glfwSetKeyCallback)
// is not.  Characters do not map 1:1
// to physical keys, as a key may produce zero, one or more characters.  If you
// want to know whether a specific physical key was pressed or released, see
// the key callback instead.
// The character callback behaves as system text input normally does and will
// not be called if modifier keys are held down that would prevent normal text
// input on that platform, for example a Super (Command) key on macOS or Alt key
// on Windows.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWcharfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref input_char
//
// @since Added in version 2.4.
//
// @glfw3
// Added window handle parameter and return value.
func SetCharCallback(window unsafe.Pointer, callback Charfun) Charfun {
	__res := bindlib.CCall2(__imp_glfwSetCharCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Charfun](__res)
}

var __imp_glfwSetCharModsCallback bindlib.PreloadProc

// @brief Sets the Unicode character with modifiers callback.
// This function sets the character with modifiers callback of the specified
// window, which is called when a Unicode character is input regardless of what
// modifier keys are used.
// The character with modifiers callback is intended for implementing custom
// Unicode character input.  For regular Unicode text input, see the
// [character callback](
// @ref glfwSetCharCallback).
// Like the character
// callback, the character with modifiers callback deals with characters and is
// keyboard layout dependent.  Characters do not map 1:1 to physical keys, as
// a key may produce zero, one or more characters.  If you want to know whether
// a specific physical key was pressed or released, see the
// [key callback](
// @ref glfwSetKeyCallback)
// instead.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or an
// [error](
// @ref error_handling)
// occurred.
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWcharmodsfun).
//
// @deprecated Scheduled for removal in version 4.0.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref input_char
//
// @since Added in version 3.1.
func SetCharModsCallback(window unsafe.Pointer, callback Charmodsfun) Charmodsfun {
	__res := bindlib.CCall2(__imp_glfwSetCharModsCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Charmodsfun](__res)
}

var __imp_glfwSetMouseButtonCallback bindlib.PreloadProc

// @brief Sets the mouse button callback.
// This function sets the mouse button callback of the specified window, which
// is called when a mouse button is pressed or released.
// When a window loses input focus, it will generate synthetic mouse button
// release events for all pressed mouse buttons with associated button tokens.
// You can tell these events from user-generated events by the fact that the
// synthetic ones are generated after the focus loss event has been processed,
// i.e. after the [window focus callback](
// @ref glfwSetWindowFocusCallback)
// has
// been called.
// The reported `button` value can be higher than `GLFW_MOUSE_BUTTON_LAST` if
// the button does not have an associated [button token](
// @ref buttons)
// and the
//
// @ref GLFW_UNLIMITED_MOUSE_BUTTONS
// input mode is set.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWmousebuttonfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref input_mouse_button
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter and return value.
func SetMouseButtonCallback(window unsafe.Pointer, callback Mousebuttonfun) Mousebuttonfun {
	__res := bindlib.CCall2(__imp_glfwSetMouseButtonCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Mousebuttonfun](__res)
}

var __imp_glfwSetCursorPosCallback bindlib.PreloadProc

// @brief Sets the cursor position callback.
// This function sets the cursor position callback of the specified window,
// which is called when the cursor is moved.  The callback is provided with the
// position, in screen coordinates, relative to the upper-left corner of the
// content area of the window.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWcursorposfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref cursor_pos
//
// @since Added in version 3.0.  Replaces `glfwSetMousePosCallback`.
func SetCursorPosCallback(window unsafe.Pointer, callback Cursorposfun) Cursorposfun {
	__res := bindlib.CCall2(__imp_glfwSetCursorPosCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Cursorposfun](__res)
}

var __imp_glfwSetCursorEnterCallback bindlib.PreloadProc

// @brief Sets the cursor enter/leave callback.
// This function sets the cursor boundary crossing callback of the specified
// window, which is called when the cursor enters or leaves the content area of
// the window.
//
// @param window The window whose callback to set.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWcursorenterfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref cursor_enter
//
// @since Added in version 3.0.
func SetCursorEnterCallback(window unsafe.Pointer, callback Cursorenterfun) Cursorenterfun {
	__res := bindlib.CCall2(__imp_glfwSetCursorEnterCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Cursorenterfun](__res)
}

var __imp_glfwSetScrollCallback bindlib.PreloadProc

// @brief Sets the scroll callback.
// This function sets the scroll callback of the specified window, which is
// called when a scrolling device is used, such as a mouse wheel or scrolling
// area of a touchpad.
// The scroll callback receives all scrolling input, like that from a mouse
// wheel or a touchpad scrolling area.
//
// @param window The window whose callback to set.
//
// @param callback The new scroll callback, or `NULL` to remove the
// currently set callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWscrollfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref scrolling
//
// @since Added in version 3.0.  Replaces `glfwSetMouseWheelCallback`.
func SetScrollCallback(window unsafe.Pointer, callback Scrollfun) Scrollfun {
	__res := bindlib.CCall2(__imp_glfwSetScrollCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Scrollfun](__res)
}

var __imp_glfwSetDropCallback bindlib.PreloadProc

// @brief Sets the path drop callback.
// This function sets the path drop callback of the specified window, which is
// called when one or more dragged paths are dropped on the window.
// Because the path array and its strings may have been generated specifically
// for that event, they are not guaranteed to be valid after the callback has
// returned.  If you wish to use them after the callback returns, you need to
// make a deep copy.
//
// @param window The window whose callback to set.
//
// @param callback The new file drop callback, or `NULL` to remove the
// currently set callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWdropfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref path_drop
//
// @since Added in version 3.1.
func SetDropCallback(window unsafe.Pointer, callback Dropfun) Dropfun {
	__res := bindlib.CCall2(__imp_glfwSetDropCallback.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Dropfun](__res)
}

var __imp_glfwJoystickPresent bindlib.PreloadProc

// @brief Returns whether the specified joystick is present.
// This function returns whether the specified joystick is present.
// There is no need to call this function before other functions that accept
// a joystick ID, as they all check for presence before performing any other
// work.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @return `GLFW_TRUE` if the joystick is present, or `GLFW_FALSE` otherwise.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref joystick
//
// @since Added in version 3.0.  Replaces `glfwGetJoystickParam`.
func JoystickPresent(jid int32) int32 {
	__res := bindlib.CCall1(__imp_glfwJoystickPresent.Addr(), bindlib.MarshallSyscall(jid))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetJoystickAxes bindlib.PreloadProc

// @brief Returns the values of all axes of the specified joystick.
// This function returns the values of all axes of the specified joystick.
// Each element in the array is a value between -1.0 and 1.0.
// If the specified joystick is not present this function will return `NULL`
// but will not generate an error.  This can be used instead of first calling
//
// @ref glfwJoystickPresent.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @param count Where to store the number of axis values in the returned
// array.  This is set to zero if the joystick is not present or an error
// occurred.
//
// @return An array of axis values, or `NULL` if the joystick is not present or
// an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @pointer
// _lifetime The returned array is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified joystick is
// disconnected or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref joystick_axis
//
// @since Added in version 3.0.  Replaces `glfwGetJoystickPos`.
func GetJoystickAxes(jid int32, count *int32) *float32 {
	__res := bindlib.CCall2(__imp_glfwGetJoystickAxes.Addr(), bindlib.MarshallSyscall(jid), bindlib.MarshallSyscall(count))
	return bindlib.UnmarshallSyscall[*float32](__res)
}

var __imp_glfwGetJoystickButtons bindlib.PreloadProc

// @brief Returns the state of all buttons of the specified joystick.
// This function returns the state of all buttons of the specified joystick.
// Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`.
// For backward compatibility with earlier versions that did not have
// @ref glfwGetJoystickHats,
// the button array also includes all hats, each
// represented as four buttons.  The hats are in the same order as returned by
// __glfwGetJoystickHats__ and are in the order _up_, _right_, _down_ and
// _left_.  To disable these extra buttons, set the
// @ref GLFW_JOYSTICK_HAT_BUTTONS
// init hint before initialization.
// If the specified joystick is not present this function will return `NULL`
// but will not generate an error.  This can be used instead of first calling
//
// @ref glfwJoystickPresent.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @param count Where to store the number of button states in the returned
// array.  This is set to zero if the joystick is not present or an error
// occurred.
//
// @return An array of button states, or `NULL` if the joystick is not present
// or an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @pointer
// _lifetime The returned array is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified joystick is
// disconnected or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref joystick_button
//
// @since Added in version 2.2.
//
// @glfw3
// Changed to return a dynamic array.
func GetJoystickButtons(jid int32, count *int32) *uint8 {
	__res := bindlib.CCall2(__imp_glfwGetJoystickButtons.Addr(), bindlib.MarshallSyscall(jid), bindlib.MarshallSyscall(count))
	return bindlib.UnmarshallSyscall[*uint8](__res)
}

var __imp_glfwGetJoystickHats bindlib.PreloadProc

// @brief Returns the state of all hats of the specified joystick.
// This function returns the state of all hats of the specified joystick.
// Each element in the array is one of the following values:
// Name                  | Value
// ----                  | -----
// `GLFW_HAT_CENTERED`   | 0
// `GLFW_HAT_UP`         | 1
// `GLFW_HAT_RIGHT`      | 2
// `GLFW_HAT_DOWN`       | 4
// `GLFW_HAT_LEFT`       | 8
// `GLFW_HAT_RIGHT_UP`   | `GLFW_HAT_RIGHT`
// \
// | `GLFW_HAT_UP`
// `GLFW_HAT_RIGHT_DOWN` | `GLFW_HAT_RIGHT`
// \
// | `GLFW_HAT_DOWN`
// `GLFW_HAT_LEFT_UP`    | `GLFW_HAT_LEFT`
// \
// | `GLFW_HAT_UP`
// `GLFW_HAT_LEFT_DOWN`  | `GLFW_HAT_LEFT`
// \
// | `GLFW_HAT_DOWN`
// The diagonal directions are bitwise combinations of the primary (up, right,
// down and left) directions and you can test for these individually by ANDing
// it with the corresponding direction.
//
// If the specified joystick is not present this function will return `NULL`
// but will not generate an error.  This can be used instead of first calling
//
// @ref glfwJoystickPresent.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @param count Where to store the number of hat states in the returned
// array.  This is set to zero if the joystick is not present or an error
// occurred.
//
// @return An array of hat states, or `NULL` if the joystick is not present
// or an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @pointer
// _lifetime The returned array is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified joystick is
// disconnected, this function is called again for that joystick or the library
// is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref joystick_hat
//
// @since Added in version 3.3.
func GetJoystickHats(jid int32, count *int32) *uint8 {
	__res := bindlib.CCall2(__imp_glfwGetJoystickHats.Addr(), bindlib.MarshallSyscall(jid), bindlib.MarshallSyscall(count))
	return bindlib.UnmarshallSyscall[*uint8](__res)
}

var __imp_glfwGetJoystickName bindlib.PreloadProc

// @brief Returns the name of the specified joystick.
// This function returns the name, encoded as UTF-8, of the specified joystick.
// The returned string is allocated and freed by GLFW.  You should not free it
// yourself.
// If the specified joystick is not present this function will return `NULL`
// but will not generate an error.  This can be used instead of first calling
//
// @ref glfwJoystickPresent.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @return The UTF-8 encoded name of the joystick, or `NULL` if the joystick
// is not present or an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @pointer
// _lifetime The returned string is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified joystick is
// disconnected or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref joystick_name
//
// @since Added in version 3.0.
func GetJoystickName(jid int32) *byte {
	__res := bindlib.CCall1(__imp_glfwGetJoystickName.Addr(), bindlib.MarshallSyscall(jid))
	return bindlib.UnmarshallSyscall[*byte](__res)
}

var __imp_glfwGetJoystickGUID bindlib.PreloadProc

// @brief Returns the SDL compatible GUID of the specified joystick.
// This function returns the SDL compatible GUID, as a UTF-8 encoded
// hexadecimal string, of the specified joystick.  The returned string is
// allocated and freed by GLFW.  You should not free it yourself.
// The GUID is what connects a joystick to a gamepad mapping.  A connected
// joystick will always have a GUID even if there is no gamepad mapping
// assigned to it.
// If the specified joystick is not present this function will return `NULL`
// but will not generate an error.  This can be used instead of first calling
//
// @ref glfwJoystickPresent.
// The GUID uses the format introduced in SDL 2.0.5.  This GUID tries to
// uniquely identify the make and model of a joystick but does not identify
// a specific unit, e.g. all wired Xbox 360 controllers will have the same
// GUID on that platform.  The GUID for a unit may vary between platforms
// depending on what hardware information the platform specific APIs provide.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @return The UTF-8 encoded GUID of the joystick, or `NULL` if the joystick
// is not present or an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_INVALID_ENUM
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @pointer
// _lifetime The returned string is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified joystick is
// disconnected or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref gamepad
//
// @since Added in version 3.3.
func GetJoystickGUID(jid int32) *byte {
	__res := bindlib.CCall1(__imp_glfwGetJoystickGUID.Addr(), bindlib.MarshallSyscall(jid))
	return bindlib.UnmarshallSyscall[*byte](__res)
}

var __imp_glfwSetJoystickUserPointer bindlib.PreloadProc

// @brief Sets the user pointer of the specified joystick.
// This function sets the user-defined pointer of the specified joystick.  The
// current value is retained until the joystick is disconnected.  The initial
// value is `NULL`.
// This function may be called from the joystick callback, even for a joystick
// that is being disconnected.
//
// @param jid The joystick whose pointer to set.
//
// @param pointer The new value.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Access is not
// synchronized.
//
// @sa
// @ref joystick_userptr
//
// @sa
// @ref glfwGetJoystickUserPointer
//
// @since Added in version 3.3.
func SetJoystickUserPointer(jid int32, pointer unsafe.Pointer) {
	bindlib.CCall2(__imp_glfwSetJoystickUserPointer.Addr(), bindlib.MarshallSyscall(jid), bindlib.MarshallSyscall(pointer))
}

var __imp_glfwGetJoystickUserPointer bindlib.PreloadProc

// @brief Returns the user pointer of the specified joystick.
// This function returns the current value of the user-defined pointer of the
// specified joystick.  The initial value is `NULL`.
// This function may be called from the joystick callback, even for a joystick
// that is being disconnected.
//
// @param jid The joystick whose pointer to return.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Access is not
// synchronized.
//
// @sa
// @ref joystick_userptr
//
// @sa
// @ref glfwSetJoystickUserPointer
//
// @since Added in version 3.3.
func GetJoystickUserPointer(jid int32) unsafe.Pointer {
	__res := bindlib.CCall1(__imp_glfwGetJoystickUserPointer.Addr(), bindlib.MarshallSyscall(jid))
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwJoystickIsGamepad bindlib.PreloadProc

// @brief Returns whether the specified joystick has a gamepad mapping.
// This function returns whether the specified joystick is both present and has
// a gamepad mapping.
// If the specified joystick is present but does not have a gamepad mapping
// this function will return `GLFW_FALSE` but will not generate an error.  Call
//
// @ref glfwJoystickPresent
// to check if a joystick is present regardless of
// whether it has a mapping.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @return `GLFW_TRUE` if a joystick is both present and has a gamepad mapping,
// or `GLFW_FALSE` otherwise.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref gamepad
//
// @sa
// @ref glfwGetGamepadState
//
// @since Added in version 3.3.
func JoystickIsGamepad(jid int32) int32 {
	__res := bindlib.CCall1(__imp_glfwJoystickIsGamepad.Addr(), bindlib.MarshallSyscall(jid))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwSetJoystickCallback bindlib.PreloadProc

// @brief Sets the joystick configuration callback.
// This function sets the joystick configuration callback, or removes the
// currently set callback.  This is called when a joystick is connected to or
// disconnected from the system.
// For joystick connection and disconnection events to be delivered on all
// platforms, you need to call one of the [event processing](
// @ref events)
// functions.  Joystick disconnection may also be detected and the callback
// called by joystick functions.  The function will then return whatever it
// returns if the joystick is not present.
//
// @param callback The new callback, or `NULL` to remove the currently set
// callback.
//
// @return The previously set callback, or `NULL` if no callback was set or the
// library had not been [initialized](
// @ref intro_init).
//
// For more information about the callback parameters, see the
// [function pointer type](
// @ref GLFWjoystickfun).
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref joystick_event
//
// @since Added in version 3.2.
func SetJoystickCallback(callback Joystickfun) Joystickfun {
	__res := bindlib.CCall1(__imp_glfwSetJoystickCallback.Addr(), bindlib.MarshallSyscall(callback))
	return bindlib.UnmarshallSyscall[Joystickfun](__res)
}

var __imp_glfwUpdateGamepadMappings bindlib.PreloadProc

// @brief Adds the specified SDL_GameControllerDB gamepad mappings.
// This function parses the specified ASCII encoded string and updates the
// internal list with any gamepad mappings it finds.  This string may
// contain either a single gamepad mapping or many mappings separated by
// newlines.  The parser supports the full format of the `gamecontrollerdb.txt`
// source file including empty lines and comments.
// See
// @ref gamepad_mapping
// for a description of the format.
// If there is already a gamepad mapping for a given GUID in the internal list,
// it will be replaced by the one passed to this function.  If the library is
// terminated and re-initialized the internal list will revert to the built-in
// default.
//
// @param string The string containing the gamepad mappings.
//
// @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_VALUE.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref gamepad
//
// @sa
// @ref glfwJoystickIsGamepad
//
// @sa
// @ref glfwGetGamepadName
//
// @since Added in version 3.3.
func UpdateGamepadMappings(_string *byte) int32 {
	__res := bindlib.CCall1(__imp_glfwUpdateGamepadMappings.Addr(), bindlib.MarshallSyscall(_string))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetGamepadName bindlib.PreloadProc

// @brief Returns the human-readable gamepad name for the specified joystick.
// This function returns the human-readable name of the gamepad from the
// gamepad mapping assigned to the specified joystick.
// If the specified joystick is not present or does not have a gamepad mapping
// this function will return `NULL` but will not generate an error.  Call
//
// @ref glfwJoystickPresent
// to check whether it is present regardless of
// whether it has a mapping.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @return The UTF-8 encoded name of the gamepad, or `NULL` if the
// joystick is not present, does not have a mapping or an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @pointer
// _lifetime The returned string is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the specified joystick is
// disconnected, the gamepad mappings are updated or the library is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref gamepad
//
// @sa
// @ref glfwJoystickIsGamepad
//
// @since Added in version 3.3.
func GetGamepadName(jid int32) *byte {
	__res := bindlib.CCall1(__imp_glfwGetGamepadName.Addr(), bindlib.MarshallSyscall(jid))
	return bindlib.UnmarshallSyscall[*byte](__res)
}

var __imp_glfwGetGamepadState bindlib.PreloadProc

// @brief Retrieves the state of the specified joystick remapped as a gamepad.
// This function retrieves the state of the specified joystick remapped to
// an Xbox-like gamepad.
// If the specified joystick is not present or does not have a gamepad mapping
// this function will return `GLFW_FALSE` but will not generate an error.  Call
//
// @ref glfwJoystickPresent
// to check whether it is present regardless of
// whether it has a mapping.
// The Guide button may not be available for input as it is often hooked by the
// system or the Steam client.
// Not all devices have all the buttons or axes provided by
// @ref GLFWgamepadstate.
// Unavailable buttons and axes will always report
// `GLFW_RELEASE` and 0.0 respectively.
//
// @param jid The [joystick](
// @ref joysticks)
// to query.
//
// @param state The gamepad input state of the joystick.
//
// @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if no joystick is
// connected, it has no gamepad mapping or an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_ENUM.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref gamepad
//
// @sa
// @ref glfwUpdateGamepadMappings
//
// @sa
// @ref glfwJoystickIsGamepad
//
// @since Added in version 3.3.
func GetGamepadState(jid int32, state *Gamepadstate) int32 {
	__res := bindlib.CCall2(__imp_glfwGetGamepadState.Addr(), bindlib.MarshallSyscall(jid), bindlib.MarshallSyscall(state))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwSetClipboardString bindlib.PreloadProc

// @brief Sets the clipboard to the specified string.
// This function sets the system clipboard to the specified, UTF-8 encoded
// string.
//
// @param window Deprecated.  Any valid window or `NULL`.
//
// @param string A UTF-8 encoded string.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @win32
// The clipboard on Windows has a single global lock for reading and
// writing.  GLFW tries to acquire it a few times, which is almost always enough.  If it
// cannot acquire the lock then this function emits
// @ref GLFW_PLATFORM_ERROR
// and returns.
// It is safe to try this multiple times.
//
// @pointer
// _lifetime The specified string is copied before this function
// returns.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref clipboard
//
// @sa
// @ref glfwGetClipboardString
//
// @since Added in version 3.0.
func SetClipboardString(window unsafe.Pointer, _string *byte) {
	bindlib.CCall2(__imp_glfwSetClipboardString.Addr(), bindlib.MarshallSyscall(window), bindlib.MarshallSyscall(_string))
}

var __imp_glfwGetClipboardString bindlib.PreloadProc

// @brief Returns the contents of the clipboard as a string.
// This function returns the contents of the system clipboard, if it contains
// or is convertible to a UTF-8 encoded string.  If the clipboard is empty or
// if its contents cannot be converted, `NULL` is returned and a
// @ref GLFW_FORMAT_UNAVAILABLE
// error is generated.
//
// @param window Deprecated.  Any valid window or `NULL`.
//
// @return The contents of the clipboard as a UTF-8 encoded string, or `NULL`
// if an [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_FORMAT_UNAVAILABLE
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark
// @win32
// The clipboard on Windows has a single global lock for reading and
// writing.  GLFW tries to acquire it a few times, which is almost always enough.  If it
// cannot acquire the lock then this function emits
// @ref GLFW_PLATFORM_ERROR
// and returns.
// It is safe to try this multiple times.
//
// @pointer
// _lifetime The returned string is allocated and freed by GLFW.  You
// should not free it yourself.  It is valid until the next call to
// @ref glfwGetClipboardString
// or
// @ref glfwSetClipboardString,
// or until the library
// is terminated.
//
// @thread
// _safety This function must only be called from the main thread.
//
// @sa
// @ref clipboard
//
// @sa
// @ref glfwSetClipboardString
//
// @since Added in version 3.0.
func GetClipboardString(window unsafe.Pointer) *byte {
	__res := bindlib.CCall1(__imp_glfwGetClipboardString.Addr(), bindlib.MarshallSyscall(window))
	return bindlib.UnmarshallSyscall[*byte](__res)
}

var __imp_glfwGetTime bindlib.PreloadProc

// @brief Returns the GLFW time.
// This function returns the current GLFW time, in seconds.  Unless the time
// has been set using
// @ref glfwSetTime
// it measures time elapsed since GLFW was
// initialized.
// This function and
// @ref glfwSetTime
// are helper functions on top of
// @ref glfwGetTimerFrequency
// and
// @ref glfwGetTimerValue.
// The resolution of the timer is system dependent, but is usually on the order
// of a few micro- or nanoseconds.  It uses the highest-resolution monotonic
// time source on each operating system.
//
// @return The current time, in seconds, or zero if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.  Reading and
// writing of the internal base time is not atomic, so it needs to be
// externally synchronized with calls to
// @ref glfwSetTime.
//
// @sa
// @ref time
//
// @since Added in version 1.0.
func GetTime() float64 {
	__res := bindlib.CCall0(__imp_glfwGetTime.Addr())
	return bindlib.UnmarshallSyscall[float64](__res)
}

var __imp_glfwSetTime bindlib.PreloadProc

// @brief Sets the GLFW time.
// This function sets the current GLFW time, in seconds.  The value must be
// a positive finite number less than or equal to 18446744073.0, which is
// approximately 584.5 years.
// This function and
// @ref glfwGetTime
// are helper functions on top of
// @ref glfwGetTimerFrequency
// and
// @ref glfwGetTimerValue.
//
// @param time The new value, in seconds.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_INVALID_VALUE.
//
// @remark The upper limit of GLFW time is calculated as
// floor((2
// 64
// - 1) / 10
// 9
// ) and is due to implementations
// storing nanoseconds in 64 bits.  The limit may be increased in the future.
//
// @thread
// _safety This function may be called from any thread.  Reading and
// writing of the internal base time is not atomic, so it needs to be
// externally synchronized with calls to
// @ref glfwGetTime.
//
// @sa
// @ref time
//
// @since Added in version 2.2.
func SetTime(time float64) { bindlib.CCall1(__imp_glfwSetTime.Addr(), bindlib.MarshallSyscall(time)) }

var __imp_glfwGetTimerValue bindlib.PreloadProc

// @brief Returns the current value of the raw timer.
// This function returns the current value of the raw timer, measured in
// 1
//
// /
//
// frequency seconds.  To get the frequency, call
// @ref glfwGetTimerFrequency.
//
// @return The value of the timer, or zero if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref time
//
// @sa
// @ref glfwGetTimerFrequency
//
// @since Added in version 3.2.
func GetTimerValue() uint64 {
	__res := bindlib.CCall0(__imp_glfwGetTimerValue.Addr())
	return bindlib.UnmarshallSyscall[uint64](__res)
}

var __imp_glfwGetTimerFrequency bindlib.PreloadProc

// @brief Returns the frequency, in Hz, of the raw timer.
// This function returns the frequency, in Hz, of the raw timer.
//
// @return The frequency of the timer, in Hz, or zero if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref time
//
// @sa
// @ref glfwGetTimerValue
//
// @since Added in version 3.2.
func GetTimerFrequency() uint64 {
	__res := bindlib.CCall0(__imp_glfwGetTimerFrequency.Addr())
	return bindlib.UnmarshallSyscall[uint64](__res)
}

var __imp_glfwMakeContextCurrent bindlib.PreloadProc

// @brief Makes the context of the specified window current for the calling
// thread.
// This function makes the OpenGL or OpenGL ES context of the specified window
// current on the calling thread.  It can also detach the current context from
// the calling thread without making a new one current by passing in `NULL`.
// A context must only be made current on a single thread at a time and each
// thread can have only a single current context at a time.  Making a context
// current detaches any previously current context on the calling thread.
// When moving a context between threads, you must detach it (make it
// non-current) on the old thread before making it current on the new one.
// By default, making a context non-current implicitly forces a pipeline flush.
// On machines that support `GL_KHR_context_flush_control`, you can control
// whether a context performs this flush by setting the
// [GLFW_CONTEXT_RELEASE_BEHAVIOR](
// @ref GLFW_CONTEXT_RELEASE_BEHAVIOR_hint)
// hint.
// The specified window must have an OpenGL or OpenGL ES context.  Specifying
// a window without a context will generate a
// @ref GLFW_NO_WINDOW_CONTEXT
// error.
//
// @param window The window whose context to make current, or `NULL` to
// detach the current context.
//
// @remarks If the previously current context was created via a different
// context creation API than the one passed to this function, GLFW will still
// detach the previous one from its API before making the new one current.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_NO_WINDOW_CONTEXT
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref context_current
//
// @sa
// @ref glfwGetCurrentContext
//
// @since Added in version 3.0.
func MakeContextCurrent(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwMakeContextCurrent.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwGetCurrentContext bindlib.PreloadProc

// @brief Returns the window whose context is current on the calling thread.
// This function returns the window whose OpenGL or OpenGL ES context is
// current on the calling thread.
//
// @return The window whose context is current, or `NULL` if no window's
// context is current.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref context_current
//
// @sa
// @ref glfwMakeContextCurrent
//
// @since Added in version 3.0.
func GetCurrentContext() unsafe.Pointer {
	__res := bindlib.CCall0(__imp_glfwGetCurrentContext.Addr())
	return bindlib.UnmarshallSyscall[unsafe.Pointer](__res)
}

var __imp_glfwSwapBuffers bindlib.PreloadProc

// @brief Swaps the front and back buffers of the specified window.
// This function swaps the front and back buffers of the specified window when
// rendering with OpenGL or OpenGL ES.  If the swap interval is greater than
// zero, the GPU driver waits the specified number of screen updates before
// swapping the buffers.
// The specified window must have an OpenGL or OpenGL ES context.  Specifying
// a window without a context will generate a
// @ref GLFW_NO_WINDOW_CONTEXT
// error.
// This function does not apply to Vulkan.  If you are rendering with Vulkan,
// see `vkQueuePresentKHR` instead.
//
// @param window The window whose buffers to swap.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_NO_WINDOW_CONTEXT
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark __EGL:__ The context of the specified window must be current on the
// calling thread.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref buffer_swap
//
// @sa
// @ref glfwSwapInterval
//
// @since Added in version 1.0.
//
// @glfw3
// Added window handle parameter.
func SwapBuffers(window unsafe.Pointer) {
	bindlib.CCall1(__imp_glfwSwapBuffers.Addr(), bindlib.MarshallSyscall(window))
}

var __imp_glfwSwapInterval bindlib.PreloadProc

// @brief Sets the swap interval for the current context.
// This function sets the swap interval for the current OpenGL or OpenGL ES
// context, i.e. the number of screen updates to wait from the time
// @ref glfwSwapBuffers
// was called before swapping the buffers and returning.  This
// is sometimes called _vertical synchronization_, _vertical retrace
// synchronization_ or just _vsync_.
// A context that supports either of the `WGL_EXT_swap_control_tear` and
// `GLX_EXT_swap_control_tear` extensions also accepts _negative_ swap
// intervals, which allows the driver to swap immediately even if a frame
// arrives a little bit late.  You can check for these extensions with
// @ref glfwExtensionSupported.
// A context must be current on the calling thread.  Calling this function
// without a current context will cause a
// @ref GLFW_NO_CURRENT_CONTEXT
// error.
// This function does not apply to Vulkan.  If you are rendering with Vulkan,
// see the present mode of your swapchain instead.
//
// @param interval The minimum number of screen updates to wait for
// until the buffers are swapped by
// @ref glfwSwapBuffers.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_NO_CURRENT_CONTEXT
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark This function is not called during context creation, leaving the
// swap interval set to whatever is the default for that API.  This is done
// because some swap interval extensions used by GLFW do not allow the swap
// interval to be reset to zero once it has been set to a non-zero value.
//
// @remark Some GPU drivers do not honor the requested swap interval, either
// because of a user setting that overrides the application's request or due to
// bugs in the driver.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref buffer_swap
//
// @sa
// @ref glfwSwapBuffers
//
// @since Added in version 1.0.
func SwapInterval(interval int32) {
	bindlib.CCall1(__imp_glfwSwapInterval.Addr(), bindlib.MarshallSyscall(interval))
}

var __imp_glfwExtensionSupported bindlib.PreloadProc

// @brief Returns whether the specified extension is available.
// This function returns whether the specified
// [API extension](
// @ref context_glext)
// is supported by the current OpenGL or
// OpenGL ES context.  It searches both for client API extension and context
// creation API extensions.
// A context must be current on the calling thread.  Calling this function
// without a current context will cause a
// @ref GLFW_NO_CURRENT_CONTEXT
// error.
// As this functions retrieves and searches one or more extension strings each
// call, it is recommended that you cache its results if it is going to be used
// frequently.  The extension strings will not change during the lifetime of
// a context, so there is no danger in doing this.
// This function does not apply to Vulkan.  If you are using Vulkan, see
// @ref glfwGetRequiredInstanceExtensions,
// `vkEnumerateInstanceExtensionProperties`
// and `vkEnumerateDeviceExtensionProperties` instead.
//
// @param extension The ASCII encoded name of the extension.
//
// @return `GLFW_TRUE` if the extension is available, or `GLFW_FALSE`
// otherwise.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_NO_CURRENT_CONTEXT,
//
// @ref GLFW_INVALID_VALUE
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref context_glext
//
// @sa
// @ref glfwGetProcAddress
//
// @since Added in version 1.0.
func ExtensionSupported(extension *byte) int32 {
	__res := bindlib.CCall1(__imp_glfwExtensionSupported.Addr(), bindlib.MarshallSyscall(extension))
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetProcAddress bindlib.PreloadProc

// @brief Returns the address of the specified function for the current
// context.
// This function returns the address of the specified OpenGL or OpenGL ES
// [core or extension function](
// @ref context_glext),
// if it is supported
// by the current context.
// A context must be current on the calling thread.  Calling this function
// without a current context will cause a
// @ref GLFW_NO_CURRENT_CONTEXT
// error.
// This function does not apply to Vulkan.  If you are rendering with Vulkan,
// see
// @ref glfwGetInstanceProcAddress,
// `vkGetInstanceProcAddr` and
// `vkGetDeviceProcAddr` instead.
//
// @param procname The ASCII encoded name of the function.
//
// @return The address of the function, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED,
//
// @ref GLFW_NO_CURRENT_CONTEXT
// and
// @ref GLFW_PLATFORM_ERROR.
//
// @remark The address of a given function is not guaranteed to be the same
// between contexts.
//
// @remark This function may return a non-`NULL` address despite the
// associated version or extension not being available.  Always check the
// context version or extension string first.
//
// @pointer
// _lifetime The returned function pointer is valid until the context
// is destroyed or the library is terminated.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref context_glext
//
// @sa
// @ref glfwExtensionSupported
//
// @since Added in version 1.0.
func GetProcAddress(procname *byte) Glproc {
	__res := bindlib.CCall1(__imp_glfwGetProcAddress.Addr(), bindlib.MarshallSyscall(procname))
	return bindlib.UnmarshallSyscall[Glproc](__res)
}

var __imp_glfwVulkanSupported bindlib.PreloadProc

// @brief Returns whether the Vulkan loader and an ICD have been found.
// This function returns whether the Vulkan loader and any minimally functional
// ICD have been found.
// The availability of a Vulkan loader and even an ICD does not by itself guarantee that
// surface creation or even instance creation is possible.  Call
// @ref glfwGetRequiredInstanceExtensions
// to check whether the extensions necessary for Vulkan
// surface creation are available and
// @ref glfwGetPhysicalDevicePresentationSupport
// to
// check whether a queue family of a physical device supports image presentation.
//
// @return `GLFW_TRUE` if Vulkan is minimally available, or `GLFW_FALSE`
// otherwise.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref vulkan_support
//
// @since Added in version 3.2.
func VulkanSupported() int32 {
	__res := bindlib.CCall0(__imp_glfwVulkanSupported.Addr())
	return bindlib.UnmarshallSyscall[int32](__res)
}

var __imp_glfwGetRequiredInstanceExtensions bindlib.PreloadProc

// @brief Returns the Vulkan instance extensions required by GLFW.
// This function returns an array of names of Vulkan instance extensions required
// by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the
// list will always contain `VK_KHR_surface`, so if you don't require any
// additional extensions you can pass this list directly to the
// `VkInstanceCreateInfo` struct.
// If Vulkan is not available on the machine, this function returns `NULL` and
// generates a
// @ref GLFW_API_UNAVAILABLE
// error.  Call
// @ref glfwVulkanSupported
// to check whether Vulkan is at least minimally available.
// If Vulkan is available but no set of extensions allowing window surface
// creation was found, this function returns `NULL`.  You may still use Vulkan
// for off-screen rendering and compute work.
//
// @param count Where to store the number of extensions in the returned
// array.  This is set to zero if an error occurred.
//
// @return An array of ASCII encoded extension names, or `NULL` if an
// [error](
// @ref error_handling)
// occurred.
//
// @errors
// Possible errors include
// @ref GLFW_NOT_INITIALIZED
// and
// @ref GLFW_API_UNAVAILABLE.
//
// @remark Additional extensions may be required by future versions of GLFW.
// You should check if any extensions you wish to enable are already in the
// returned array, as it is an error to specify an extension more than once in
// the `VkInstanceCreateInfo` struct.
//
// @pointer
// _lifetime The returned array is allocated and freed by GLFW.  You
// should not free it yourself.  It is guaranteed to be valid only until the
// library is terminated.
//
// @thread
// _safety This function may be called from any thread.
//
// @sa
// @ref vulkan_ext
//
// @sa
// @ref glfwCreateWindowSurface
//
// @since Added in version 3.2.
func GetRequiredInstanceExtensions(count *uint32) **byte {
	__res := bindlib.CCall1(__imp_glfwGetRequiredInstanceExtensions.Addr(), bindlib.MarshallSyscall(count))
	return bindlib.UnmarshallSyscall[**byte](__res)
}
